/* automatically generated by rust-bindgen 0.70.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(C)]
pub struct __BindgenComplex<T> {
    pub re: T,
    pub im: T,
}
pub const _ERRNO_H: libc::c_int = 1;
pub const _FEATURES_H: libc::c_int = 1;
pub const _DEFAULT_SOURCE: libc::c_int = 1;
pub const __GLIBC_USE_ISOC2Y: libc::c_int = 0;
pub const __GLIBC_USE_ISOC23: libc::c_int = 0;
pub const __USE_ISOC11: libc::c_int = 1;
pub const __USE_ISOC99: libc::c_int = 1;
pub const __USE_ISOC95: libc::c_int = 1;
pub const __USE_POSIX_IMPLICITLY: libc::c_int = 1;
pub const _POSIX_SOURCE: libc::c_int = 1;
pub const _POSIX_C_SOURCE: libc::c_int = 200809;
pub const __USE_POSIX: libc::c_int = 1;
pub const __USE_POSIX2: libc::c_int = 1;
pub const __USE_POSIX199309: libc::c_int = 1;
pub const __USE_POSIX199506: libc::c_int = 1;
pub const __USE_XOPEN2K: libc::c_int = 1;
pub const __USE_XOPEN2K8: libc::c_int = 1;
pub const _ATFILE_SOURCE: libc::c_int = 1;
pub const __WORDSIZE: libc::c_int = 64;
pub const __WORDSIZE_TIME64_COMPAT32: libc::c_int = 1;
pub const __SYSCALL_WORDSIZE: libc::c_int = 64;
pub const __TIMESIZE: libc::c_int = 64;
pub const __USE_TIME_BITS64: libc::c_int = 1;
pub const __USE_MISC: libc::c_int = 1;
pub const __USE_ATFILE: libc::c_int = 1;
pub const __USE_FORTIFY_LEVEL: libc::c_int = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: libc::c_int = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: libc::c_int = 0;
pub const __GLIBC_USE_C23_STRTOL: libc::c_int = 0;
pub const _STDC_PREDEF_H: libc::c_int = 1;
pub const __STDC_IEC_559__: libc::c_int = 1;
pub const __STDC_IEC_60559_BFP__: libc::c_int = 201404;
pub const __STDC_IEC_559_COMPLEX__: libc::c_int = 1;
pub const __STDC_IEC_60559_COMPLEX__: libc::c_int = 201404;
pub const __STDC_ISO_10646__: libc::c_int = 201706;
pub const __GNU_LIBRARY__: libc::c_int = 6;
pub const __GLIBC__: libc::c_int = 2;
pub const __GLIBC_MINOR__: libc::c_int = 42;
pub const _SYS_CDEFS_H: libc::c_int = 1;
pub const __glibc_c99_flexarr_available: libc::c_int = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: libc::c_int = 0;
pub const __HAVE_GENERIC_SELECTION: libc::c_int = 1;
pub const _BITS_ERRNO_H: libc::c_int = 1;
pub const EPERM: libc::c_int = 1;
pub const ENOENT: libc::c_int = 2;
pub const ESRCH: libc::c_int = 3;
pub const EINTR: libc::c_int = 4;
pub const EIO: libc::c_int = 5;
pub const ENXIO: libc::c_int = 6;
pub const E2BIG: libc::c_int = 7;
pub const ENOEXEC: libc::c_int = 8;
pub const EBADF: libc::c_int = 9;
pub const ECHILD: libc::c_int = 10;
pub const EAGAIN: libc::c_int = 11;
pub const ENOMEM: libc::c_int = 12;
pub const EACCES: libc::c_int = 13;
pub const EFAULT: libc::c_int = 14;
pub const ENOTBLK: libc::c_int = 15;
pub const EBUSY: libc::c_int = 16;
pub const EEXIST: libc::c_int = 17;
pub const EXDEV: libc::c_int = 18;
pub const ENODEV: libc::c_int = 19;
pub const ENOTDIR: libc::c_int = 20;
pub const EISDIR: libc::c_int = 21;
pub const EINVAL: libc::c_int = 22;
pub const ENFILE: libc::c_int = 23;
pub const EMFILE: libc::c_int = 24;
pub const ENOTTY: libc::c_int = 25;
pub const ETXTBSY: libc::c_int = 26;
pub const EFBIG: libc::c_int = 27;
pub const ENOSPC: libc::c_int = 28;
pub const ESPIPE: libc::c_int = 29;
pub const EROFS: libc::c_int = 30;
pub const EMLINK: libc::c_int = 31;
pub const EPIPE: libc::c_int = 32;
pub const EDOM: libc::c_int = 33;
pub const ERANGE: libc::c_int = 34;
pub const EDEADLK: libc::c_int = 35;
pub const ENAMETOOLONG: libc::c_int = 36;
pub const ENOLCK: libc::c_int = 37;
pub const ENOSYS: libc::c_int = 38;
pub const ENOTEMPTY: libc::c_int = 39;
pub const ELOOP: libc::c_int = 40;
pub const EWOULDBLOCK: libc::c_int = 11;
pub const ENOMSG: libc::c_int = 42;
pub const EIDRM: libc::c_int = 43;
pub const ECHRNG: libc::c_int = 44;
pub const EL2NSYNC: libc::c_int = 45;
pub const EL3HLT: libc::c_int = 46;
pub const EL3RST: libc::c_int = 47;
pub const ELNRNG: libc::c_int = 48;
pub const EUNATCH: libc::c_int = 49;
pub const ENOCSI: libc::c_int = 50;
pub const EL2HLT: libc::c_int = 51;
pub const EBADE: libc::c_int = 52;
pub const EBADR: libc::c_int = 53;
pub const EXFULL: libc::c_int = 54;
pub const ENOANO: libc::c_int = 55;
pub const EBADRQC: libc::c_int = 56;
pub const EBADSLT: libc::c_int = 57;
pub const EDEADLOCK: libc::c_int = 35;
pub const EBFONT: libc::c_int = 59;
pub const ENOSTR: libc::c_int = 60;
pub const ENODATA: libc::c_int = 61;
pub const ETIME: libc::c_int = 62;
pub const ENOSR: libc::c_int = 63;
pub const ENONET: libc::c_int = 64;
pub const ENOPKG: libc::c_int = 65;
pub const EREMOTE: libc::c_int = 66;
pub const ENOLINK: libc::c_int = 67;
pub const EADV: libc::c_int = 68;
pub const ESRMNT: libc::c_int = 69;
pub const ECOMM: libc::c_int = 70;
pub const EPROTO: libc::c_int = 71;
pub const EMULTIHOP: libc::c_int = 72;
pub const EDOTDOT: libc::c_int = 73;
pub const EBADMSG: libc::c_int = 74;
pub const EOVERFLOW: libc::c_int = 75;
pub const ENOTUNIQ: libc::c_int = 76;
pub const EBADFD: libc::c_int = 77;
pub const EREMCHG: libc::c_int = 78;
pub const ELIBACC: libc::c_int = 79;
pub const ELIBBAD: libc::c_int = 80;
pub const ELIBSCN: libc::c_int = 81;
pub const ELIBMAX: libc::c_int = 82;
pub const ELIBEXEC: libc::c_int = 83;
pub const EILSEQ: libc::c_int = 84;
pub const ERESTART: libc::c_int = 85;
pub const ESTRPIPE: libc::c_int = 86;
pub const EUSERS: libc::c_int = 87;
pub const ENOTSOCK: libc::c_int = 88;
pub const EDESTADDRREQ: libc::c_int = 89;
pub const EMSGSIZE: libc::c_int = 90;
pub const EPROTOTYPE: libc::c_int = 91;
pub const ENOPROTOOPT: libc::c_int = 92;
pub const EPROTONOSUPPORT: libc::c_int = 93;
pub const ESOCKTNOSUPPORT: libc::c_int = 94;
pub const EOPNOTSUPP: libc::c_int = 95;
pub const EPFNOSUPPORT: libc::c_int = 96;
pub const EAFNOSUPPORT: libc::c_int = 97;
pub const EADDRINUSE: libc::c_int = 98;
pub const EADDRNOTAVAIL: libc::c_int = 99;
pub const ENETDOWN: libc::c_int = 100;
pub const ENETUNREACH: libc::c_int = 101;
pub const ENETRESET: libc::c_int = 102;
pub const ECONNABORTED: libc::c_int = 103;
pub const ECONNRESET: libc::c_int = 104;
pub const ENOBUFS: libc::c_int = 105;
pub const EISCONN: libc::c_int = 106;
pub const ENOTCONN: libc::c_int = 107;
pub const ESHUTDOWN: libc::c_int = 108;
pub const ETOOMANYREFS: libc::c_int = 109;
pub const ETIMEDOUT: libc::c_int = 110;
pub const ECONNREFUSED: libc::c_int = 111;
pub const EHOSTDOWN: libc::c_int = 112;
pub const EHOSTUNREACH: libc::c_int = 113;
pub const EALREADY: libc::c_int = 114;
pub const EINPROGRESS: libc::c_int = 115;
pub const ESTALE: libc::c_int = 116;
pub const EUCLEAN: libc::c_int = 117;
pub const ENOTNAM: libc::c_int = 118;
pub const ENAVAIL: libc::c_int = 119;
pub const EISNAM: libc::c_int = 120;
pub const EREMOTEIO: libc::c_int = 121;
pub const EDQUOT: libc::c_int = 122;
pub const ENOMEDIUM: libc::c_int = 123;
pub const EMEDIUMTYPE: libc::c_int = 124;
pub const ECANCELED: libc::c_int = 125;
pub const ENOKEY: libc::c_int = 126;
pub const EKEYEXPIRED: libc::c_int = 127;
pub const EKEYREVOKED: libc::c_int = 128;
pub const EKEYREJECTED: libc::c_int = 129;
pub const EOWNERDEAD: libc::c_int = 130;
pub const ENOTRECOVERABLE: libc::c_int = 131;
pub const ERFKILL: libc::c_int = 132;
pub const EHWPOISON: libc::c_int = 133;
pub const ENOTSUP: libc::c_int = 95;
pub const _STDINT_H: libc::c_int = 1;
pub const __GLIBC_USE_LIB_EXT2: libc::c_int = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: libc::c_int = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: libc::c_int = 0;
pub const __GLIBC_USE_IEC_60559_EXT: libc::c_int = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: libc::c_int = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: libc::c_int = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: libc::c_int = 0;
pub const _BITS_TYPES_H: libc::c_int = 1;
pub const _BITS_TYPESIZES_H: libc::c_int = 1;
pub const __OFF_T_MATCHES_OFF64_T: libc::c_int = 1;
pub const __INO_T_MATCHES_INO64_T: libc::c_int = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: libc::c_int = 1;
pub const __STATFS_MATCHES_STATFS64: libc::c_int = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: libc::c_int = 1;
pub const __FD_SETSIZE: libc::c_int = 1024;
pub const _BITS_TIME64_H: libc::c_int = 1;
pub const _BITS_WCHAR_H: libc::c_int = 1;
pub const _BITS_STDINT_INTN_H: libc::c_int = 1;
pub const _BITS_STDINT_UINTN_H: libc::c_int = 1;
pub const _BITS_STDINT_LEAST_H: libc::c_int = 1;
pub const INT8_MIN: libc::c_int = -128;
pub const INT16_MIN: libc::c_int = -32768;
pub const INT32_MIN: libc::c_int = -2147483648;
pub const INT8_MAX: libc::c_int = 127;
pub const INT16_MAX: libc::c_int = 32767;
pub const INT32_MAX: libc::c_int = 2147483647;
pub const UINT8_MAX: libc::c_int = 255;
pub const UINT16_MAX: libc::c_int = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: libc::c_int = -128;
pub const INT_LEAST16_MIN: libc::c_int = -32768;
pub const INT_LEAST32_MIN: libc::c_int = -2147483648;
pub const INT_LEAST8_MAX: libc::c_int = 127;
pub const INT_LEAST16_MAX: libc::c_int = 32767;
pub const INT_LEAST32_MAX: libc::c_int = 2147483647;
pub const UINT_LEAST8_MAX: libc::c_int = 255;
pub const UINT_LEAST16_MAX: libc::c_int = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: libc::c_int = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: libc::c_int = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: libc::c_int = 255;
pub const UINT_FAST16_MAX: libc::c_int = -1;
pub const UINT_FAST32_MAX: libc::c_int = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: libc::c_int = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: libc::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: libc::c_int = 2147483647;
pub const SIZE_MAX: libc::c_int = -1;
pub const WINT_MIN: libc::c_int = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const FF_LAMBDA_SHIFT: libc::c_int = 7;
pub const FF_LAMBDA_SCALE: libc::c_int = 128;
pub const FF_QP2LAMBDA: libc::c_int = 118;
pub const FF_LAMBDA_MAX: libc::c_int = 32767;
pub const FF_QUALITY_SCALE: libc::c_int = 128;
pub const AV_TIME_BASE: libc::c_int = 1000000;
pub const _INTTYPES_H: libc::c_int = 1;
pub const ____gwchar_t_defined: libc::c_int = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const _LIBC_LIMITS_H_: libc::c_int = 1;
pub const MB_LEN_MAX: libc::c_int = 16;
pub const _BITS_POSIX1_LIM_H: libc::c_int = 1;
pub const _POSIX_AIO_LISTIO_MAX: libc::c_int = 2;
pub const _POSIX_AIO_MAX: libc::c_int = 1;
pub const _POSIX_ARG_MAX: libc::c_int = 4096;
pub const _POSIX_CHILD_MAX: libc::c_int = 25;
pub const _POSIX_DELAYTIMER_MAX: libc::c_int = 32;
pub const _POSIX_HOST_NAME_MAX: libc::c_int = 255;
pub const _POSIX_LINK_MAX: libc::c_int = 8;
pub const _POSIX_LOGIN_NAME_MAX: libc::c_int = 9;
pub const _POSIX_MAX_CANON: libc::c_int = 255;
pub const _POSIX_MAX_INPUT: libc::c_int = 255;
pub const _POSIX_MQ_OPEN_MAX: libc::c_int = 8;
pub const _POSIX_MQ_PRIO_MAX: libc::c_int = 32;
pub const _POSIX_NAME_MAX: libc::c_int = 14;
pub const _POSIX_NGROUPS_MAX: libc::c_int = 8;
pub const _POSIX_OPEN_MAX: libc::c_int = 20;
pub const _POSIX_PATH_MAX: libc::c_int = 256;
pub const _POSIX_PIPE_BUF: libc::c_int = 512;
pub const _POSIX_RE_DUP_MAX: libc::c_int = 255;
pub const _POSIX_RTSIG_MAX: libc::c_int = 8;
pub const _POSIX_SEM_NSEMS_MAX: libc::c_int = 256;
pub const _POSIX_SEM_VALUE_MAX: libc::c_int = 32767;
pub const _POSIX_SIGQUEUE_MAX: libc::c_int = 32;
pub const _POSIX_SSIZE_MAX: libc::c_int = 32767;
pub const _POSIX_STREAM_MAX: libc::c_int = 8;
pub const _POSIX_SYMLINK_MAX: libc::c_int = 255;
pub const _POSIX_SYMLOOP_MAX: libc::c_int = 8;
pub const _POSIX_TIMER_MAX: libc::c_int = 32;
pub const _POSIX_TTY_NAME_MAX: libc::c_int = 9;
pub const _POSIX_TZNAME_MAX: libc::c_int = 6;
pub const _POSIX_CLOCKRES_MIN: libc::c_int = 20000000;
pub const NR_OPEN: libc::c_int = 1024;
pub const NGROUPS_MAX: libc::c_int = 65536;
pub const ARG_MAX: libc::c_int = 131072;
pub const LINK_MAX: libc::c_int = 127;
pub const MAX_CANON: libc::c_int = 255;
pub const MAX_INPUT: libc::c_int = 255;
pub const NAME_MAX: libc::c_int = 255;
pub const PATH_MAX: libc::c_int = 4096;
pub const PIPE_BUF: libc::c_int = 4096;
pub const XATTR_NAME_MAX: libc::c_int = 255;
pub const XATTR_SIZE_MAX: libc::c_int = 65536;
pub const XATTR_LIST_MAX: libc::c_int = 65536;
pub const RTSIG_MAX: libc::c_int = 32;
pub const _POSIX_THREAD_KEYS_MAX: libc::c_int = 128;
pub const PTHREAD_KEYS_MAX: libc::c_int = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: libc::c_int = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: libc::c_int = 4;
pub const _POSIX_THREAD_THREADS_MAX: libc::c_int = 64;
pub const AIO_PRIO_DELTA_MAX: libc::c_int = 20;
pub const PTHREAD_STACK_MIN: libc::c_int = 16384;
pub const DELAYTIMER_MAX: libc::c_int = 2147483647;
pub const TTY_NAME_MAX: libc::c_int = 32;
pub const LOGIN_NAME_MAX: libc::c_int = 256;
pub const HOST_NAME_MAX: libc::c_int = 64;
pub const MQ_PRIO_MAX: libc::c_int = 32768;
pub const SEM_VALUE_MAX: libc::c_int = 2147483647;
pub const _BITS_POSIX2_LIM_H: libc::c_int = 1;
pub const _POSIX2_BC_BASE_MAX: libc::c_int = 99;
pub const _POSIX2_BC_DIM_MAX: libc::c_int = 2048;
pub const _POSIX2_BC_SCALE_MAX: libc::c_int = 99;
pub const _POSIX2_BC_STRING_MAX: libc::c_int = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: libc::c_int = 2;
pub const _POSIX2_EXPR_NEST_MAX: libc::c_int = 32;
pub const _POSIX2_LINE_MAX: libc::c_int = 2048;
pub const _POSIX2_RE_DUP_MAX: libc::c_int = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: libc::c_int = 14;
pub const BC_BASE_MAX: libc::c_int = 99;
pub const BC_DIM_MAX: libc::c_int = 2048;
pub const BC_SCALE_MAX: libc::c_int = 99;
pub const BC_STRING_MAX: libc::c_int = 1000;
pub const COLL_WEIGHTS_MAX: libc::c_int = 255;
pub const EXPR_NEST_MAX: libc::c_int = 32;
pub const LINE_MAX: libc::c_int = 2048;
pub const CHARCLASS_NAME_MAX: libc::c_int = 2048;
pub const RE_DUP_MAX: libc::c_int = 32767;
pub const _MATH_H: libc::c_int = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: libc::c_int = 1;
pub const __HAVE_FLOAT128: libc::c_int = 1;
pub const __HAVE_DISTINCT_FLOAT128: libc::c_int = 1;
pub const __HAVE_FLOAT64X: libc::c_int = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: libc::c_int = 1;
pub const __HAVE_FLOAT16: libc::c_int = 0;
pub const __HAVE_FLOAT32: libc::c_int = 1;
pub const __HAVE_FLOAT64: libc::c_int = 1;
pub const __HAVE_FLOAT32X: libc::c_int = 1;
pub const __HAVE_FLOAT128X: libc::c_int = 0;
pub const __HAVE_DISTINCT_FLOAT16: libc::c_int = 0;
pub const __HAVE_DISTINCT_FLOAT32: libc::c_int = 0;
pub const __HAVE_DISTINCT_FLOAT64: libc::c_int = 0;
pub const __HAVE_DISTINCT_FLOAT32X: libc::c_int = 0;
pub const __HAVE_DISTINCT_FLOAT64X: libc::c_int = 0;
pub const __HAVE_DISTINCT_FLOAT128X: libc::c_int = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: libc::c_int = 0;
pub const __FP_LOGB0_IS_MIN: libc::c_int = 1;
pub const __FP_LOGBNAN_IS_MIN: libc::c_int = 1;
pub const FP_ILOGB0: libc::c_int = -2147483648;
pub const FP_ILOGBNAN: libc::c_int = -2147483648;
pub const __MATH_DECLARING_DOUBLE: libc::c_int = 1;
pub const __MATH_DECLARING_FLOATN: libc::c_int = 0;
pub const __MATH_DECLARE_LDOUBLE: libc::c_int = 1;
pub const MATH_ERRNO: libc::c_int = 1;
pub const MATH_ERREXCEPT: libc::c_int = 2;
pub const math_errhandling: libc::c_int = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _STDIO_H: libc::c_int = 1;
pub const _____fpos_t_defined: libc::c_int = 1;
pub const ____mbstate_t_defined: libc::c_int = 1;
pub const _____fpos64_t_defined: libc::c_int = 1;
pub const ____FILE_defined: libc::c_int = 1;
pub const __FILE_defined: libc::c_int = 1;
pub const __struct_FILE_defined: libc::c_int = 1;
pub const _IO_EOF_SEEN: libc::c_int = 16;
pub const _IO_ERR_SEEN: libc::c_int = 32;
pub const _IO_USER_LOCK: libc::c_int = 32768;
pub const __cookie_io_functions_t_defined: libc::c_int = 1;
pub const _IOFBF: libc::c_int = 0;
pub const _IOLBF: libc::c_int = 1;
pub const _IONBF: libc::c_int = 2;
pub const BUFSIZ: libc::c_int = 8192;
pub const EOF: libc::c_int = -1;
pub const SEEK_SET: libc::c_int = 0;
pub const SEEK_CUR: libc::c_int = 1;
pub const SEEK_END: libc::c_int = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: libc::c_int = 20;
pub const TMP_MAX: libc::c_int = 238328;
pub const _BITS_STDIO_LIM_H: libc::c_int = 1;
pub const FILENAME_MAX: libc::c_int = 4096;
pub const L_ctermid: libc::c_int = 9;
pub const FOPEN_MAX: libc::c_int = 16;
pub const _STDLIB_H: libc::c_int = 1;
pub const WNOHANG: libc::c_int = 1;
pub const WUNTRACED: libc::c_int = 2;
pub const WSTOPPED: libc::c_int = 2;
pub const WEXITED: libc::c_int = 4;
pub const WCONTINUED: libc::c_int = 8;
pub const WNOWAIT: libc::c_int = 16777216;
pub const __WNOTHREAD: libc::c_int = 536870912;
pub const __WALL: libc::c_int = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: libc::c_int = 65535;
pub const __WCOREFLAG: libc::c_int = 128;
pub const __ldiv_t_defined: libc::c_int = 1;
pub const __lldiv_t_defined: libc::c_int = 1;
pub const RAND_MAX: libc::c_int = 2147483647;
pub const EXIT_FAILURE: libc::c_int = 1;
pub const EXIT_SUCCESS: libc::c_int = 0;
pub const _SYS_TYPES_H: libc::c_int = 1;
pub const __clock_t_defined: libc::c_int = 1;
pub const __clockid_t_defined: libc::c_int = 1;
pub const __time_t_defined: libc::c_int = 1;
pub const __timer_t_defined: libc::c_int = 1;
pub const __BIT_TYPES_DEFINED__: libc::c_int = 1;
pub const _ENDIAN_H: libc::c_int = 1;
pub const _BITS_ENDIAN_H: libc::c_int = 1;
pub const __LITTLE_ENDIAN: libc::c_int = 1234;
pub const __BIG_ENDIAN: libc::c_int = 4321;
pub const __PDP_ENDIAN: libc::c_int = 3412;
pub const _BITS_ENDIANNESS_H: libc::c_int = 1;
pub const __BYTE_ORDER: libc::c_int = 1234;
pub const __FLOAT_WORD_ORDER: libc::c_int = 1234;
pub const LITTLE_ENDIAN: libc::c_int = 1234;
pub const BIG_ENDIAN: libc::c_int = 4321;
pub const PDP_ENDIAN: libc::c_int = 3412;
pub const BYTE_ORDER: libc::c_int = 1234;
pub const _BITS_BYTESWAP_H: libc::c_int = 1;
pub const _BITS_UINTN_IDENTITY_H: libc::c_int = 1;
pub const _SYS_SELECT_H: libc::c_int = 1;
pub const __sigset_t_defined: libc::c_int = 1;
pub const __timeval_defined: libc::c_int = 1;
pub const _STRUCT_TIMESPEC: libc::c_int = 1;
pub const FD_SETSIZE: libc::c_int = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: libc::c_int = 1;
pub const _THREAD_SHARED_TYPES_H: libc::c_int = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: libc::c_int = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: libc::c_int = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: libc::c_int = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: libc::c_int = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: libc::c_int = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: libc::c_int = 4;
pub const __SIZEOF_PTHREAD_COND_T: libc::c_int = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: libc::c_int = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: libc::c_int = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: libc::c_int = 4;
pub const _THREAD_MUTEX_INTERNAL_H: libc::c_int = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: libc::c_int = 1;
pub const __have_pthread_attr_t: libc::c_int = 1;
pub const _ALLOCA_H: libc::c_int = 1;
pub const _STRING_H: libc::c_int = 1;
pub const _BITS_TYPES_LOCALE_T_H: libc::c_int = 1;
pub const _BITS_TYPES___LOCALE_T_H: libc::c_int = 1;
pub const _STRINGS_H: libc::c_int = 1;
pub const LIBAVUTIL_VERSION_MAJOR: libc::c_int = 56;
pub const LIBAVUTIL_VERSION_MINOR: libc::c_int = 70;
pub const LIBAVUTIL_VERSION_MICRO: libc::c_int = 100;
pub const AV_HAVE_BIGENDIAN: libc::c_int = 0;
pub const AV_HAVE_FAST_UNALIGNED: libc::c_int = 1;
pub const AVERROR_EXPERIMENTAL: libc::c_int = -733130664;
pub const AVERROR_INPUT_CHANGED: libc::c_int = -1668179713;
pub const AVERROR_OUTPUT_CHANGED: libc::c_int = -1668179714;
pub const AV_ERROR_MAX_STRING_SIZE: usize = 64;
pub const M_LOG2_10: f64 = 3.321928094887362;
pub const M_PHI: f64 = 1.618033988749895;
pub const AV_LOG_QUIET: libc::c_int = -8;
pub const AV_LOG_PANIC: libc::c_int = 0;
pub const AV_LOG_FATAL: libc::c_int = 8;
pub const AV_LOG_ERROR: libc::c_int = 16;
pub const AV_LOG_WARNING: libc::c_int = 24;
pub const AV_LOG_INFO: libc::c_int = 32;
pub const AV_LOG_VERBOSE: libc::c_int = 40;
pub const AV_LOG_DEBUG: libc::c_int = 48;
pub const AV_LOG_TRACE: libc::c_int = 56;
pub const AV_LOG_MAX_OFFSET: libc::c_int = 64;
pub const AV_LOG_SKIP_REPEATED: libc::c_int = 1;
pub const AV_LOG_PRINT_LEVEL: libc::c_int = 2;
pub const AVPALETTE_SIZE: libc::c_int = 1024;
pub const AVPALETTE_COUNT: libc::c_int = 256;
pub const AV_FOURCC_MAX_STRING_SIZE: libc::c_int = 32;
pub const AV_BUFFER_FLAG_READONLY: libc::c_int = 1;
pub const AV_CPU_FLAG_FORCE: u32 = 2147483648;
pub const AV_CPU_FLAG_MMX: libc::c_int = 1;
pub const AV_CPU_FLAG_MMXEXT: libc::c_int = 2;
pub const AV_CPU_FLAG_MMX2: libc::c_int = 2;
pub const AV_CPU_FLAG_3DNOW: libc::c_int = 4;
pub const AV_CPU_FLAG_SSE: libc::c_int = 8;
pub const AV_CPU_FLAG_SSE2: libc::c_int = 16;
pub const AV_CPU_FLAG_SSE2SLOW: libc::c_int = 1073741824;
pub const AV_CPU_FLAG_3DNOWEXT: libc::c_int = 32;
pub const AV_CPU_FLAG_SSE3: libc::c_int = 64;
pub const AV_CPU_FLAG_SSE3SLOW: libc::c_int = 536870912;
pub const AV_CPU_FLAG_SSSE3: libc::c_int = 128;
pub const AV_CPU_FLAG_SSSE3SLOW: libc::c_int = 67108864;
pub const AV_CPU_FLAG_ATOM: libc::c_int = 268435456;
pub const AV_CPU_FLAG_SSE4: libc::c_int = 256;
pub const AV_CPU_FLAG_SSE42: libc::c_int = 512;
pub const AV_CPU_FLAG_AESNI: libc::c_int = 524288;
pub const AV_CPU_FLAG_AVX: libc::c_int = 16384;
pub const AV_CPU_FLAG_AVXSLOW: libc::c_int = 134217728;
pub const AV_CPU_FLAG_XOP: libc::c_int = 1024;
pub const AV_CPU_FLAG_FMA4: libc::c_int = 2048;
pub const AV_CPU_FLAG_CMOV: libc::c_int = 4096;
pub const AV_CPU_FLAG_AVX2: libc::c_int = 32768;
pub const AV_CPU_FLAG_FMA3: libc::c_int = 65536;
pub const AV_CPU_FLAG_BMI1: libc::c_int = 131072;
pub const AV_CPU_FLAG_BMI2: libc::c_int = 262144;
pub const AV_CPU_FLAG_AVX512: libc::c_int = 1048576;
pub const AV_CPU_FLAG_ALTIVEC: libc::c_int = 1;
pub const AV_CPU_FLAG_VSX: libc::c_int = 2;
pub const AV_CPU_FLAG_POWER8: libc::c_int = 4;
pub const AV_CPU_FLAG_ARMV5TE: libc::c_int = 1;
pub const AV_CPU_FLAG_ARMV6: libc::c_int = 2;
pub const AV_CPU_FLAG_ARMV6T2: libc::c_int = 4;
pub const AV_CPU_FLAG_VFP: libc::c_int = 8;
pub const AV_CPU_FLAG_VFPV3: libc::c_int = 16;
pub const AV_CPU_FLAG_NEON: libc::c_int = 32;
pub const AV_CPU_FLAG_ARMV8: libc::c_int = 64;
pub const AV_CPU_FLAG_VFP_VM: libc::c_int = 128;
pub const AV_CPU_FLAG_SETEND: libc::c_int = 65536;
pub const AV_CPU_FLAG_MMI: libc::c_int = 1;
pub const AV_CPU_FLAG_MSA: libc::c_int = 2;
pub const AV_CH_FRONT_LEFT: libc::c_ulonglong = 1;
pub const AV_CH_FRONT_RIGHT: libc::c_ulonglong = 2;
pub const AV_CH_FRONT_CENTER: libc::c_ulonglong = 4;
pub const AV_CH_LOW_FREQUENCY: libc::c_ulonglong = 8;
pub const AV_CH_BACK_LEFT: libc::c_ulonglong = 16;
pub const AV_CH_BACK_RIGHT: libc::c_ulonglong = 32;
pub const AV_CH_FRONT_LEFT_OF_CENTER: libc::c_ulonglong = 64;
pub const AV_CH_FRONT_RIGHT_OF_CENTER: libc::c_ulonglong = 128;
pub const AV_CH_BACK_CENTER: libc::c_ulonglong = 256;
pub const AV_CH_SIDE_LEFT: libc::c_ulonglong = 512;
pub const AV_CH_SIDE_RIGHT: libc::c_ulonglong = 1024;
pub const AV_CH_TOP_CENTER: libc::c_ulonglong = 2048;
pub const AV_CH_TOP_FRONT_LEFT: libc::c_ulonglong = 4096;
pub const AV_CH_TOP_FRONT_CENTER: libc::c_ulonglong = 8192;
pub const AV_CH_TOP_FRONT_RIGHT: libc::c_ulonglong = 16384;
pub const AV_CH_TOP_BACK_LEFT: libc::c_ulonglong = 32768;
pub const AV_CH_TOP_BACK_CENTER: libc::c_ulonglong = 65536;
pub const AV_CH_TOP_BACK_RIGHT: libc::c_ulonglong = 131072;
pub const AV_CH_STEREO_LEFT: libc::c_ulonglong = 536870912;
pub const AV_CH_STEREO_RIGHT: libc::c_ulonglong = 1073741824;
pub const AV_CH_WIDE_LEFT: libc::c_ulonglong = 2147483648;
pub const AV_CH_WIDE_RIGHT: libc::c_ulonglong = 4294967296;
pub const AV_CH_SURROUND_DIRECT_LEFT: libc::c_ulonglong = 8589934592;
pub const AV_CH_SURROUND_DIRECT_RIGHT: libc::c_ulonglong = 17179869184;
pub const AV_CH_LOW_FREQUENCY_2: libc::c_ulonglong = 34359738368;
pub const AV_CH_TOP_SIDE_LEFT: libc::c_ulonglong = 68719476736;
pub const AV_CH_TOP_SIDE_RIGHT: libc::c_ulonglong = 137438953472;
pub const AV_CH_BOTTOM_FRONT_CENTER: libc::c_ulonglong = 274877906944;
pub const AV_CH_BOTTOM_FRONT_LEFT: libc::c_ulonglong = 549755813888;
pub const AV_CH_BOTTOM_FRONT_RIGHT: libc::c_ulonglong = 1099511627776;
pub const AV_CH_LAYOUT_NATIVE: libc::c_ulonglong = 9223372036854775808;
pub const AV_CH_LAYOUT_MONO: libc::c_ulonglong = 4;
pub const AV_CH_LAYOUT_STEREO: libc::c_ulonglong = 3;
pub const AV_CH_LAYOUT_2POINT1: libc::c_ulonglong = 11;
pub const AV_CH_LAYOUT_2_1: libc::c_ulonglong = 259;
pub const AV_CH_LAYOUT_SURROUND: libc::c_ulonglong = 7;
pub const AV_CH_LAYOUT_3POINT1: libc::c_ulonglong = 15;
pub const AV_CH_LAYOUT_4POINT0: libc::c_ulonglong = 263;
pub const AV_CH_LAYOUT_4POINT1: libc::c_ulonglong = 271;
pub const AV_CH_LAYOUT_2_2: libc::c_ulonglong = 1539;
pub const AV_CH_LAYOUT_QUAD: libc::c_ulonglong = 51;
pub const AV_CH_LAYOUT_5POINT0: libc::c_ulonglong = 1543;
pub const AV_CH_LAYOUT_5POINT1: libc::c_ulonglong = 1551;
pub const AV_CH_LAYOUT_5POINT0_BACK: libc::c_ulonglong = 55;
pub const AV_CH_LAYOUT_5POINT1_BACK: libc::c_ulonglong = 63;
pub const AV_CH_LAYOUT_6POINT0: libc::c_ulonglong = 1799;
pub const AV_CH_LAYOUT_6POINT0_FRONT: libc::c_ulonglong = 1731;
pub const AV_CH_LAYOUT_HEXAGONAL: libc::c_ulonglong = 311;
pub const AV_CH_LAYOUT_6POINT1: libc::c_ulonglong = 1807;
pub const AV_CH_LAYOUT_6POINT1_BACK: libc::c_ulonglong = 319;
pub const AV_CH_LAYOUT_6POINT1_FRONT: libc::c_ulonglong = 1739;
pub const AV_CH_LAYOUT_7POINT0: libc::c_ulonglong = 1591;
pub const AV_CH_LAYOUT_7POINT0_FRONT: libc::c_ulonglong = 1735;
pub const AV_CH_LAYOUT_7POINT1: libc::c_ulonglong = 1599;
pub const AV_CH_LAYOUT_7POINT1_WIDE: libc::c_ulonglong = 1743;
pub const AV_CH_LAYOUT_7POINT1_WIDE_BACK: libc::c_ulonglong = 255;
pub const AV_CH_LAYOUT_OCTAGONAL: libc::c_ulonglong = 1847;
pub const AV_CH_LAYOUT_HEXADECAGONAL: libc::c_ulonglong = 6442710839;
pub const AV_CH_LAYOUT_STEREO_DOWNMIX: libc::c_ulonglong = 1610612736;
pub const AV_CH_LAYOUT_22POINT2: libc::c_ulonglong = 2164663779327;
pub const AV_DICT_MATCH_CASE: libc::c_int = 1;
pub const AV_DICT_IGNORE_SUFFIX: libc::c_int = 2;
pub const AV_DICT_DONT_STRDUP_KEY: libc::c_int = 4;
pub const AV_DICT_DONT_STRDUP_VAL: libc::c_int = 8;
pub const AV_DICT_DONT_OVERWRITE: libc::c_int = 16;
pub const AV_DICT_APPEND: libc::c_int = 32;
pub const AV_DICT_MULTIKEY: libc::c_int = 64;
pub const AV_NUM_DATA_POINTERS: libc::c_int = 8;
pub const AV_FRAME_FLAG_CORRUPT: libc::c_int = 1;
pub const AV_FRAME_FLAG_DISCARD: libc::c_int = 4;
pub const FF_DECODE_ERROR_INVALID_BITSTREAM: libc::c_int = 1;
pub const FF_DECODE_ERROR_MISSING_REFERENCE: libc::c_int = 2;
pub const FF_DECODE_ERROR_CONCEALMENT_ACTIVE: libc::c_int = 4;
pub const FF_DECODE_ERROR_DECODE_SLICES: libc::c_int = 8;
pub const LIBAVCODEC_VERSION_MAJOR: libc::c_int = 58;
pub const LIBAVCODEC_VERSION_MINOR: libc::c_int = 134;
pub const LIBAVCODEC_VERSION_MICRO: libc::c_int = 100;
pub const AV_PKT_FLAG_KEY: libc::c_int = 1;
pub const AV_PKT_FLAG_CORRUPT: libc::c_int = 2;
pub const AV_PKT_FLAG_DISCARD: libc::c_int = 4;
pub const AV_PKT_FLAG_TRUSTED: libc::c_int = 8;
pub const AV_PKT_FLAG_DISPOSABLE: libc::c_int = 16;
pub const AV_CODEC_CAP_DRAW_HORIZ_BAND: libc::c_uint = 1;
pub const AV_CODEC_CAP_DR1: libc::c_uint = 2;
pub const AV_CODEC_CAP_TRUNCATED: libc::c_uint = 8;
pub const AV_CODEC_CAP_DELAY: libc::c_uint = 32;
pub const AV_CODEC_CAP_SMALL_LAST_FRAME: libc::c_uint = 64;
pub const AV_CODEC_CAP_SUBFRAMES: libc::c_uint = 256;
pub const AV_CODEC_CAP_EXPERIMENTAL: libc::c_uint = 512;
pub const AV_CODEC_CAP_CHANNEL_CONF: libc::c_uint = 1024;
pub const AV_CODEC_CAP_FRAME_THREADS: libc::c_uint = 4096;
pub const AV_CODEC_CAP_SLICE_THREADS: libc::c_uint = 8192;
pub const AV_CODEC_CAP_PARAM_CHANGE: libc::c_uint = 16384;
pub const AV_CODEC_CAP_OTHER_THREADS: libc::c_uint = 32768;
pub const AV_CODEC_CAP_AUTO_THREADS: libc::c_uint = 32768;
pub const AV_CODEC_CAP_VARIABLE_FRAME_SIZE: libc::c_uint = 65536;
pub const AV_CODEC_CAP_AVOID_PROBING: libc::c_uint = 131072;
pub const AV_CODEC_CAP_INTRA_ONLY: libc::c_uint = 1073741824;
pub const AV_CODEC_CAP_LOSSLESS: u32 = 2147483648;
pub const AV_CODEC_CAP_HARDWARE: libc::c_uint = 262144;
pub const AV_CODEC_CAP_HYBRID: libc::c_uint = 524288;
pub const AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE: libc::c_uint = 1048576;
pub const AV_CODEC_CAP_ENCODER_FLUSH: libc::c_uint = 2097152;
pub const AV_CODEC_PROP_INTRA_ONLY: libc::c_int = 1;
pub const AV_CODEC_PROP_LOSSY: libc::c_int = 2;
pub const AV_CODEC_PROP_LOSSLESS: libc::c_int = 4;
pub const AV_CODEC_PROP_REORDER: libc::c_int = 8;
pub const AV_CODEC_PROP_BITMAP_SUB: libc::c_int = 65536;
pub const AV_CODEC_PROP_TEXT_SUB: libc::c_int = 131072;
pub const AV_INPUT_BUFFER_PADDING_SIZE: libc::c_int = 64;
pub const AV_INPUT_BUFFER_MIN_SIZE: libc::c_int = 16384;
pub const AV_CODEC_FLAG_UNALIGNED: libc::c_uint = 1;
pub const AV_CODEC_FLAG_QSCALE: libc::c_uint = 2;
pub const AV_CODEC_FLAG_4MV: libc::c_uint = 4;
pub const AV_CODEC_FLAG_OUTPUT_CORRUPT: libc::c_uint = 8;
pub const AV_CODEC_FLAG_QPEL: libc::c_uint = 16;
pub const AV_CODEC_FLAG_DROPCHANGED: libc::c_uint = 32;
pub const AV_CODEC_FLAG_PASS1: libc::c_uint = 512;
pub const AV_CODEC_FLAG_PASS2: libc::c_uint = 1024;
pub const AV_CODEC_FLAG_LOOP_FILTER: libc::c_uint = 2048;
pub const AV_CODEC_FLAG_GRAY: libc::c_uint = 8192;
pub const AV_CODEC_FLAG_PSNR: libc::c_uint = 32768;
pub const AV_CODEC_FLAG_TRUNCATED: libc::c_uint = 65536;
pub const AV_CODEC_FLAG_INTERLACED_DCT: libc::c_uint = 262144;
pub const AV_CODEC_FLAG_LOW_DELAY: libc::c_uint = 524288;
pub const AV_CODEC_FLAG_GLOBAL_HEADER: libc::c_uint = 4194304;
pub const AV_CODEC_FLAG_BITEXACT: libc::c_uint = 8388608;
pub const AV_CODEC_FLAG_AC_PRED: libc::c_uint = 16777216;
pub const AV_CODEC_FLAG_INTERLACED_ME: libc::c_uint = 536870912;
pub const AV_CODEC_FLAG_CLOSED_GOP: u32 = 2147483648;
pub const AV_CODEC_FLAG2_FAST: libc::c_int = 1;
pub const AV_CODEC_FLAG2_NO_OUTPUT: libc::c_int = 4;
pub const AV_CODEC_FLAG2_LOCAL_HEADER: libc::c_int = 8;
pub const AV_CODEC_FLAG2_DROP_FRAME_TIMECODE: libc::c_int = 8192;
pub const AV_CODEC_FLAG2_CHUNKS: libc::c_int = 32768;
pub const AV_CODEC_FLAG2_IGNORE_CROP: libc::c_int = 65536;
pub const AV_CODEC_FLAG2_SHOW_ALL: libc::c_int = 4194304;
pub const AV_CODEC_FLAG2_EXPORT_MVS: libc::c_int = 268435456;
pub const AV_CODEC_FLAG2_SKIP_MANUAL: libc::c_int = 536870912;
pub const AV_CODEC_FLAG2_RO_FLUSH_NOOP: libc::c_int = 1073741824;
pub const AV_CODEC_EXPORT_DATA_MVS: libc::c_int = 1;
pub const AV_CODEC_EXPORT_DATA_PRFT: libc::c_int = 2;
pub const AV_CODEC_EXPORT_DATA_VIDEO_ENC_PARAMS: libc::c_int = 4;
pub const AV_CODEC_EXPORT_DATA_FILM_GRAIN: libc::c_int = 8;
pub const AV_GET_BUFFER_FLAG_REF: libc::c_int = 1;
pub const AV_GET_ENCODE_BUFFER_FLAG_REF: libc::c_int = 1;
pub const FF_COMPRESSION_DEFAULT: libc::c_int = -1;
pub const FF_PRED_LEFT: libc::c_int = 0;
pub const FF_PRED_PLANE: libc::c_int = 1;
pub const FF_PRED_MEDIAN: libc::c_int = 2;
pub const FF_CMP_SAD: libc::c_int = 0;
pub const FF_CMP_SSE: libc::c_int = 1;
pub const FF_CMP_SATD: libc::c_int = 2;
pub const FF_CMP_DCT: libc::c_int = 3;
pub const FF_CMP_PSNR: libc::c_int = 4;
pub const FF_CMP_BIT: libc::c_int = 5;
pub const FF_CMP_RD: libc::c_int = 6;
pub const FF_CMP_ZERO: libc::c_int = 7;
pub const FF_CMP_VSAD: libc::c_int = 8;
pub const FF_CMP_VSSE: libc::c_int = 9;
pub const FF_CMP_NSSE: libc::c_int = 10;
pub const FF_CMP_W53: libc::c_int = 11;
pub const FF_CMP_W97: libc::c_int = 12;
pub const FF_CMP_DCTMAX: libc::c_int = 13;
pub const FF_CMP_DCT264: libc::c_int = 14;
pub const FF_CMP_MEDIAN_SAD: libc::c_int = 15;
pub const FF_CMP_CHROMA: libc::c_int = 256;
pub const SLICE_FLAG_CODED_ORDER: libc::c_int = 1;
pub const SLICE_FLAG_ALLOW_FIELD: libc::c_int = 2;
pub const SLICE_FLAG_ALLOW_PLANE: libc::c_int = 4;
pub const FF_MB_DECISION_SIMPLE: libc::c_int = 0;
pub const FF_MB_DECISION_BITS: libc::c_int = 1;
pub const FF_MB_DECISION_RD: libc::c_int = 2;
pub const FF_CODER_TYPE_VLC: libc::c_int = 0;
pub const FF_CODER_TYPE_AC: libc::c_int = 1;
pub const FF_CODER_TYPE_RAW: libc::c_int = 2;
pub const FF_CODER_TYPE_RLE: libc::c_int = 3;
pub const FF_BUG_AUTODETECT: libc::c_int = 1;
pub const FF_BUG_XVID_ILACE: libc::c_int = 4;
pub const FF_BUG_UMP4: libc::c_int = 8;
pub const FF_BUG_NO_PADDING: libc::c_int = 16;
pub const FF_BUG_AMV: libc::c_int = 32;
pub const FF_BUG_QPEL_CHROMA: libc::c_int = 64;
pub const FF_BUG_STD_QPEL: libc::c_int = 128;
pub const FF_BUG_QPEL_CHROMA2: libc::c_int = 256;
pub const FF_BUG_DIRECT_BLOCKSIZE: libc::c_int = 512;
pub const FF_BUG_EDGE: libc::c_int = 1024;
pub const FF_BUG_HPEL_CHROMA: libc::c_int = 2048;
pub const FF_BUG_DC_CLIP: libc::c_int = 4096;
pub const FF_BUG_MS: libc::c_int = 8192;
pub const FF_BUG_TRUNCATED: libc::c_int = 16384;
pub const FF_BUG_IEDGE: libc::c_int = 32768;
pub const FF_COMPLIANCE_VERY_STRICT: libc::c_int = 2;
pub const FF_COMPLIANCE_STRICT: libc::c_int = 1;
pub const FF_COMPLIANCE_NORMAL: libc::c_int = 0;
pub const FF_COMPLIANCE_UNOFFICIAL: libc::c_int = -1;
pub const FF_COMPLIANCE_EXPERIMENTAL: libc::c_int = -2;
pub const FF_EC_GUESS_MVS: libc::c_int = 1;
pub const FF_EC_DEBLOCK: libc::c_int = 2;
pub const FF_EC_FAVOR_INTER: libc::c_int = 256;
pub const FF_DEBUG_PICT_INFO: libc::c_int = 1;
pub const FF_DEBUG_RC: libc::c_int = 2;
pub const FF_DEBUG_BITSTREAM: libc::c_int = 4;
pub const FF_DEBUG_MB_TYPE: libc::c_int = 8;
pub const FF_DEBUG_QP: libc::c_int = 16;
pub const FF_DEBUG_DCT_COEFF: libc::c_int = 64;
pub const FF_DEBUG_SKIP: libc::c_int = 128;
pub const FF_DEBUG_STARTCODE: libc::c_int = 256;
pub const FF_DEBUG_ER: libc::c_int = 1024;
pub const FF_DEBUG_MMCO: libc::c_int = 2048;
pub const FF_DEBUG_BUGS: libc::c_int = 4096;
pub const FF_DEBUG_BUFFERS: libc::c_int = 32768;
pub const FF_DEBUG_THREADS: libc::c_int = 65536;
pub const FF_DEBUG_GREEN_MD: libc::c_int = 8388608;
pub const FF_DEBUG_NOMC: libc::c_int = 16777216;
pub const AV_EF_CRCCHECK: libc::c_int = 1;
pub const AV_EF_BITSTREAM: libc::c_int = 2;
pub const AV_EF_BUFFER: libc::c_int = 4;
pub const AV_EF_EXPLODE: libc::c_int = 8;
pub const AV_EF_IGNORE_ERR: libc::c_int = 32768;
pub const AV_EF_CAREFUL: libc::c_int = 65536;
pub const AV_EF_COMPLIANT: libc::c_int = 131072;
pub const AV_EF_AGGRESSIVE: libc::c_int = 262144;
pub const FF_DCT_AUTO: libc::c_int = 0;
pub const FF_DCT_FASTINT: libc::c_int = 1;
pub const FF_DCT_INT: libc::c_int = 2;
pub const FF_DCT_MMX: libc::c_int = 3;
pub const FF_DCT_ALTIVEC: libc::c_int = 5;
pub const FF_DCT_FAAN: libc::c_int = 6;
pub const FF_IDCT_AUTO: libc::c_int = 0;
pub const FF_IDCT_INT: libc::c_int = 1;
pub const FF_IDCT_SIMPLE: libc::c_int = 2;
pub const FF_IDCT_SIMPLEMMX: libc::c_int = 3;
pub const FF_IDCT_ARM: libc::c_int = 7;
pub const FF_IDCT_ALTIVEC: libc::c_int = 8;
pub const FF_IDCT_SIMPLEARM: libc::c_int = 10;
pub const FF_IDCT_XVID: libc::c_int = 14;
pub const FF_IDCT_SIMPLEARMV5TE: libc::c_int = 16;
pub const FF_IDCT_SIMPLEARMV6: libc::c_int = 17;
pub const FF_IDCT_FAAN: libc::c_int = 20;
pub const FF_IDCT_SIMPLENEON: libc::c_int = 22;
pub const FF_IDCT_NONE: libc::c_int = 24;
pub const FF_IDCT_SIMPLEAUTO: libc::c_int = 128;
pub const FF_THREAD_FRAME: libc::c_int = 1;
pub const FF_THREAD_SLICE: libc::c_int = 2;
pub const FF_PROFILE_UNKNOWN: libc::c_int = -99;
pub const FF_PROFILE_RESERVED: libc::c_int = -100;
pub const FF_PROFILE_AAC_MAIN: libc::c_int = 0;
pub const FF_PROFILE_AAC_LOW: libc::c_int = 1;
pub const FF_PROFILE_AAC_SSR: libc::c_int = 2;
pub const FF_PROFILE_AAC_LTP: libc::c_int = 3;
pub const FF_PROFILE_AAC_HE: libc::c_int = 4;
pub const FF_PROFILE_AAC_HE_V2: libc::c_int = 28;
pub const FF_PROFILE_AAC_LD: libc::c_int = 22;
pub const FF_PROFILE_AAC_ELD: libc::c_int = 38;
pub const FF_PROFILE_MPEG2_AAC_LOW: libc::c_int = 128;
pub const FF_PROFILE_MPEG2_AAC_HE: libc::c_int = 131;
pub const FF_PROFILE_DNXHD: libc::c_int = 0;
pub const FF_PROFILE_DNXHR_LB: libc::c_int = 1;
pub const FF_PROFILE_DNXHR_SQ: libc::c_int = 2;
pub const FF_PROFILE_DNXHR_HQ: libc::c_int = 3;
pub const FF_PROFILE_DNXHR_HQX: libc::c_int = 4;
pub const FF_PROFILE_DNXHR_444: libc::c_int = 5;
pub const FF_PROFILE_DTS: libc::c_int = 20;
pub const FF_PROFILE_DTS_ES: libc::c_int = 30;
pub const FF_PROFILE_DTS_96_24: libc::c_int = 40;
pub const FF_PROFILE_DTS_HD_HRA: libc::c_int = 50;
pub const FF_PROFILE_DTS_HD_MA: libc::c_int = 60;
pub const FF_PROFILE_DTS_EXPRESS: libc::c_int = 70;
pub const FF_PROFILE_MPEG2_422: libc::c_int = 0;
pub const FF_PROFILE_MPEG2_HIGH: libc::c_int = 1;
pub const FF_PROFILE_MPEG2_SS: libc::c_int = 2;
pub const FF_PROFILE_MPEG2_SNR_SCALABLE: libc::c_int = 3;
pub const FF_PROFILE_MPEG2_MAIN: libc::c_int = 4;
pub const FF_PROFILE_MPEG2_SIMPLE: libc::c_int = 5;
pub const FF_PROFILE_H264_CONSTRAINED: libc::c_int = 512;
pub const FF_PROFILE_H264_INTRA: libc::c_int = 2048;
pub const FF_PROFILE_H264_BASELINE: libc::c_int = 66;
pub const FF_PROFILE_H264_CONSTRAINED_BASELINE: libc::c_int = 578;
pub const FF_PROFILE_H264_MAIN: libc::c_int = 77;
pub const FF_PROFILE_H264_EXTENDED: libc::c_int = 88;
pub const FF_PROFILE_H264_HIGH: libc::c_int = 100;
pub const FF_PROFILE_H264_HIGH_10: libc::c_int = 110;
pub const FF_PROFILE_H264_HIGH_10_INTRA: libc::c_int = 2158;
pub const FF_PROFILE_H264_MULTIVIEW_HIGH: libc::c_int = 118;
pub const FF_PROFILE_H264_HIGH_422: libc::c_int = 122;
pub const FF_PROFILE_H264_HIGH_422_INTRA: libc::c_int = 2170;
pub const FF_PROFILE_H264_STEREO_HIGH: libc::c_int = 128;
pub const FF_PROFILE_H264_HIGH_444: libc::c_int = 144;
pub const FF_PROFILE_H264_HIGH_444_PREDICTIVE: libc::c_int = 244;
pub const FF_PROFILE_H264_HIGH_444_INTRA: libc::c_int = 2292;
pub const FF_PROFILE_H264_CAVLC_444: libc::c_int = 44;
pub const FF_PROFILE_VC1_SIMPLE: libc::c_int = 0;
pub const FF_PROFILE_VC1_MAIN: libc::c_int = 1;
pub const FF_PROFILE_VC1_COMPLEX: libc::c_int = 2;
pub const FF_PROFILE_VC1_ADVANCED: libc::c_int = 3;
pub const FF_PROFILE_MPEG4_SIMPLE: libc::c_int = 0;
pub const FF_PROFILE_MPEG4_SIMPLE_SCALABLE: libc::c_int = 1;
pub const FF_PROFILE_MPEG4_CORE: libc::c_int = 2;
pub const FF_PROFILE_MPEG4_MAIN: libc::c_int = 3;
pub const FF_PROFILE_MPEG4_N_BIT: libc::c_int = 4;
pub const FF_PROFILE_MPEG4_SCALABLE_TEXTURE: libc::c_int = 5;
pub const FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION: libc::c_int = 6;
pub const FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE: libc::c_int = 7;
pub const FF_PROFILE_MPEG4_HYBRID: libc::c_int = 8;
pub const FF_PROFILE_MPEG4_ADVANCED_REAL_TIME: libc::c_int = 9;
pub const FF_PROFILE_MPEG4_CORE_SCALABLE: libc::c_int = 10;
pub const FF_PROFILE_MPEG4_ADVANCED_CODING: libc::c_int = 11;
pub const FF_PROFILE_MPEG4_ADVANCED_CORE: libc::c_int = 12;
pub const FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE: libc::c_int = 13;
pub const FF_PROFILE_MPEG4_SIMPLE_STUDIO: libc::c_int = 14;
pub const FF_PROFILE_MPEG4_ADVANCED_SIMPLE: libc::c_int = 15;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0: libc::c_int = 1;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1: libc::c_int = 2;
pub const FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION: libc::c_int = 32768;
pub const FF_PROFILE_JPEG2000_DCINEMA_2K: libc::c_int = 3;
pub const FF_PROFILE_JPEG2000_DCINEMA_4K: libc::c_int = 4;
pub const FF_PROFILE_VP9_0: libc::c_int = 0;
pub const FF_PROFILE_VP9_1: libc::c_int = 1;
pub const FF_PROFILE_VP9_2: libc::c_int = 2;
pub const FF_PROFILE_VP9_3: libc::c_int = 3;
pub const FF_PROFILE_HEVC_MAIN: libc::c_int = 1;
pub const FF_PROFILE_HEVC_MAIN_10: libc::c_int = 2;
pub const FF_PROFILE_HEVC_MAIN_STILL_PICTURE: libc::c_int = 3;
pub const FF_PROFILE_HEVC_REXT: libc::c_int = 4;
pub const FF_PROFILE_VVC_MAIN_10: libc::c_int = 1;
pub const FF_PROFILE_VVC_MAIN_10_444: libc::c_int = 33;
pub const FF_PROFILE_AV1_MAIN: libc::c_int = 0;
pub const FF_PROFILE_AV1_HIGH: libc::c_int = 1;
pub const FF_PROFILE_AV1_PROFESSIONAL: libc::c_int = 2;
pub const FF_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT: libc::c_int = 192;
pub const FF_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT: libc::c_int = 193;
pub const FF_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT: libc::c_int = 194;
pub const FF_PROFILE_MJPEG_HUFFMAN_LOSSLESS: libc::c_int = 195;
pub const FF_PROFILE_MJPEG_JPEG_LS: libc::c_int = 247;
pub const FF_PROFILE_SBC_MSBC: libc::c_int = 1;
pub const FF_PROFILE_PRORES_PROXY: libc::c_int = 0;
pub const FF_PROFILE_PRORES_LT: libc::c_int = 1;
pub const FF_PROFILE_PRORES_STANDARD: libc::c_int = 2;
pub const FF_PROFILE_PRORES_HQ: libc::c_int = 3;
pub const FF_PROFILE_PRORES_4444: libc::c_int = 4;
pub const FF_PROFILE_PRORES_XQ: libc::c_int = 5;
pub const FF_PROFILE_ARIB_PROFILE_A: libc::c_int = 0;
pub const FF_PROFILE_ARIB_PROFILE_C: libc::c_int = 1;
pub const FF_PROFILE_KLVA_SYNC: libc::c_int = 0;
pub const FF_PROFILE_KLVA_ASYNC: libc::c_int = 1;
pub const FF_LEVEL_UNKNOWN: libc::c_int = -99;
pub const FF_SUB_CHARENC_MODE_DO_NOTHING: libc::c_int = -1;
pub const FF_SUB_CHARENC_MODE_AUTOMATIC: libc::c_int = 0;
pub const FF_SUB_CHARENC_MODE_PRE_DECODER: libc::c_int = 1;
pub const FF_SUB_CHARENC_MODE_IGNORE: libc::c_int = 2;
pub const FF_DEBUG_VIS_MV_P_FOR: libc::c_int = 1;
pub const FF_DEBUG_VIS_MV_B_FOR: libc::c_int = 2;
pub const FF_DEBUG_VIS_MV_B_BACK: libc::c_int = 4;
pub const FF_CODEC_PROPERTY_LOSSLESS: libc::c_int = 1;
pub const FF_CODEC_PROPERTY_CLOSED_CAPTIONS: libc::c_int = 2;
pub const FF_SUB_TEXT_FMT_ASS: libc::c_int = 0;
pub const FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS: libc::c_int = 1;
pub const AV_HWACCEL_CODEC_CAP_EXPERIMENTAL: libc::c_int = 512;
pub const AV_HWACCEL_FLAG_IGNORE_LEVEL: libc::c_int = 1;
pub const AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH: libc::c_int = 2;
pub const AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH: libc::c_int = 4;
pub const AV_SUBTITLE_FLAG_FORCED: libc::c_int = 1;
pub const AV_PARSER_PTS_NB: libc::c_int = 4;
pub const PARSER_FLAG_COMPLETE_FRAMES: libc::c_int = 1;
pub const PARSER_FLAG_ONCE: libc::c_int = 2;
pub const PARSER_FLAG_FETCHED_OFFSET: libc::c_int = 4;
pub const PARSER_FLAG_USE_CODEC_TS: libc::c_int = 4096;
pub const DV_PROFILE_BYTES: libc::c_int = 480;
pub const VORBIS_FLAG_HEADER: libc::c_int = 1;
pub const VORBIS_FLAG_COMMENT: libc::c_int = 2;
pub const VORBIS_FLAG_SETUP: libc::c_int = 4;
pub const _TIME_H: libc::c_int = 1;
pub const _BITS_TIME_H: libc::c_int = 1;
pub const CLOCK_REALTIME: libc::c_int = 0;
pub const CLOCK_MONOTONIC: libc::c_int = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: libc::c_int = 2;
pub const CLOCK_THREAD_CPUTIME_ID: libc::c_int = 3;
pub const CLOCK_MONOTONIC_RAW: libc::c_int = 4;
pub const CLOCK_REALTIME_COARSE: libc::c_int = 5;
pub const CLOCK_MONOTONIC_COARSE: libc::c_int = 6;
pub const CLOCK_BOOTTIME: libc::c_int = 7;
pub const CLOCK_REALTIME_ALARM: libc::c_int = 8;
pub const CLOCK_BOOTTIME_ALARM: libc::c_int = 9;
pub const CLOCK_TAI: libc::c_int = 11;
pub const TIMER_ABSTIME: libc::c_int = 1;
pub const __struct_tm_defined: libc::c_int = 1;
pub const __itimerspec_defined: libc::c_int = 1;
pub const TIME_UTC: libc::c_int = 1;
pub const LIBAVFORMAT_VERSION_MAJOR: libc::c_int = 58;
pub const LIBAVFORMAT_VERSION_MINOR: libc::c_int = 76;
pub const LIBAVFORMAT_VERSION_MICRO: libc::c_int = 100;
pub const FF_API_R_FRAME_RATE: libc::c_int = 1;
pub const AVIO_SEEKABLE_NORMAL: libc::c_int = 1;
pub const AVIO_SEEKABLE_TIME: libc::c_int = 2;
pub const AVSEEK_SIZE: libc::c_int = 65536;
pub const AVSEEK_FORCE: libc::c_int = 131072;
pub const AVIO_FLAG_READ: libc::c_int = 1;
pub const AVIO_FLAG_WRITE: libc::c_int = 2;
pub const AVIO_FLAG_READ_WRITE: libc::c_int = 3;
pub const AVIO_FLAG_NONBLOCK: libc::c_int = 8;
pub const AVIO_FLAG_DIRECT: libc::c_int = 32768;
pub const AVPROBE_SCORE_EXTENSION: libc::c_int = 50;
pub const AVPROBE_SCORE_MIME: libc::c_int = 75;
pub const AVPROBE_SCORE_MAX: libc::c_int = 100;
pub const AVPROBE_PADDING_SIZE: libc::c_int = 32;
pub const AVFMT_NOFILE: libc::c_int = 1;
pub const AVFMT_NEEDNUMBER: libc::c_int = 2;
pub const AVFMT_SHOW_IDS: libc::c_int = 8;
pub const AVFMT_GLOBALHEADER: libc::c_int = 64;
pub const AVFMT_NOTIMESTAMPS: libc::c_int = 128;
pub const AVFMT_GENERIC_INDEX: libc::c_int = 256;
pub const AVFMT_TS_DISCONT: libc::c_int = 512;
pub const AVFMT_VARIABLE_FPS: libc::c_int = 1024;
pub const AVFMT_NODIMENSIONS: libc::c_int = 2048;
pub const AVFMT_NOSTREAMS: libc::c_int = 4096;
pub const AVFMT_NOBINSEARCH: libc::c_int = 8192;
pub const AVFMT_NOGENSEARCH: libc::c_int = 16384;
pub const AVFMT_NO_BYTE_SEEK: libc::c_int = 32768;
pub const AVFMT_ALLOW_FLUSH: libc::c_int = 65536;
pub const AVFMT_TS_NONSTRICT: libc::c_int = 131072;
pub const AVFMT_TS_NEGATIVE: libc::c_int = 262144;
pub const AVFMT_SEEK_TO_PTS: libc::c_int = 67108864;
pub const AVINDEX_KEYFRAME: libc::c_int = 1;
pub const AVINDEX_DISCARD_FRAME: libc::c_int = 2;
pub const AV_DISPOSITION_DEFAULT: libc::c_int = 1;
pub const AV_DISPOSITION_DUB: libc::c_int = 2;
pub const AV_DISPOSITION_ORIGINAL: libc::c_int = 4;
pub const AV_DISPOSITION_COMMENT: libc::c_int = 8;
pub const AV_DISPOSITION_LYRICS: libc::c_int = 16;
pub const AV_DISPOSITION_KARAOKE: libc::c_int = 32;
pub const AV_DISPOSITION_FORCED: libc::c_int = 64;
pub const AV_DISPOSITION_HEARING_IMPAIRED: libc::c_int = 128;
pub const AV_DISPOSITION_VISUAL_IMPAIRED: libc::c_int = 256;
pub const AV_DISPOSITION_CLEAN_EFFECTS: libc::c_int = 512;
pub const AV_DISPOSITION_ATTACHED_PIC: libc::c_int = 1024;
pub const AV_DISPOSITION_TIMED_THUMBNAILS: libc::c_int = 2048;
pub const AV_DISPOSITION_CAPTIONS: libc::c_int = 65536;
pub const AV_DISPOSITION_DESCRIPTIONS: libc::c_int = 131072;
pub const AV_DISPOSITION_METADATA: libc::c_int = 262144;
pub const AV_DISPOSITION_DEPENDENT: libc::c_int = 524288;
pub const AV_DISPOSITION_STILL_IMAGE: libc::c_int = 1048576;
pub const AV_PTS_WRAP_IGNORE: libc::c_int = 0;
pub const AV_PTS_WRAP_ADD_OFFSET: libc::c_int = 1;
pub const AV_PTS_WRAP_SUB_OFFSET: libc::c_int = -1;
pub const AVSTREAM_EVENT_FLAG_METADATA_UPDATED: libc::c_int = 1;
pub const AVSTREAM_EVENT_FLAG_NEW_PACKETS: libc::c_int = 2;
pub const AV_PROGRAM_RUNNING: libc::c_int = 1;
pub const AVFMTCTX_NOHEADER: libc::c_int = 1;
pub const AVFMTCTX_UNSEEKABLE: libc::c_int = 2;
pub const AVFMT_FLAG_GENPTS: libc::c_int = 1;
pub const AVFMT_FLAG_IGNIDX: libc::c_int = 2;
pub const AVFMT_FLAG_NONBLOCK: libc::c_int = 4;
pub const AVFMT_FLAG_IGNDTS: libc::c_int = 8;
pub const AVFMT_FLAG_NOFILLIN: libc::c_int = 16;
pub const AVFMT_FLAG_NOPARSE: libc::c_int = 32;
pub const AVFMT_FLAG_NOBUFFER: libc::c_int = 64;
pub const AVFMT_FLAG_CUSTOM_IO: libc::c_int = 128;
pub const AVFMT_FLAG_DISCARD_CORRUPT: libc::c_int = 256;
pub const AVFMT_FLAG_FLUSH_PACKETS: libc::c_int = 512;
pub const AVFMT_FLAG_BITEXACT: libc::c_int = 1024;
pub const AVFMT_FLAG_MP4A_LATM: libc::c_int = 32768;
pub const AVFMT_FLAG_SORT_DTS: libc::c_int = 65536;
pub const AVFMT_FLAG_PRIV_OPT: libc::c_int = 131072;
pub const AVFMT_FLAG_KEEP_SIDE_DATA: libc::c_int = 262144;
pub const AVFMT_FLAG_FAST_SEEK: libc::c_int = 524288;
pub const AVFMT_FLAG_SHORTEST: libc::c_int = 1048576;
pub const AVFMT_FLAG_AUTO_BSF: libc::c_int = 2097152;
pub const FF_FDEBUG_TS: libc::c_int = 1;
pub const AVFMT_EVENT_FLAG_METADATA_UPDATED: libc::c_int = 1;
pub const AVFMT_AVOID_NEG_TS_AUTO: libc::c_int = -1;
pub const AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE: libc::c_int = 1;
pub const AVFMT_AVOID_NEG_TS_MAKE_ZERO: libc::c_int = 2;
pub const AVSEEK_FLAG_BACKWARD: libc::c_int = 1;
pub const AVSEEK_FLAG_BYTE: libc::c_int = 2;
pub const AVSEEK_FLAG_ANY: libc::c_int = 4;
pub const AVSEEK_FLAG_FRAME: libc::c_int = 8;
pub const AVSTREAM_INIT_IN_WRITE_HEADER: libc::c_int = 0;
pub const AVSTREAM_INIT_IN_INIT_OUTPUT: libc::c_int = 1;
pub const AV_FRAME_FILENAME_FLAGS_MULTIPLE: libc::c_int = 1;
pub const AV_BF_ROUNDS: libc::c_int = 16;
pub const AV_ESCAPE_FLAG_WHITESPACE: libc::c_int = 1;
pub const AV_ESCAPE_FLAG_STRICT: libc::c_int = 2;
pub const AV_ESCAPE_FLAG_XML_SINGLE_QUOTES: libc::c_int = 4;
pub const AV_ESCAPE_FLAG_XML_DOUBLE_QUOTES: libc::c_int = 8;
pub const AV_UTF8_FLAG_ACCEPT_INVALID_BIG_CODES: libc::c_int = 1;
pub const AV_UTF8_FLAG_ACCEPT_NON_CHARACTERS: libc::c_int = 2;
pub const AV_UTF8_FLAG_ACCEPT_SURROGATES: libc::c_int = 4;
pub const AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES: libc::c_int = 8;
pub const AV_UTF8_FLAG_ACCEPT_ALL: libc::c_int = 7;
pub const AV_BPRINT_SIZE_AUTOMATIC: libc::c_int = 1;
pub const AV_BPRINT_SIZE_COUNT_ONLY: libc::c_int = 0;
pub const AV_HASH_MAX_SIZE: libc::c_int = 64;
pub const AV_PIX_FMT_FLAG_BE: libc::c_int = 1;
pub const AV_PIX_FMT_FLAG_PAL: libc::c_int = 2;
pub const AV_PIX_FMT_FLAG_BITSTREAM: libc::c_int = 4;
pub const AV_PIX_FMT_FLAG_HWACCEL: libc::c_int = 8;
pub const AV_PIX_FMT_FLAG_PLANAR: libc::c_int = 16;
pub const AV_PIX_FMT_FLAG_RGB: libc::c_int = 32;
pub const AV_PIX_FMT_FLAG_PSEUDOPAL: libc::c_int = 64;
pub const AV_PIX_FMT_FLAG_ALPHA: libc::c_int = 128;
pub const AV_PIX_FMT_FLAG_BAYER: libc::c_int = 256;
pub const AV_PIX_FMT_FLAG_FLOAT: libc::c_int = 512;
pub const FF_LOSS_RESOLUTION: libc::c_int = 1;
pub const FF_LOSS_DEPTH: libc::c_int = 2;
pub const FF_LOSS_COLORSPACE: libc::c_int = 4;
pub const FF_LOSS_ALPHA: libc::c_int = 8;
pub const FF_LOSS_COLORQUANT: libc::c_int = 16;
pub const FF_LOSS_CHROMA: libc::c_int = 32;
pub const AV_LZO_INPUT_DEPLETED: libc::c_int = 1;
pub const AV_LZO_OUTPUT_FULL: libc::c_int = 2;
pub const AV_LZO_INVALID_BACKPTR: libc::c_int = 4;
pub const AV_LZO_ERROR: libc::c_int = 8;
pub const AV_LZO_INPUT_PADDING: libc::c_int = 8;
pub const AV_LZO_OUTPUT_PADDING: libc::c_int = 12;
pub const AV_OPT_FLAG_ENCODING_PARAM: libc::c_int = 1;
pub const AV_OPT_FLAG_DECODING_PARAM: libc::c_int = 2;
pub const AV_OPT_FLAG_AUDIO_PARAM: libc::c_int = 8;
pub const AV_OPT_FLAG_VIDEO_PARAM: libc::c_int = 16;
pub const AV_OPT_FLAG_SUBTITLE_PARAM: libc::c_int = 32;
pub const AV_OPT_FLAG_EXPORT: libc::c_int = 64;
pub const AV_OPT_FLAG_READONLY: libc::c_int = 128;
pub const AV_OPT_FLAG_BSF_PARAM: libc::c_int = 256;
pub const AV_OPT_FLAG_RUNTIME_PARAM: libc::c_int = 32768;
pub const AV_OPT_FLAG_FILTERING_PARAM: libc::c_int = 65536;
pub const AV_OPT_FLAG_DEPRECATED: libc::c_int = 131072;
pub const AV_OPT_FLAG_CHILD_CONSTS: libc::c_int = 262144;
pub const AV_OPT_SEARCH_CHILDREN: libc::c_int = 1;
pub const AV_OPT_SEARCH_FAKE_OBJ: libc::c_int = 2;
pub const AV_OPT_ALLOW_NULL: libc::c_int = 4;
pub const AV_OPT_MULTI_COMPONENT_RANGE: libc::c_int = 4096;
pub const AV_OPT_SERIALIZE_SKIP_DEFAULTS: libc::c_int = 1;
pub const AV_OPT_SERIALIZE_OPT_FLAGS_EXACT: libc::c_int = 2;
pub const AV_STEREO3D_FLAG_INVERT: libc::c_int = 1;
pub const AV_TIMECODE_STR_SIZE: libc::c_int = 23;
pub const LIBSWSCALE_VERSION_MAJOR: libc::c_int = 5;
pub const LIBSWSCALE_VERSION_MINOR: libc::c_int = 9;
pub const LIBSWSCALE_VERSION_MICRO: libc::c_int = 100;
pub const SWS_FAST_BILINEAR: libc::c_int = 1;
pub const SWS_BILINEAR: libc::c_int = 2;
pub const SWS_BICUBIC: libc::c_int = 4;
pub const SWS_X: libc::c_int = 8;
pub const SWS_POINT: libc::c_int = 16;
pub const SWS_AREA: libc::c_int = 32;
pub const SWS_BICUBLIN: libc::c_int = 64;
pub const SWS_GAUSS: libc::c_int = 128;
pub const SWS_SINC: libc::c_int = 256;
pub const SWS_LANCZOS: libc::c_int = 512;
pub const SWS_SPLINE: libc::c_int = 1024;
pub const SWS_SRC_V_CHR_DROP_MASK: libc::c_int = 196608;
pub const SWS_SRC_V_CHR_DROP_SHIFT: libc::c_int = 16;
pub const SWS_PARAM_DEFAULT: libc::c_int = 123456;
pub const SWS_PRINT_INFO: libc::c_int = 4096;
pub const SWS_FULL_CHR_H_INT: libc::c_int = 8192;
pub const SWS_FULL_CHR_H_INP: libc::c_int = 16384;
pub const SWS_DIRECT_BGR: libc::c_int = 32768;
pub const SWS_ACCURATE_RND: libc::c_int = 262144;
pub const SWS_BITEXACT: libc::c_int = 524288;
pub const SWS_ERROR_DIFFUSION: libc::c_int = 8388608;
pub const SWS_MAX_REDUCE_CUTOFF: f64 = 0.002;
pub const SWS_CS_ITU709: libc::c_int = 1;
pub const SWS_CS_FCC: libc::c_int = 4;
pub const SWS_CS_ITU601: libc::c_int = 5;
pub const SWS_CS_ITU624: libc::c_int = 5;
pub const SWS_CS_SMPTE170M: libc::c_int = 5;
pub const SWS_CS_SMPTE240M: libc::c_int = 7;
pub const SWS_CS_DEFAULT: libc::c_int = 5;
pub const SWS_CS_BT2020: libc::c_int = 9;
pub type __u_char = libc::c_uchar;
pub type __u_short = libc::c_ushort;
pub type __u_int = libc::c_uint;
pub type __u_long = libc::c_ulong;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = libc::c_long;
pub type __u_quad_t = libc::c_ulong;
pub type __intmax_t = libc::c_long;
pub type __uintmax_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __fsid_t {
    pub __val: [libc::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = libc::c_long;
pub type __rlim_t = libc::c_ulong;
pub type __rlim64_t = libc::c_ulong;
pub type __id_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __useconds_t = libc::c_uint;
pub type __suseconds_t = libc::c_long;
pub type __suseconds64_t = libc::c_long;
pub type __daddr_t = libc::c_int;
pub type __key_t = libc::c_int;
pub type __clockid_t = libc::c_int;
pub type __timer_t = *mut libc::c_void;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __blkcnt64_t = libc::c_long;
pub type __fsblkcnt_t = libc::c_ulong;
pub type __fsblkcnt64_t = libc::c_ulong;
pub type __fsfilcnt_t = libc::c_ulong;
pub type __fsfilcnt64_t = libc::c_ulong;
pub type __fsword_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __syscall_ulong_t = libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut libc::c_char;
pub type __intptr_t = libc::c_long;
pub type __socklen_t = libc::c_uint;
pub type __sig_atomic_t = libc::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = libc::c_schar;
pub type int_fast16_t = libc::c_long;
pub type int_fast32_t = libc::c_long;
pub type int_fast64_t = libc::c_long;
pub type uint_fast8_t = libc::c_uchar;
pub type uint_fast16_t = libc::c_ulong;
pub type uint_fast32_t = libc::c_ulong;
pub type uint_fast64_t = libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    #[doc = " Return the LIBAVUTIL_VERSION_INT constant."]
    pub fn avutil_version() -> libc::c_uint;
}
extern "C" {
    #[doc = " Return an informative version string. This usually is the actual release\n version number or a git commit description. This string has no fixed format\n and can change any time. It should never be parsed by code."]
    pub fn av_version_info() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return the libavutil build-time configuration."]
    pub fn avutil_configuration() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return the libavutil license."]
    pub fn avutil_license() -> *const libc::c_char;
}
#[repr(i32)]
#[doc = " @addtogroup lavu_media Media Type\n @brief Media Type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVMediaType {
    #[doc = "< Usually treated as AVMEDIA_TYPE_DATA"]
    AVMEDIA_TYPE_UNKNOWN = -1,
    AVMEDIA_TYPE_VIDEO = 0,
    AVMEDIA_TYPE_AUDIO = 1,
    #[doc = "< Opaque data information usually continuous"]
    AVMEDIA_TYPE_DATA = 2,
    AVMEDIA_TYPE_SUBTITLE = 3,
    #[doc = "< Opaque data information usually sparse"]
    AVMEDIA_TYPE_ATTACHMENT = 4,
    AVMEDIA_TYPE_NB = 5,
}
extern "C" {
    #[doc = " Return a string describing the media_type enum, NULL if media_type\n is unknown."]
    pub fn av_get_media_type_string(media_type: AVMediaType) -> *const libc::c_char;
}
#[repr(u32)]
#[doc = " @}\n @}\n @defgroup lavu_picture Image related\n\n AVPicture types, pixel formats and basic image planes manipulation.\n\n @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVPictureType {
    #[doc = "< Undefined"]
    AV_PICTURE_TYPE_NONE = 0,
    #[doc = "< Intra"]
    AV_PICTURE_TYPE_I = 1,
    #[doc = "< Predicted"]
    AV_PICTURE_TYPE_P = 2,
    #[doc = "< Bi-dir predicted"]
    AV_PICTURE_TYPE_B = 3,
    #[doc = "< S(GMC)-VOP MPEG-4"]
    AV_PICTURE_TYPE_S = 4,
    #[doc = "< Switching Intra"]
    AV_PICTURE_TYPE_SI = 5,
    #[doc = "< Switching Predicted"]
    AV_PICTURE_TYPE_SP = 6,
    #[doc = "< BI type"]
    AV_PICTURE_TYPE_BI = 7,
}
extern "C" {
    #[doc = " Return a single letter to describe the given picture type\n pict_type.\n\n @param[in] pict_type the picture type @return a single character\n representing the picture type, '?' if pict_type is unknown"]
    pub fn av_get_picture_type_char(pict_type: AVPictureType) -> libc::c_char;
}
pub type __gwchar_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct imaxdiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::std::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::std::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::std::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::std::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: libc::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: libc::c_int,
    ) -> uintmax_t;
}
pub type __cfloat128 = __BindgenComplex<u128>;
pub type _Float128 = u128;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: libc::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const libc::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: libc::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> libc::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: libc::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub static mut signgam: libc::c_int;
}
pub const FP_NAN: _bindgen_ty_1 = _bindgen_ty_1::FP_NAN;
pub const FP_INFINITE: _bindgen_ty_1 = _bindgen_ty_1::FP_INFINITE;
pub const FP_ZERO: _bindgen_ty_1 = _bindgen_ty_1::FP_ZERO;
pub const FP_SUBNORMAL: _bindgen_ty_1 = _bindgen_ty_1::FP_SUBNORMAL;
pub const FP_NORMAL: _bindgen_ty_1 = _bindgen_ty_1::FP_NORMAL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4,
}
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: libc::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: libc::c_uint,
    pub __wchb: [libc::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::std::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::std::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos_t"][::std::mem::size_of::<_G_fpos_t>() - 16usize];
    ["Alignment of _G_fpos_t"][::std::mem::align_of::<_G_fpos_t>() - 8usize];
    ["Offset of field: _G_fpos_t::__pos"][::std::mem::offset_of!(_G_fpos_t, __pos) - 0usize];
    ["Offset of field: _G_fpos_t::__state"][::std::mem::offset_of!(_G_fpos_t, __state) - 8usize];
};
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos64_t"][::std::mem::size_of::<_G_fpos64_t>() - 16usize];
    ["Alignment of _G_fpos64_t"][::std::mem::align_of::<_G_fpos64_t>() - 8usize];
    ["Offset of field: _G_fpos64_t::__pos"][::std::mem::offset_of!(_G_fpos64_t, __pos) - 0usize];
    ["Offset of field: _G_fpos64_t::__state"]
        [::std::mem::offset_of!(_G_fpos64_t, __state) - 8usize];
};
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub _short_backupbuf: [libc::c_char; 1usize],
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: libc::c_int,
    pub _unused3: libc::c_int,
    pub _total_written: __uint64_t,
    pub _unused2: [libc::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_short_backupbuf"]
        [::std::mem::offset_of!(_IO_FILE, _short_backupbuf) - 119usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    ["Offset of field: _IO_FILE::_prevchain"]
        [::std::mem::offset_of!(_IO_FILE, _prevchain) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused3"][::std::mem::offset_of!(_IO_FILE, _unused3) - 196usize];
    ["Offset of field: _IO_FILE::_total_written"]
        [::std::mem::offset_of!(_IO_FILE, _total_written) - 200usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 208usize];
};
impl _IO_FILE {
    #[inline]
    pub fn _flags2(&self) -> libc::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set__flags2(&mut self, val: libc::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(_flags2: libc::c_int) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let _flags2: u32 = unsafe { ::std::mem::transmute(_flags2) };
            _flags2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut libc::c_void,
        __buf: *mut libc::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut libc::c_void,
        __buf: *const libc::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut libc::c_void,
        __pos: *mut __off64_t,
        __w: libc::c_int,
    ) -> libc::c_int,
>;
pub type cookie_close_function_t =
    ::std::option::Option<unsafe extern "C" fn(__cookie: *mut libc::c_void) -> libc::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_cookie_io_functions_t"]
        [::std::mem::size_of::<_IO_cookie_io_functions_t>() - 32usize];
    ["Alignment of _IO_cookie_io_functions_t"]
        [::std::mem::align_of::<_IO_cookie_io_functions_t>() - 8usize];
    ["Offset of field: _IO_cookie_io_functions_t::read"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, read) - 0usize];
    ["Offset of field: _IO_cookie_io_functions_t::write"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, write) - 8usize];
    ["Offset of field: _IO_cookie_io_functions_t::seek"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, seek) - 16usize];
    ["Offset of field: _IO_cookie_io_functions_t::close"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, close) - 24usize];
};
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn rename(__old: *const libc::c_char, __new: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: libc::c_int,
        __old: *const libc::c_char,
        __newfd: libc::c_int,
        __new: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const libc::c_char, __pfx: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const libc::c_char,
        __modes: *const libc::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: libc::c_int, __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut libc::c_void,
        __modes: *const libc::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut libc::c_void,
        __len: usize,
        __modes: *const libc::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut libc::c_char, __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut libc::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut libc::c_char,
        __modes: libc::c_int,
        __n: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut libc::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn printf(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut libc::c_char, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const libc::c_char, __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut libc::c_char,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut libc::c_char,
        __maxlen: libc::c_ulong,
        __format: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut libc::c_char,
        __maxlen: libc::c_ulong,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut libc::c_char,
        __f: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn asprintf(__ptr: *mut *mut libc::c_char, __fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: libc::c_int,
        __fmt: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn dprintf(__fd: libc::c_int, __fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn scanf(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const libc::c_char, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(__s: *const libc::c_char, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const libc::c_char, __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const libc::c_char,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(__format: *const libc::c_char, __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const libc::c_char,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar() -> libc::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> libc::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fputc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putw(__w: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut libc::c_char,
        __n: libc::c_int,
        __stream: *mut FILE,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut libc::c_char,
        __n: *mut usize,
        __delimiter: libc::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut libc::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn puts(__s: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn ungetc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut libc::c_void,
        __size: libc::c_ulong,
        __n: libc::c_ulong,
        __stream: *mut FILE,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const libc::c_void,
        __size: libc::c_ulong,
        __n: libc::c_ulong,
        __s: *mut FILE,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut libc::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const libc::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: libc::c_long, __whence: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> libc::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn perror(__s: *const libc::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn popen(__command: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type wchar_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct div_t {
    pub quot: libc::c_int,
    pub rem: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ldiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct lldiv_t {
    pub quot: libc::c_longlong,
    pub rem: libc::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
extern "C" {
    pub fn atof(__nptr: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const libc::c_char) -> libc::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const libc::c_char) -> libc::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const libc::c_char, __endptr: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const libc::c_char, __endptr: *mut *mut libc::c_char) -> f32;
}
extern "C" {
    pub fn strtol(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: libc::c_long) -> *mut libc::c_char;
}
extern "C" {
    pub fn a64l(__s: *const libc::c_char) -> libc::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = libc::c_ulong;
pub type ushort = libc::c_ushort;
pub type uint = libc::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = libc::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __sigset_t {
    pub __val: [libc::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = libc::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::__fds_bits"][::std::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> libc::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: libc::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>() - 8usize];
    ["Alignment of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>() - 4usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter"][::std::mem::size_of::<__atomic_wide_counter>() - 8usize];
    ["Alignment of __atomic_wide_counter"]
        [::std::mem::align_of::<__atomic_wide_counter>() - 8usize];
    ["Offset of field: __atomic_wide_counter::__value64"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value64) - 0usize];
    ["Offset of field: __atomic_wide_counter::__value32"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value32) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"]
        [::std::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::std::mem::size_of::<__pthread_internal_slist>() - 8usize];
    ["Alignment of __pthread_internal_slist"]
        [::std::mem::align_of::<__pthread_internal_slist>() - 8usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::std::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::std::mem::size_of::<__pthread_mutex_s>() - 40usize];
    ["Alignment of __pthread_mutex_s"][::std::mem::align_of::<__pthread_mutex_s>() - 8usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::std::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::std::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::std::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::std::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::std::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: __pthread_mutex_s::__spins"]
        [::std::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: __pthread_mutex_s::__elision"]
        [::std::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: __pthread_mutex_s::__list"]
        [::std::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: libc::c_uint,
    pub __writers: libc::c_uint,
    pub __wrphase_futex: libc::c_uint,
    pub __writers_futex: libc::c_uint,
    pub __pad3: libc::c_uint,
    pub __pad4: libc::c_uint,
    pub __cur_writer: libc::c_int,
    pub __shared: libc::c_int,
    pub __rwelision: libc::c_schar,
    pub __pad1: [libc::c_uchar; 7usize],
    pub __pad2: libc::c_ulong,
    pub __flags: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"][::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
    ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_size: [libc::c_uint; 2usize],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2usize],
    pub __unused_initialized_1: libc::c_uint,
    pub __unused_initialized_2: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::std::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::std::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__wseq"]
        [::std::mem::offset_of!(__pthread_cond_s, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s::__g1_start"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_start) - 8usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_size) - 16usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::std::mem::offset_of!(__pthread_cond_s, __wrefs) - 28usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_signals) - 32usize];
    ["Offset of field: __pthread_cond_s::__unused_initialized_1"]
        [::std::mem::offset_of!(__pthread_cond_s, __unused_initialized_1) - 40usize];
    ["Offset of field: __pthread_cond_s::__unused_initialized_2"]
        [::std::mem::offset_of!(__pthread_cond_s, __unused_initialized_2) - 44usize];
};
pub type __tss_t = libc::c_uint;
pub type __thrd_t = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __once_flag {
    pub __data: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __once_flag"][::std::mem::size_of::<__once_flag>() - 4usize];
    ["Alignment of __once_flag"][::std::mem::align_of::<__once_flag>() - 4usize];
    ["Offset of field: __once_flag::__data"][::std::mem::offset_of!(__once_flag, __data) - 0usize];
};
pub type pthread_t = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = libc::c_uint;
pub type pthread_once_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [libc::c_char; 56usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [libc::c_char; 48usize],
    pub __align: libc::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [libc::c_char; 56usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [libc::c_char; 8usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [libc::c_char; 32usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
extern "C" {
    pub fn random() -> libc::c_long;
}
extern "C" {
    pub fn srandom(__seed: libc::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: libc::c_uint,
        __statebuf: *mut libc::c_char,
        __statelen: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut libc::c_char) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: libc::c_int,
    pub rand_deg: libc::c_int,
    pub rand_sep: libc::c_int,
    pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of random_data"][::std::mem::size_of::<random_data>() - 48usize];
    ["Alignment of random_data"][::std::mem::align_of::<random_data>() - 8usize];
    ["Offset of field: random_data::fptr"][::std::mem::offset_of!(random_data, fptr) - 0usize];
    ["Offset of field: random_data::rptr"][::std::mem::offset_of!(random_data, rptr) - 8usize];
    ["Offset of field: random_data::state"][::std::mem::offset_of!(random_data, state) - 16usize];
    ["Offset of field: random_data::rand_type"]
        [::std::mem::offset_of!(random_data, rand_type) - 24usize];
    ["Offset of field: random_data::rand_deg"]
        [::std::mem::offset_of!(random_data, rand_deg) - 28usize];
    ["Offset of field: random_data::rand_sep"]
        [::std::mem::offset_of!(random_data, rand_sep) - 32usize];
    ["Offset of field: random_data::end_ptr"]
        [::std::mem::offset_of!(random_data, end_ptr) - 40usize];
};
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> libc::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: libc::c_uint, __buf: *mut random_data) -> libc::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: libc::c_uint,
        __statebuf: *mut libc::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> libc::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut libc::c_char, __buf: *mut random_data) -> libc::c_int;
}
extern "C" {
    pub fn rand() -> libc::c_int;
}
extern "C" {
    pub fn srand(__seed: libc::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut libc::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> libc::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
    pub fn mrand48() -> libc::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
    pub fn srand48(__seedval: libc::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut libc::c_ushort) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut libc::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct drand48_data {
    pub __x: [libc::c_ushort; 3usize],
    pub __old_x: [libc::c_ushort; 3usize],
    pub __c: libc::c_ushort,
    pub __init: libc::c_ushort,
    pub __a: libc::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of drand48_data"][::std::mem::size_of::<drand48_data>() - 24usize];
    ["Alignment of drand48_data"][::std::mem::align_of::<drand48_data>() - 8usize];
    ["Offset of field: drand48_data::__x"][::std::mem::offset_of!(drand48_data, __x) - 0usize];
    ["Offset of field: drand48_data::__old_x"]
        [::std::mem::offset_of!(drand48_data, __old_x) - 6usize];
    ["Offset of field: drand48_data::__c"][::std::mem::offset_of!(drand48_data, __c) - 12usize];
    ["Offset of field: drand48_data::__init"]
        [::std::mem::offset_of!(drand48_data, __init) - 14usize];
    ["Offset of field: drand48_data::__a"][::std::mem::offset_of!(drand48_data, __a) - 16usize];
};
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data, __result: *mut libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut libc::c_long,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data, __result: *mut libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut libc::c_long,
    ) -> libc::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: libc::c_long, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut libc::c_ushort, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut libc::c_ushort, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut libc::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: libc::c_ulong, __size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut libc::c_void, __size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut libc::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut libc::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn alloca(__size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut libc::c_void,
        __alignment: usize,
        __size: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: libc::c_ulong, __size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(__status: libc::c_int, __arg: *mut libc::c_void),
        >,
        __arg: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn exit(__status: libc::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: libc::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const libc::c_char,
        __value: *const libc::c_char,
        __replace: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn clearenv() -> libc::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut libc::c_char, __suffixlen: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn system(__command: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const libc::c_char,
        __resolved: *mut libc::c_char,
    ) -> *mut libc::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void) -> libc::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const libc::c_void,
        __base: *const libc::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut libc::c_void, __nmemb: usize, __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn labs(__x: libc::c_long) -> libc::c_long;
}
extern "C" {
    pub fn llabs(__x: libc::c_longlong) -> libc::c_longlong;
}
extern "C" {
    pub fn div(__numer: libc::c_int, __denom: libc::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: libc::c_long, __denom: libc::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: libc::c_longlong, __denom: libc::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: libc::c_int, __buf: *mut libc::c_char)
        -> *mut libc::c_char;
}
extern "C" {
    pub fn mblen(__s: *const libc::c_char, __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const libc::c_char, __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut libc::c_char, __wchar: wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const libc::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut libc::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut libc::c_char,
        __tokens: *const *mut libc::c_char,
        __valuep: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __c: libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut libc::c_void,
        __c: libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const libc::c_void,
        __s2: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const libc::c_void,
        __c: libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> libc::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const libc::c_ushort,
    pub __ctype_tolower: *const libc::c_int,
    pub __ctype_toupper: *const libc::c_int,
    pub __names: [*const libc::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::std::mem::size_of::<__locale_struct>() - 232usize];
    ["Alignment of __locale_struct"][::std::mem::align_of::<__locale_struct>() - 8usize];
    ["Offset of field: __locale_struct::__locales"]
        [::std::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::std::mem::offset_of!(__locale_struct, __ctype_b) - 104usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::std::mem::offset_of!(__locale_struct, __ctype_tolower) - 112usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::std::mem::offset_of!(__locale_struct, __ctype_toupper) - 120usize];
    ["Offset of field: __locale_struct::__names"]
        [::std::mem::offset_of!(__locale_struct, __names) - 128usize];
};
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __l: locale_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strndup(__string: *const libc::c_char, __n: libc::c_ulong) -> *mut libc::c_char;
}
extern "C" {
    pub fn strchr(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strchrnul(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const libc::c_char, __reject: *const libc::c_char) -> libc::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const libc::c_char, __accept: *const libc::c_char) -> libc::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const libc::c_char, __accept: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const libc::c_char,
        __needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut libc::c_char, __delim: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut libc::c_char,
        __delim: *const libc::c_char,
        __save_ptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *const libc::c_char,
        __needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn memmem(
        __haystack: *const libc::c_void,
        __haystacklen: usize,
        __needle: *const libc::c_void,
        __needlelen: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mempcpy(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn strlen(__s: *const libc::c_char) -> libc::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const libc::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: libc::c_int,
        __buf: *mut libc::c_char,
        __buflen: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: libc::c_int, __l: locale_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const libc::c_void,
        __s2: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const libc::c_void, __dest: *mut libc::c_void, __n: libc::c_ulong);
}
extern "C" {
    pub fn bzero(__s: *mut libc::c_void, __n: libc::c_ulong);
}
extern "C" {
    pub fn index(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn rindex(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn ffs(__i: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ffsl(__l: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn ffsll(__ll: libc::c_longlong) -> libc::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __loc: locale_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut libc::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut libc::c_char,
        __delim: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strsignal(__sig: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strlcpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn strlcat(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn av_log2(v: libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn av_log2_16bit(v: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " Put a description of the AVERROR code errnum in errbuf.\n In case of failure the global variable errno is set to indicate the\n error. Even in case of failure av_strerror() will print a generic\n error message indicating the errnum provided to errbuf.\n\n @param errnum      error code to describe\n @param errbuf      buffer to which description is written\n @param errbuf_size the size in bytes of errbuf\n @return 0 on success, a negative value if a description for errnum\n cannot be found"]
    pub fn av_strerror(
        errnum: libc::c_int,
        errbuf: *mut libc::c_char,
        errbuf_size: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate a memory block with alignment suitable for all memory accesses\n (including vectors if available on the CPU).\n\n @param size Size in bytes for the memory block to be allocated\n @return Pointer to the allocated block, or `NULL` if the block cannot\n         be allocated\n @see av_mallocz()"]
    pub fn av_malloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Allocate a memory block with alignment suitable for all memory accesses\n (including vectors if available on the CPU) and zero all the bytes of the\n block.\n\n @param size Size in bytes for the memory block to be allocated\n @return Pointer to the allocated block, or `NULL` if it cannot be allocated\n @see av_malloc()"]
    pub fn av_mallocz(size: usize) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Allocate a memory block for an array with av_malloc().\n\n The allocated memory will have size `size * nmemb` bytes.\n\n @param nmemb Number of element\n @param size  Size of a single element\n @return Pointer to the allocated block, or `NULL` if the block cannot\n         be allocated\n @see av_malloc()"]
    pub fn av_malloc_array(nmemb: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Allocate a memory block for an array with av_mallocz().\n\n The allocated memory will have size `size * nmemb` bytes.\n\n @param nmemb Number of elements\n @param size  Size of the single element\n @return Pointer to the allocated block, or `NULL` if the block cannot\n         be allocated\n\n @see av_mallocz()\n @see av_malloc_array()"]
    pub fn av_mallocz_array(nmemb: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Non-inlined equivalent of av_mallocz_array().\n\n Created for symmetry with the calloc() C function."]
    pub fn av_calloc(nmemb: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Allocate, reallocate, or free a block of memory.\n\n If `ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is\n zero, free the memory block pointed to by `ptr`. Otherwise, expand or\n shrink that block of memory according to `size`.\n\n @param ptr  Pointer to a memory block already allocated with\n             av_realloc() or `NULL`\n @param size Size in bytes of the memory block to be allocated or\n             reallocated\n\n @return Pointer to a newly-reallocated block or `NULL` if the block\n         cannot be reallocated or the function is used to free the memory block\n\n @warning Unlike av_malloc(), the returned pointer is not guaranteed to be\n          correctly aligned.\n @see av_fast_realloc()\n @see av_reallocp()"]
    pub fn av_realloc(ptr: *mut libc::c_void, size: usize) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Allocate, reallocate, or free a block of memory through a pointer to a\n pointer.\n\n If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is\n zero, free the memory block pointed to by `*ptr`. Otherwise, expand or\n shrink that block of memory according to `size`.\n\n @param[in,out] ptr  Pointer to a pointer to a memory block already allocated\n                     with av_realloc(), or a pointer to `NULL`. The pointer\n                     is updated on success, or freed on failure.\n @param[in]     size Size in bytes for the memory block to be allocated or\n                     reallocated\n\n @return Zero on success, an AVERROR error code on failure\n\n @warning Unlike av_malloc(), the allocated memory is not guaranteed to be\n          correctly aligned."]
    pub fn av_reallocp(ptr: *mut libc::c_void, size: usize) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate, reallocate, or free a block of memory.\n\n This function does the same thing as av_realloc(), except:\n - It takes two size arguments and allocates `nelem * elsize` bytes,\n   after checking the result of the multiplication for integer overflow.\n - It frees the input block in case of failure, thus avoiding the memory\n   leak with the classic\n   @code{.c}\n   buf = realloc(buf);\n   if (!buf)\n       return -1;\n   @endcode\n   pattern."]
    pub fn av_realloc_f(ptr: *mut libc::c_void, nelem: usize, elsize: usize) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Allocate, reallocate, or free an array.\n\n If `ptr` is `NULL` and `nmemb` > 0, allocate a new block. If\n `nmemb` is zero, free the memory block pointed to by `ptr`.\n\n @param ptr   Pointer to a memory block already allocated with\n              av_realloc() or `NULL`\n @param nmemb Number of elements in the array\n @param size  Size of the single element of the array\n\n @return Pointer to a newly-reallocated block or NULL if the block\n         cannot be reallocated or the function is used to free the memory block\n\n @warning Unlike av_malloc(), the allocated memory is not guaranteed to be\n          correctly aligned.\n @see av_reallocp_array()"]
    pub fn av_realloc_array(ptr: *mut libc::c_void, nmemb: usize, size: usize)
        -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Allocate, reallocate, or free an array through a pointer to a pointer.\n\n If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block. If `nmemb` is\n zero, free the memory block pointed to by `*ptr`.\n\n @param[in,out] ptr   Pointer to a pointer to a memory block already\n                      allocated with av_realloc(), or a pointer to `NULL`.\n                      The pointer is updated on success, or freed on failure.\n @param[in]     nmemb Number of elements\n @param[in]     size  Size of the single element\n\n @return Zero on success, an AVERROR error code on failure\n\n @warning Unlike av_malloc(), the allocated memory is not guaranteed to be\n          correctly aligned."]
    pub fn av_reallocp_array(ptr: *mut libc::c_void, nmemb: usize, size: usize) -> libc::c_int;
}
extern "C" {
    #[doc = " Reallocate the given buffer if it is not large enough, otherwise do nothing.\n\n If the given buffer is `NULL`, then a new uninitialized buffer is allocated.\n\n If the given buffer is not large enough, and reallocation fails, `NULL` is\n returned and `*size` is set to 0, but the original buffer is not changed or\n freed.\n\n A typical use pattern follows:\n\n @code{.c}\n uint8_t *buf = ...;\n uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);\n if (!new_buf) {\n     // Allocation failed; clean up original buffer\n     av_freep(&buf);\n     return AVERROR(ENOMEM);\n }\n @endcode\n\n @param[in,out] ptr      Already allocated buffer, or `NULL`\n @param[in,out] size     Pointer to the size of buffer `ptr`. `*size` is\n                         updated to the new allocated size, in particular 0\n                         in case of failure.\n @param[in]     min_size Desired minimal size of buffer `ptr`\n @return `ptr` if the buffer is large enough, a pointer to newly reallocated\n         buffer if the buffer was not large enough, or `NULL` in case of\n         error\n @see av_realloc()\n @see av_fast_malloc()"]
    pub fn av_fast_realloc(
        ptr: *mut libc::c_void,
        size: *mut libc::c_uint,
        min_size: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Allocate a buffer, reusing the given one if large enough.\n\n Contrary to av_fast_realloc(), the current buffer contents might not be\n preserved and on error the old buffer is freed, thus no special handling to\n avoid memleaks is necessary.\n\n `*ptr` is allowed to be `NULL`, in which case allocation always happens if\n `size_needed` is greater than 0.\n\n @code{.c}\n uint8_t *buf = ...;\n av_fast_malloc(&buf, &current_size, size_needed);\n if (!buf) {\n     // Allocation failed; buf already freed\n     return AVERROR(ENOMEM);\n }\n @endcode\n\n @param[in,out] ptr      Pointer to pointer to an already allocated buffer.\n                         `*ptr` will be overwritten with pointer to new\n                         buffer on success or `NULL` on failure\n @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is\n                         updated to the new allocated size, in particular 0\n                         in case of failure.\n @param[in]     min_size Desired minimal size of buffer `*ptr`\n @see av_realloc()\n @see av_fast_mallocz()"]
    pub fn av_fast_malloc(ptr: *mut libc::c_void, size: *mut libc::c_uint, min_size: usize);
}
extern "C" {
    #[doc = " Allocate and clear a buffer, reusing the given one if large enough.\n\n Like av_fast_malloc(), but all newly allocated space is initially cleared.\n Reused buffer is not cleared.\n\n `*ptr` is allowed to be `NULL`, in which case allocation always happens if\n `size_needed` is greater than 0.\n\n @param[in,out] ptr      Pointer to pointer to an already allocated buffer.\n                         `*ptr` will be overwritten with pointer to new\n                         buffer on success or `NULL` on failure\n @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is\n                         updated to the new allocated size, in particular 0\n                         in case of failure.\n @param[in]     min_size Desired minimal size of buffer `*ptr`\n @see av_fast_malloc()"]
    pub fn av_fast_mallocz(ptr: *mut libc::c_void, size: *mut libc::c_uint, min_size: usize);
}
extern "C" {
    #[doc = " Free a memory block which has been allocated with a function of av_malloc()\n or av_realloc() family.\n\n @param ptr Pointer to the memory block which should be freed.\n\n @note `ptr = NULL` is explicitly allowed.\n @note It is recommended that you use av_freep() instead, to prevent leaving\n       behind dangling pointers.\n @see av_freep()"]
    pub fn av_free(ptr: *mut libc::c_void);
}
extern "C" {
    #[doc = " Free a memory block which has been allocated with a function of av_malloc()\n or av_realloc() family, and set the pointer pointing to it to `NULL`.\n\n @code{.c}\n uint8_t *buf = av_malloc(16);\n av_free(buf);\n // buf now contains a dangling pointer to freed memory, and accidental\n // dereference of buf will result in a use-after-free, which may be a\n // security risk.\n\n uint8_t *buf = av_malloc(16);\n av_freep(&buf);\n // buf is now NULL, and accidental dereference will only result in a\n // NULL-pointer dereference.\n @endcode\n\n @param ptr Pointer to the pointer to the memory block which should be freed\n @note `*ptr = NULL` is safe and leads to no action.\n @see av_free()"]
    pub fn av_freep(ptr: *mut libc::c_void);
}
extern "C" {
    #[doc = " Duplicate a string.\n\n @param s String to be duplicated\n @return Pointer to a newly-allocated string containing a\n         copy of `s` or `NULL` if the string cannot be allocated\n @see av_strndup()"]
    pub fn av_strdup(s: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Duplicate a substring of a string.\n\n @param s   String to be duplicated\n @param len Maximum length of the resulting string (not counting the\n            terminating byte)\n @return Pointer to a newly-allocated string containing a\n         substring of `s` or `NULL` if the string cannot be allocated"]
    pub fn av_strndup(s: *const libc::c_char, len: usize) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Duplicate a buffer with av_malloc().\n\n @param p    Buffer to be duplicated\n @param size Size in bytes of the buffer copied\n @return Pointer to a newly allocated buffer containing a\n         copy of `p` or `NULL` if the buffer cannot be allocated"]
    pub fn av_memdup(p: *const libc::c_void, size: usize) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Overlapping memcpy() implementation.\n\n @param dst  Destination buffer\n @param back Number of bytes back to start copying (i.e. the initial size of\n             the overlapping window); must be > 0\n @param cnt  Number of bytes to copy; must be >= 0\n\n @note `cnt > back` is valid, this will copy the bytes we just copied,\n       thus creating a repeating pattern with a period length of `back`."]
    pub fn av_memcpy_backptr(dst: *mut u8, back: libc::c_int, cnt: libc::c_int);
}
extern "C" {
    #[doc = " Add the pointer to an element to a dynamic array.\n\n The array to grow is supposed to be an array of pointers to\n structures, and the element to add must be a pointer to an already\n allocated structure.\n\n The array is reallocated when its size reaches powers of 2.\n Therefore, the amortized cost of adding an element is constant.\n\n In case of success, the pointer to the array is updated in order to\n point to the new grown array, and the number pointed to by `nb_ptr`\n is incremented.\n In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and\n `*nb_ptr` is set to 0.\n\n @param[in,out] tab_ptr Pointer to the array to grow\n @param[in,out] nb_ptr  Pointer to the number of elements in the array\n @param[in]     elem    Element to add\n @see av_dynarray_add_nofree(), av_dynarray2_add()"]
    pub fn av_dynarray_add(
        tab_ptr: *mut libc::c_void,
        nb_ptr: *mut libc::c_int,
        elem: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Add an element to a dynamic array.\n\n Function has the same functionality as av_dynarray_add(),\n but it doesn't free memory on fails. It returns error code\n instead and leave current buffer untouched.\n\n @return >=0 on success, negative otherwise\n @see av_dynarray_add(), av_dynarray2_add()"]
    pub fn av_dynarray_add_nofree(
        tab_ptr: *mut libc::c_void,
        nb_ptr: *mut libc::c_int,
        elem: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Add an element of size `elem_size` to a dynamic array.\n\n The array is reallocated when its number of elements reaches powers of 2.\n Therefore, the amortized cost of adding an element is constant.\n\n In case of success, the pointer to the array is updated in order to\n point to the new grown array, and the number pointed to by `nb_ptr`\n is incremented.\n In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and\n `*nb_ptr` is set to 0.\n\n @param[in,out] tab_ptr   Pointer to the array to grow\n @param[in,out] nb_ptr    Pointer to the number of elements in the array\n @param[in]     elem_size Size in bytes of an element in the array\n @param[in]     elem_data Pointer to the data of the element to add. If\n                          `NULL`, the space of the newly added element is\n                          allocated but left uninitialized.\n\n @return Pointer to the data of the element to copy in the newly allocated\n         space\n @see av_dynarray_add(), av_dynarray_add_nofree()"]
    pub fn av_dynarray2_add(
        tab_ptr: *mut *mut libc::c_void,
        nb_ptr: *mut libc::c_int,
        elem_size: usize,
        elem_data: *const u8,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Set the maximum size that may be allocated in one block.\n\n The value specified with this function is effective for all libavutil's @ref\n lavu_mem_funcs \"heap management functions.\"\n\n By default, the max value is defined as `INT_MAX`.\n\n @param max Value to be set as the new maximum size\n\n @warning Exercise extreme caution when using this function. Don't touch\n          this if you do not understand the full consequence of doing so."]
    pub fn av_max_alloc(max: usize);
}
#[doc = " Rational number (pair of numerator and denominator)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVRational {
    #[doc = "< Numerator"]
    pub num: libc::c_int,
    #[doc = "< Denominator"]
    pub den: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVRational"][::std::mem::size_of::<AVRational>() - 8usize];
    ["Alignment of AVRational"][::std::mem::align_of::<AVRational>() - 4usize];
    ["Offset of field: AVRational::num"][::std::mem::offset_of!(AVRational, num) - 0usize];
    ["Offset of field: AVRational::den"][::std::mem::offset_of!(AVRational, den) - 4usize];
};
extern "C" {
    #[doc = " Reduce a fraction.\n\n This is useful for framerate calculations.\n\n @param[out] dst_num Destination numerator\n @param[out] dst_den Destination denominator\n @param[in]      num Source numerator\n @param[in]      den Source denominator\n @param[in]      max Maximum allowed values for `dst_num` & `dst_den`\n @return 1 if the operation is exact, 0 otherwise"]
    pub fn av_reduce(
        dst_num: *mut libc::c_int,
        dst_den: *mut libc::c_int,
        num: i64,
        den: i64,
        max: i64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Multiply two rationals.\n @param b First rational\n @param c Second rational\n @return b*c"]
    pub fn av_mul_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    #[doc = " Divide one rational by another.\n @param b First rational\n @param c Second rational\n @return b/c"]
    pub fn av_div_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    #[doc = " Add two rationals.\n @param b First rational\n @param c Second rational\n @return b+c"]
    pub fn av_add_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    #[doc = " Subtract one rational from another.\n @param b First rational\n @param c Second rational\n @return b-c"]
    pub fn av_sub_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    #[doc = " Convert a double precision floating point number to a rational.\n\n In case of infinity, the returned value is expressed as `{1, 0}` or\n `{-1, 0}` depending on the sign.\n\n In general rational numbers with |num| <= 1<<26 && |den| <= 1<<26\n can be recovered exactly from their double representation.\n (no exceptions were found within 1B random ones)\n\n @param d   `double` to convert\n @param max Maximum allowed numerator and denominator\n @return `d` in AVRational form\n @see av_q2d()"]
    pub fn av_d2q(d: f64, max: libc::c_int) -> AVRational;
}
extern "C" {
    #[doc = " Find which of the two rationals is closer to another rational.\n\n @param q     Rational to be compared against\n @param q1,q2 Rationals to be tested\n @return One of the following values:\n         - 1 if `q1` is nearer to `q` than `q2`\n         - -1 if `q2` is nearer to `q` than `q1`\n         - 0 if they have the same distance"]
    pub fn av_nearer_q(q: AVRational, q1: AVRational, q2: AVRational) -> libc::c_int;
}
extern "C" {
    #[doc = " Find the value in a list of rationals nearest a given reference rational.\n\n @param q      Reference rational\n @param q_list Array of rationals terminated by `{0, 0}`\n @return Index of the nearest value found in the array"]
    pub fn av_find_nearest_q_idx(q: AVRational, q_list: *const AVRational) -> libc::c_int;
}
extern "C" {
    #[doc = " Convert an AVRational to a IEEE 32-bit `float` expressed in fixed-point\n format.\n\n @param q Rational to be converted\n @return Equivalent floating-point value, expressed as an unsigned 32-bit\n         integer.\n @note The returned value is platform-indepedant."]
    pub fn av_q2intfloat(q: AVRational) -> u32;
}
extern "C" {
    #[doc = " Return the best rational so that a and b are multiple of it.\n If the resulting denominator is larger than max_den, return def."]
    pub fn av_gcd_q(
        a: AVRational,
        b: AVRational,
        max_den: libc::c_int,
        def: AVRational,
    ) -> AVRational;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat32 {
    pub i: u32,
    pub f: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of av_intfloat32"][::std::mem::size_of::<av_intfloat32>() - 4usize];
    ["Alignment of av_intfloat32"][::std::mem::align_of::<av_intfloat32>() - 4usize];
    ["Offset of field: av_intfloat32::i"][::std::mem::offset_of!(av_intfloat32, i) - 0usize];
    ["Offset of field: av_intfloat32::f"][::std::mem::offset_of!(av_intfloat32, f) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat64 {
    pub i: u64,
    pub f: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of av_intfloat64"][::std::mem::size_of::<av_intfloat64>() - 8usize];
    ["Alignment of av_intfloat64"][::std::mem::align_of::<av_intfloat64>() - 8usize];
    ["Offset of field: av_intfloat64::i"][::std::mem::offset_of!(av_intfloat64, i) - 0usize];
    ["Offset of field: av_intfloat64::f"][::std::mem::offset_of!(av_intfloat64, f) - 0usize];
};
#[repr(u32)]
#[doc = " Rounding methods."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVRounding {
    #[doc = "< Round toward zero."]
    AV_ROUND_ZERO = 0,
    #[doc = "< Round away from zero."]
    AV_ROUND_INF = 1,
    #[doc = "< Round toward -infinity."]
    AV_ROUND_DOWN = 2,
    #[doc = "< Round toward +infinity."]
    AV_ROUND_UP = 3,
    #[doc = "< Round to nearest and halfway cases away from zero."]
    AV_ROUND_NEAR_INF = 5,
    #[doc = " Flag telling rescaling functions to pass `INT64_MIN`/`MAX` through\n unchanged, avoiding special cases for #AV_NOPTS_VALUE.\n\n Unlike other values of the enumeration AVRounding, this value is a\n bitmask that must be used in conjunction with another value of the\n enumeration through a bitwise OR, in order to set behavior for normal\n cases.\n\n @code{.c}\n av_rescale_rnd(3, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);\n // Rescaling 3:\n //     Calculating 3 * 1 / 2\n //     3 / 2 is rounded up to 2\n //     => 2\n\n av_rescale_rnd(AV_NOPTS_VALUE, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);\n // Rescaling AV_NOPTS_VALUE:\n //     AV_NOPTS_VALUE == INT64_MIN\n //     AV_NOPTS_VALUE is passed through\n //     => AV_NOPTS_VALUE\n @endcode"]
    AV_ROUND_PASS_MINMAX = 8192,
}
extern "C" {
    #[doc = " Compute the greatest common divisor of two integer operands.\n\n @param a,b Operands\n @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;\n if a == 0 and b == 0, returns 0."]
    pub fn av_gcd(a: i64, b: i64) -> i64;
}
extern "C" {
    #[doc = " Rescale a 64-bit integer with rounding to nearest.\n\n The operation is mathematically equivalent to `a * b / c`, but writing that\n directly can overflow.\n\n This function is equivalent to av_rescale_rnd() with #AV_ROUND_NEAR_INF.\n\n @see av_rescale_rnd(), av_rescale_q(), av_rescale_q_rnd()"]
    pub fn av_rescale(a: i64, b: i64, c: i64) -> i64;
}
extern "C" {
    #[doc = " Rescale a 64-bit integer with specified rounding.\n\n The operation is mathematically equivalent to `a * b / c`, but writing that\n directly can overflow, and does not support different rounding methods.\n If the result is not representable then INT64_MIN is returned.\n\n @see av_rescale(), av_rescale_q(), av_rescale_q_rnd()"]
    pub fn av_rescale_rnd(a: i64, b: i64, c: i64, rnd: AVRounding) -> i64;
}
extern "C" {
    #[doc = " Rescale a 64-bit integer by 2 rational numbers.\n\n The operation is mathematically equivalent to `a * bq / cq`.\n\n This function is equivalent to av_rescale_q_rnd() with #AV_ROUND_NEAR_INF.\n\n @see av_rescale(), av_rescale_rnd(), av_rescale_q_rnd()"]
    pub fn av_rescale_q(a: i64, bq: AVRational, cq: AVRational) -> i64;
}
extern "C" {
    #[doc = " Rescale a 64-bit integer by 2 rational numbers with specified rounding.\n\n The operation is mathematically equivalent to `a * bq / cq`.\n\n @see av_rescale(), av_rescale_rnd(), av_rescale_q()"]
    pub fn av_rescale_q_rnd(a: i64, bq: AVRational, cq: AVRational, rnd: AVRounding) -> i64;
}
extern "C" {
    #[doc = " Compare two timestamps each in its own time base.\n\n @return One of the following values:\n         - -1 if `ts_a` is before `ts_b`\n         - 1 if `ts_a` is after `ts_b`\n         - 0 if they represent the same position\n\n @warning\n The result of the function is undefined if one of the timestamps is outside\n the `int64_t` range when represented in the other's timebase."]
    pub fn av_compare_ts(ts_a: i64, tb_a: AVRational, ts_b: i64, tb_b: AVRational) -> libc::c_int;
}
extern "C" {
    #[doc = " Compare the remainders of two integer operands divided by a common divisor.\n\n In other words, compare the least significant `log2(mod)` bits of integers\n `a` and `b`.\n\n @code{.c}\n av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 % 0x10  (0x2)\n av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)\n @endcode\n\n @param a,b Operands\n @param mod Divisor; must be a power of 2\n @return\n         - a negative value if `a % mod < b % mod`\n         - a positive value if `a % mod > b % mod`\n         - zero             if `a % mod == b % mod`"]
    pub fn av_compare_mod(a: u64, b: u64, mod_: u64) -> i64;
}
extern "C" {
    #[doc = " Rescale a timestamp while preserving known durations.\n\n This function is designed to be called per audio packet to scale the input\n timestamp to a different time base. Compared to a simple av_rescale_q()\n call, this function is robust against possible inconsistent frame durations.\n\n The `last` parameter is a state variable that must be preserved for all\n subsequent calls for the same stream. For the first call, `*last` should be\n initialized to #AV_NOPTS_VALUE.\n\n @param[in]     in_tb    Input time base\n @param[in]     in_ts    Input timestamp\n @param[in]     fs_tb    Duration time base; typically this is finer-grained\n                         (greater) than `in_tb` and `out_tb`\n @param[in]     duration Duration till the next call to this function (i.e.\n                         duration of the current packet/frame)\n @param[in,out] last     Pointer to a timestamp expressed in terms of\n                         `fs_tb`, acting as a state variable\n @param[in]     out_tb   Output timebase\n @return        Timestamp expressed in terms of `out_tb`\n\n @note In the context of this function, \"duration\" is in term of samples, not\n       seconds."]
    pub fn av_rescale_delta(
        in_tb: AVRational,
        in_ts: i64,
        fs_tb: AVRational,
        duration: libc::c_int,
        last: *mut i64,
        out_tb: AVRational,
    ) -> i64;
}
extern "C" {
    #[doc = " Add a value to a timestamp.\n\n This function guarantees that when the same value is repeatly added that\n no accumulation of rounding errors occurs.\n\n @param[in] ts     Input timestamp\n @param[in] ts_tb  Input timestamp time base\n @param[in] inc    Value to be added\n @param[in] inc_tb Time base of `inc`"]
    pub fn av_add_stable(ts_tb: AVRational, ts: i64, inc_tb: AVRational, inc: i64) -> i64;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVClassCategory {
    AV_CLASS_CATEGORY_NA = 0,
    AV_CLASS_CATEGORY_INPUT = 1,
    AV_CLASS_CATEGORY_OUTPUT = 2,
    AV_CLASS_CATEGORY_MUXER = 3,
    AV_CLASS_CATEGORY_DEMUXER = 4,
    AV_CLASS_CATEGORY_ENCODER = 5,
    AV_CLASS_CATEGORY_DECODER = 6,
    AV_CLASS_CATEGORY_FILTER = 7,
    AV_CLASS_CATEGORY_BITSTREAM_FILTER = 8,
    AV_CLASS_CATEGORY_SWSCALER = 9,
    AV_CLASS_CATEGORY_SWRESAMPLER = 10,
    AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40,
    AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = 41,
    AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = 42,
    AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = 43,
    AV_CLASS_CATEGORY_DEVICE_OUTPUT = 44,
    AV_CLASS_CATEGORY_DEVICE_INPUT = 45,
    #[doc = "< not part of ABI/API"]
    AV_CLASS_CATEGORY_NB = 46,
}
#[doc = " Describe the class of an AVClass context structure. That is an\n arbitrary struct of which the first field is a pointer to an\n AVClass struct (e.g. AVCodecContext, AVFormatContext etc.)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVClass {
    #[doc = " The name of the class; usually it is the same name as the\n context structure type to which the AVClass is associated."]
    pub class_name: *const libc::c_char,
    #[doc = " A pointer to a function which returns the name of a context\n instance ctx associated with the class."]
    pub item_name:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut libc::c_void) -> *const libc::c_char>,
    #[doc = " a pointer to the first option specified in the class if any or NULL\n\n @see av_set_default_options()"]
    pub option: *const AVOption,
    #[doc = " LIBAVUTIL_VERSION with which this structure was created.\n This is used to allow fields to be added without requiring major\n version bumps everywhere."]
    pub version: libc::c_int,
    #[doc = " Offset in the structure where log_level_offset is stored.\n 0 means there is no such variable"]
    pub log_level_offset_offset: libc::c_int,
    #[doc = " Offset in the structure where a pointer to the parent context for\n logging is stored. For example a decoder could pass its AVCodecContext\n to eval as such a parent context, which an av_log() implementation\n could then leverage to display the parent context.\n The offset can be NULL."]
    pub parent_log_context_offset: libc::c_int,
    #[doc = " Return next AVOptions-enabled child or NULL"]
    pub child_next: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut libc::c_void, prev: *mut libc::c_void) -> *mut libc::c_void,
    >,
    #[doc = " Return an AVClass corresponding to the next potential\n AVOptions-enabled child.\n\n The difference between child_next and this is that\n child_next iterates over _already existing_ objects, while\n child_class_next iterates over _all possible_ children."]
    pub child_class_next:
        ::std::option::Option<unsafe extern "C" fn(prev: *const AVClass) -> *const AVClass>,
    #[doc = " Category used for visualization (like color)\n This is only set if the category is equal for all objects using this class.\n available since version (51 << 16 | 56 << 8 | 100)"]
    pub category: AVClassCategory,
    #[doc = " Callback to return the category.\n available since version (51 << 16 | 59 << 8 | 100)"]
    pub get_category:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut libc::c_void) -> AVClassCategory>,
    #[doc = " Callback to return the supported/allowed ranges.\n available since version (52.12)"]
    pub query_ranges: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut AVOptionRanges,
            obj: *mut libc::c_void,
            key: *const libc::c_char,
            flags: libc::c_int,
        ) -> libc::c_int,
    >,
    #[doc = " Iterate over the AVClasses corresponding to potential AVOptions-enabled\n children.\n\n @param iter pointer to opaque iteration state. The caller must initialize\n             *iter to NULL before the first call.\n @return AVClass for the next AVOptions-enabled child or NULL if there are\n         no more such children.\n\n @note The difference between child_next and this is that child_next\n       iterates over _already existing_ objects, while child_class_iterate\n       iterates over _all possible_ children."]
    pub child_class_iterate:
        ::std::option::Option<unsafe extern "C" fn(iter: *mut *mut libc::c_void) -> *const AVClass>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVClass"][::std::mem::size_of::<AVClass>() - 88usize];
    ["Alignment of AVClass"][::std::mem::align_of::<AVClass>() - 8usize];
    ["Offset of field: AVClass::class_name"][::std::mem::offset_of!(AVClass, class_name) - 0usize];
    ["Offset of field: AVClass::item_name"][::std::mem::offset_of!(AVClass, item_name) - 8usize];
    ["Offset of field: AVClass::option"][::std::mem::offset_of!(AVClass, option) - 16usize];
    ["Offset of field: AVClass::version"][::std::mem::offset_of!(AVClass, version) - 24usize];
    ["Offset of field: AVClass::log_level_offset_offset"]
        [::std::mem::offset_of!(AVClass, log_level_offset_offset) - 28usize];
    ["Offset of field: AVClass::parent_log_context_offset"]
        [::std::mem::offset_of!(AVClass, parent_log_context_offset) - 32usize];
    ["Offset of field: AVClass::child_next"][::std::mem::offset_of!(AVClass, child_next) - 40usize];
    ["Offset of field: AVClass::child_class_next"]
        [::std::mem::offset_of!(AVClass, child_class_next) - 48usize];
    ["Offset of field: AVClass::category"][::std::mem::offset_of!(AVClass, category) - 56usize];
    ["Offset of field: AVClass::get_category"]
        [::std::mem::offset_of!(AVClass, get_category) - 64usize];
    ["Offset of field: AVClass::query_ranges"]
        [::std::mem::offset_of!(AVClass, query_ranges) - 72usize];
    ["Offset of field: AVClass::child_class_iterate"]
        [::std::mem::offset_of!(AVClass, child_class_iterate) - 80usize];
};
extern "C" {
    #[doc = " Send the specified message to the log if the level is less than or equal\n to the current av_log_level. By default, all logging messages are sent to\n stderr. This behavior can be altered by setting a different logging callback\n function.\n @see av_log_set_callback\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n        pointer to an AVClass struct or NULL if general log.\n @param level The importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\".\n @param fmt The format string (printf-compatible) that specifies how\n        subsequent arguments are converted to output."]
    pub fn av_log(avcl: *mut libc::c_void, level: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Send the specified message to the log once with the initial_level and then with\n the subsequent_level. By default, all logging messages are sent to\n stderr. This behavior can be altered by setting a different logging callback\n function.\n @see av_log\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n        pointer to an AVClass struct or NULL if general log.\n @param initial_level importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\" for the first occurance.\n @param subsequent_level importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\" after the first occurance.\n @param fmt The format string (printf-compatible) that specifies how\n        subsequent arguments are converted to output.\n @param state a variable to keep trak of if a message has already been printed\n        this must be initialized to 0 before the first use. The same state\n        must not be accessed by 2 Threads simultaneously."]
    pub fn av_log_once(
        avcl: *mut libc::c_void,
        initial_level: libc::c_int,
        subsequent_level: libc::c_int,
        state: *mut libc::c_int,
        fmt: *const libc::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Send the specified message to the log if the level is less than or equal\n to the current av_log_level. By default, all logging messages are sent to\n stderr. This behavior can be altered by setting a different logging callback\n function.\n @see av_log_set_callback\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n        pointer to an AVClass struct.\n @param level The importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\".\n @param fmt The format string (printf-compatible) that specifies how\n        subsequent arguments are converted to output.\n @param vl The arguments referenced by the format string."]
    pub fn av_vlog(
        avcl: *mut libc::c_void,
        level: libc::c_int,
        fmt: *const libc::c_char,
        vl: *mut __va_list_tag,
    );
}
extern "C" {
    #[doc = " Get the current log level\n\n @see lavu_log_constants\n\n @return Current log level"]
    pub fn av_log_get_level() -> libc::c_int;
}
extern "C" {
    #[doc = " Set the log level\n\n @see lavu_log_constants\n\n @param level Logging level"]
    pub fn av_log_set_level(level: libc::c_int);
}
extern "C" {
    #[doc = " Set the logging callback\n\n @note The callback must be thread safe, even if the application does not use\n       threads itself as some codecs are multithreaded.\n\n @see av_log_default_callback\n\n @param callback A logging function with a compatible signature."]
    pub fn av_log_set_callback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: libc::c_int,
                arg3: *const libc::c_char,
                arg4: *mut __va_list_tag,
            ),
        >,
    );
}
extern "C" {
    #[doc = " Default logging callback\n\n It prints the message to stderr, optionally colorizing it.\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n        pointer to an AVClass struct.\n @param level The importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\".\n @param fmt The format string (printf-compatible) that specifies how\n        subsequent arguments are converted to output.\n @param vl The arguments referenced by the format string."]
    pub fn av_log_default_callback(
        avcl: *mut libc::c_void,
        level: libc::c_int,
        fmt: *const libc::c_char,
        vl: *mut __va_list_tag,
    );
}
extern "C" {
    #[doc = " Return the context name\n\n @param  ctx The AVClass context\n\n @return The AVClass class_name"]
    pub fn av_default_item_name(ctx: *mut libc::c_void) -> *const libc::c_char;
}
extern "C" {
    pub fn av_default_get_category(ptr: *mut libc::c_void) -> AVClassCategory;
}
extern "C" {
    #[doc = " Format a line of log the same way as the default callback.\n @param line          buffer to receive the formatted line\n @param line_size     size of the buffer\n @param print_prefix  used to store whether the prefix must be printed;\n                      must point to a persistent integer initially set to 1"]
    pub fn av_log_format_line(
        ptr: *mut libc::c_void,
        level: libc::c_int,
        fmt: *const libc::c_char,
        vl: *mut __va_list_tag,
        line: *mut libc::c_char,
        line_size: libc::c_int,
        print_prefix: *mut libc::c_int,
    );
}
extern "C" {
    #[doc = " Format a line of log the same way as the default callback.\n @param line          buffer to receive the formatted line;\n                      may be NULL if line_size is 0\n @param line_size     size of the buffer; at most line_size-1 characters will\n                      be written to the buffer, plus one null terminator\n @param print_prefix  used to store whether the prefix must be printed;\n                      must point to a persistent integer initially set to 1\n @return Returns a negative value if an error occurred, otherwise returns\n         the number of characters that would have been written for a\n         sufficiently large buffer, not including the terminating null\n         character. If the return value is not less than line_size, it means\n         that the log message was truncated to fit the buffer."]
    pub fn av_log_format_line2(
        ptr: *mut libc::c_void,
        level: libc::c_int,
        fmt: *const libc::c_char,
        vl: *mut __va_list_tag,
        line: *mut libc::c_char,
        line_size: libc::c_int,
        print_prefix: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_log_set_flags(arg: libc::c_int);
}
extern "C" {
    pub fn av_log_get_flags() -> libc::c_int;
}
impl AVPixelFormat {
    pub const AV_PIX_FMT_VAAPI: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_VAAPI_VLD;
}
impl AVPixelFormat {
    pub const AV_PIX_FMT_Y400A: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_YA8;
}
impl AVPixelFormat {
    pub const AV_PIX_FMT_GRAY8A: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_YA8;
}
impl AVPixelFormat {
    pub const AV_PIX_FMT_GBR24P: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_GBRP;
}
#[repr(i32)]
#[doc = " Pixel format.\n\n @note\n AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA\n color is put together as:\n  (A << 24) | (R << 16) | (G << 8) | B\n This is stored as BGRA on little-endian CPU architectures and ARGB on\n big-endian CPUs.\n\n @note\n If the resolution is not a multiple of the chroma subsampling factor\n then the chroma plane resolution must be rounded up.\n\n @par\n When the pixel format is palettized RGB32 (AV_PIX_FMT_PAL8), the palettized\n image data is stored in AVFrame.data[0]. The palette is transported in\n AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is\n formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is\n also endian-specific). Note also that the individual RGB32 palette\n components stored in AVFrame.data[1] should be in the range 0..255.\n This is important as many custom PAL8 video codecs that were designed\n to run on the IBM VGA graphics adapter use 6-bit palette components.\n\n @par\n For all the 8 bits per pixel formats, an RGB32 palette is in data[1] like\n for pal8. This palette is filled in automatically by the function\n allocating the picture."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVPixelFormat {
    AV_PIX_FMT_NONE = -1,
    #[doc = "< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)"]
    AV_PIX_FMT_YUV420P = 0,
    #[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr"]
    AV_PIX_FMT_YUYV422 = 1,
    #[doc = "< packed RGB 8:8:8, 24bpp, RGBRGB..."]
    AV_PIX_FMT_RGB24 = 2,
    #[doc = "< packed RGB 8:8:8, 24bpp, BGRBGR..."]
    AV_PIX_FMT_BGR24 = 3,
    #[doc = "< planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
    AV_PIX_FMT_YUV422P = 4,
    #[doc = "< planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)"]
    AV_PIX_FMT_YUV444P = 5,
    #[doc = "< planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)"]
    AV_PIX_FMT_YUV410P = 6,
    #[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)"]
    AV_PIX_FMT_YUV411P = 7,
    #[doc = "<        Y        ,  8bpp"]
    AV_PIX_FMT_GRAY8 = 8,
    #[doc = "<        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb"]
    AV_PIX_FMT_MONOWHITE = 9,
    #[doc = "<        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb"]
    AV_PIX_FMT_MONOBLACK = 10,
    #[doc = "< 8 bits with AV_PIX_FMT_RGB32 palette"]
    AV_PIX_FMT_PAL8 = 11,
    #[doc = "< planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range"]
    AV_PIX_FMT_YUVJ420P = 12,
    #[doc = "< planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range"]
    AV_PIX_FMT_YUVJ422P = 13,
    #[doc = "< planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range"]
    AV_PIX_FMT_YUVJ444P = 14,
    #[doc = "< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1"]
    AV_PIX_FMT_UYVY422 = 15,
    #[doc = "< packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3"]
    AV_PIX_FMT_UYYVYY411 = 16,
    #[doc = "< packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)"]
    AV_PIX_FMT_BGR8 = 17,
    #[doc = "< packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits"]
    AV_PIX_FMT_BGR4 = 18,
    #[doc = "< packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)"]
    AV_PIX_FMT_BGR4_BYTE = 19,
    #[doc = "< packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)"]
    AV_PIX_FMT_RGB8 = 20,
    #[doc = "< packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits"]
    AV_PIX_FMT_RGB4 = 21,
    #[doc = "< packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)"]
    AV_PIX_FMT_RGB4_BYTE = 22,
    #[doc = "< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
    AV_PIX_FMT_NV12 = 23,
    #[doc = "< as above, but U and V bytes are swapped"]
    AV_PIX_FMT_NV21 = 24,
    #[doc = "< packed ARGB 8:8:8:8, 32bpp, ARGBARGB..."]
    AV_PIX_FMT_ARGB = 25,
    #[doc = "< packed RGBA 8:8:8:8, 32bpp, RGBARGBA..."]
    AV_PIX_FMT_RGBA = 26,
    #[doc = "< packed ABGR 8:8:8:8, 32bpp, ABGRABGR..."]
    AV_PIX_FMT_ABGR = 27,
    #[doc = "< packed BGRA 8:8:8:8, 32bpp, BGRABGRA..."]
    AV_PIX_FMT_BGRA = 28,
    #[doc = "<        Y        , 16bpp, big-endian"]
    AV_PIX_FMT_GRAY16BE = 29,
    #[doc = "<        Y        , 16bpp, little-endian"]
    AV_PIX_FMT_GRAY16LE = 30,
    #[doc = "< planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)"]
    AV_PIX_FMT_YUV440P = 31,
    #[doc = "< planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range"]
    AV_PIX_FMT_YUVJ440P = 32,
    #[doc = "< planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)"]
    AV_PIX_FMT_YUVA420P = 33,
    #[doc = "< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian"]
    AV_PIX_FMT_RGB48BE = 34,
    #[doc = "< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian"]
    AV_PIX_FMT_RGB48LE = 35,
    #[doc = "< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian"]
    AV_PIX_FMT_RGB565BE = 36,
    #[doc = "< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian"]
    AV_PIX_FMT_RGB565LE = 37,
    #[doc = "< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian   , X=unused/undefined"]
    AV_PIX_FMT_RGB555BE = 38,
    #[doc = "< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, X=unused/undefined"]
    AV_PIX_FMT_RGB555LE = 39,
    #[doc = "< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian"]
    AV_PIX_FMT_BGR565BE = 40,
    #[doc = "< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian"]
    AV_PIX_FMT_BGR565LE = 41,
    #[doc = "< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian   , X=unused/undefined"]
    AV_PIX_FMT_BGR555BE = 42,
    #[doc = "< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined"]
    AV_PIX_FMT_BGR555LE = 43,
    #[doc = "< HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers"]
    AV_PIX_FMT_VAAPI_MOCO = 44,
    #[doc = "< HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers"]
    AV_PIX_FMT_VAAPI_IDCT = 45,
    #[doc = "< HW decoding through VA API, Picture.data[3] contains a VASurfaceID"]
    AV_PIX_FMT_VAAPI_VLD = 46,
    #[doc = "< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
    AV_PIX_FMT_YUV420P16LE = 47,
    #[doc = "< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
    AV_PIX_FMT_YUV420P16BE = 48,
    #[doc = "< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV422P16LE = 49,
    #[doc = "< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV422P16BE = 50,
    #[doc = "< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV444P16LE = 51,
    #[doc = "< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV444P16BE = 52,
    #[doc = "< HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer"]
    AV_PIX_FMT_DXVA2_VLD = 53,
    #[doc = "< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, X=unused/undefined"]
    AV_PIX_FMT_RGB444LE = 54,
    #[doc = "< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian,    X=unused/undefined"]
    AV_PIX_FMT_RGB444BE = 55,
    #[doc = "< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, X=unused/undefined"]
    AV_PIX_FMT_BGR444LE = 56,
    #[doc = "< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian,    X=unused/undefined"]
    AV_PIX_FMT_BGR444BE = 57,
    #[doc = "< 8 bits gray, 8 bits alpha"]
    AV_PIX_FMT_YA8 = 58,
    #[doc = "< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian"]
    AV_PIX_FMT_BGR48BE = 59,
    #[doc = "< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian"]
    AV_PIX_FMT_BGR48LE = 60,
    #[doc = "< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
    AV_PIX_FMT_YUV420P9BE = 61,
    #[doc = "< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
    AV_PIX_FMT_YUV420P9LE = 62,
    #[doc = "< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
    AV_PIX_FMT_YUV420P10BE = 63,
    #[doc = "< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
    AV_PIX_FMT_YUV420P10LE = 64,
    #[doc = "< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV422P10BE = 65,
    #[doc = "< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV422P10LE = 66,
    #[doc = "< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV444P9BE = 67,
    #[doc = "< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV444P9LE = 68,
    #[doc = "< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV444P10BE = 69,
    #[doc = "< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV444P10LE = 70,
    #[doc = "< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV422P9BE = 71,
    #[doc = "< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV422P9LE = 72,
    #[doc = "< planar GBR 4:4:4 24bpp"]
    AV_PIX_FMT_GBRP = 73,
    #[doc = "< planar GBR 4:4:4 27bpp, big-endian"]
    AV_PIX_FMT_GBRP9BE = 74,
    #[doc = "< planar GBR 4:4:4 27bpp, little-endian"]
    AV_PIX_FMT_GBRP9LE = 75,
    #[doc = "< planar GBR 4:4:4 30bpp, big-endian"]
    AV_PIX_FMT_GBRP10BE = 76,
    #[doc = "< planar GBR 4:4:4 30bpp, little-endian"]
    AV_PIX_FMT_GBRP10LE = 77,
    #[doc = "< planar GBR 4:4:4 48bpp, big-endian"]
    AV_PIX_FMT_GBRP16BE = 78,
    #[doc = "< planar GBR 4:4:4 48bpp, little-endian"]
    AV_PIX_FMT_GBRP16LE = 79,
    #[doc = "< planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)"]
    AV_PIX_FMT_YUVA422P = 80,
    #[doc = "< planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)"]
    AV_PIX_FMT_YUVA444P = 81,
    #[doc = "< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), big-endian"]
    AV_PIX_FMT_YUVA420P9BE = 82,
    #[doc = "< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), little-endian"]
    AV_PIX_FMT_YUVA420P9LE = 83,
    #[doc = "< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), big-endian"]
    AV_PIX_FMT_YUVA422P9BE = 84,
    #[doc = "< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), little-endian"]
    AV_PIX_FMT_YUVA422P9LE = 85,
    #[doc = "< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), big-endian"]
    AV_PIX_FMT_YUVA444P9BE = 86,
    #[doc = "< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), little-endian"]
    AV_PIX_FMT_YUVA444P9LE = 87,
    #[doc = "< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)"]
    AV_PIX_FMT_YUVA420P10BE = 88,
    #[doc = "< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)"]
    AV_PIX_FMT_YUVA420P10LE = 89,
    #[doc = "< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)"]
    AV_PIX_FMT_YUVA422P10BE = 90,
    #[doc = "< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)"]
    AV_PIX_FMT_YUVA422P10LE = 91,
    #[doc = "< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)"]
    AV_PIX_FMT_YUVA444P10BE = 92,
    #[doc = "< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)"]
    AV_PIX_FMT_YUVA444P10LE = 93,
    #[doc = "< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)"]
    AV_PIX_FMT_YUVA420P16BE = 94,
    #[doc = "< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)"]
    AV_PIX_FMT_YUVA420P16LE = 95,
    #[doc = "< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)"]
    AV_PIX_FMT_YUVA422P16BE = 96,
    #[doc = "< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)"]
    AV_PIX_FMT_YUVA422P16LE = 97,
    #[doc = "< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)"]
    AV_PIX_FMT_YUVA444P16BE = 98,
    #[doc = "< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)"]
    AV_PIX_FMT_YUVA444P16LE = 99,
    #[doc = "< HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface"]
    AV_PIX_FMT_VDPAU = 100,
    #[doc = "< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0"]
    AV_PIX_FMT_XYZ12LE = 101,
    #[doc = "< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0"]
    AV_PIX_FMT_XYZ12BE = 102,
    #[doc = "< interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
    AV_PIX_FMT_NV16 = 103,
    #[doc = "< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    AV_PIX_FMT_NV20LE = 104,
    #[doc = "< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    AV_PIX_FMT_NV20BE = 105,
    #[doc = "< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian"]
    AV_PIX_FMT_RGBA64BE = 106,
    #[doc = "< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian"]
    AV_PIX_FMT_RGBA64LE = 107,
    #[doc = "< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian"]
    AV_PIX_FMT_BGRA64BE = 108,
    #[doc = "< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian"]
    AV_PIX_FMT_BGRA64LE = 109,
    #[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb"]
    AV_PIX_FMT_YVYU422 = 110,
    #[doc = "< 16 bits gray, 16 bits alpha (big-endian)"]
    AV_PIX_FMT_YA16BE = 111,
    #[doc = "< 16 bits gray, 16 bits alpha (little-endian)"]
    AV_PIX_FMT_YA16LE = 112,
    #[doc = "< planar GBRA 4:4:4:4 32bpp"]
    AV_PIX_FMT_GBRAP = 113,
    #[doc = "< planar GBRA 4:4:4:4 64bpp, big-endian"]
    AV_PIX_FMT_GBRAP16BE = 114,
    #[doc = "< planar GBRA 4:4:4:4 64bpp, little-endian"]
    AV_PIX_FMT_GBRAP16LE = 115,
    #[doc = "  HW acceleration through QSV, data[3] contains a pointer to the\n  mfxFrameSurface1 structure."]
    AV_PIX_FMT_QSV = 116,
    #[doc = " HW acceleration though MMAL, data[3] contains a pointer to the\n MMAL_BUFFER_HEADER_T structure."]
    AV_PIX_FMT_MMAL = 117,
    #[doc = "< HW decoding through Direct3D11 via old API, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer"]
    AV_PIX_FMT_D3D11VA_VLD = 118,
    #[doc = " HW acceleration through CUDA. data[i] contain CUdeviceptr pointers\n exactly as for system memory frames."]
    AV_PIX_FMT_CUDA = 119,
    #[doc = "< packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined"]
    AV_PIX_FMT_0RGB = 120,
    #[doc = "< packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined"]
    AV_PIX_FMT_RGB0 = 121,
    #[doc = "< packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined"]
    AV_PIX_FMT_0BGR = 122,
    #[doc = "< packed BGR 8:8:8, 32bpp, BGRXBGRX...   X=unused/undefined"]
    AV_PIX_FMT_BGR0 = 123,
    #[doc = "< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
    AV_PIX_FMT_YUV420P12BE = 124,
    #[doc = "< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
    AV_PIX_FMT_YUV420P12LE = 125,
    #[doc = "< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
    AV_PIX_FMT_YUV420P14BE = 126,
    #[doc = "< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
    AV_PIX_FMT_YUV420P14LE = 127,
    #[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV422P12BE = 128,
    #[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV422P12LE = 129,
    #[doc = "< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV422P14BE = 130,
    #[doc = "< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV422P14LE = 131,
    #[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV444P12BE = 132,
    #[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV444P12LE = 133,
    #[doc = "< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV444P14BE = 134,
    #[doc = "< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV444P14LE = 135,
    #[doc = "< planar GBR 4:4:4 36bpp, big-endian"]
    AV_PIX_FMT_GBRP12BE = 136,
    #[doc = "< planar GBR 4:4:4 36bpp, little-endian"]
    AV_PIX_FMT_GBRP12LE = 137,
    #[doc = "< planar GBR 4:4:4 42bpp, big-endian"]
    AV_PIX_FMT_GBRP14BE = 138,
    #[doc = "< planar GBR 4:4:4 42bpp, little-endian"]
    AV_PIX_FMT_GBRP14LE = 139,
    #[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range"]
    AV_PIX_FMT_YUVJ411P = 140,
    #[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples"]
    AV_PIX_FMT_BAYER_BGGR8 = 141,
    #[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples"]
    AV_PIX_FMT_BAYER_RGGB8 = 142,
    #[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples"]
    AV_PIX_FMT_BAYER_GBRG8 = 143,
    #[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples"]
    AV_PIX_FMT_BAYER_GRBG8 = 144,
    #[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian"]
    AV_PIX_FMT_BAYER_BGGR16LE = 145,
    #[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian"]
    AV_PIX_FMT_BAYER_BGGR16BE = 146,
    #[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian"]
    AV_PIX_FMT_BAYER_RGGB16LE = 147,
    #[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian"]
    AV_PIX_FMT_BAYER_RGGB16BE = 148,
    #[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian"]
    AV_PIX_FMT_BAYER_GBRG16LE = 149,
    #[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian"]
    AV_PIX_FMT_BAYER_GBRG16BE = 150,
    #[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian"]
    AV_PIX_FMT_BAYER_GRBG16LE = 151,
    #[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian"]
    AV_PIX_FMT_BAYER_GRBG16BE = 152,
    #[doc = "< XVideo Motion Acceleration via common packet passing"]
    AV_PIX_FMT_XVMC = 153,
    #[doc = "< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian"]
    AV_PIX_FMT_YUV440P10LE = 154,
    #[doc = "< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian"]
    AV_PIX_FMT_YUV440P10BE = 155,
    #[doc = "< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian"]
    AV_PIX_FMT_YUV440P12LE = 156,
    #[doc = "< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian"]
    AV_PIX_FMT_YUV440P12BE = 157,
    #[doc = "< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), little-endian"]
    AV_PIX_FMT_AYUV64LE = 158,
    #[doc = "< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), big-endian"]
    AV_PIX_FMT_AYUV64BE = 159,
    #[doc = "< hardware decoding through Videotoolbox"]
    AV_PIX_FMT_VIDEOTOOLBOX = 160,
    #[doc = "< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, little-endian"]
    AV_PIX_FMT_P010LE = 161,
    #[doc = "< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, big-endian"]
    AV_PIX_FMT_P010BE = 162,
    #[doc = "< planar GBR 4:4:4:4 48bpp, big-endian"]
    AV_PIX_FMT_GBRAP12BE = 163,
    #[doc = "< planar GBR 4:4:4:4 48bpp, little-endian"]
    AV_PIX_FMT_GBRAP12LE = 164,
    #[doc = "< planar GBR 4:4:4:4 40bpp, big-endian"]
    AV_PIX_FMT_GBRAP10BE = 165,
    #[doc = "< planar GBR 4:4:4:4 40bpp, little-endian"]
    AV_PIX_FMT_GBRAP10LE = 166,
    #[doc = "< hardware decoding through MediaCodec"]
    AV_PIX_FMT_MEDIACODEC = 167,
    #[doc = "<        Y        , 12bpp, big-endian"]
    AV_PIX_FMT_GRAY12BE = 168,
    #[doc = "<        Y        , 12bpp, little-endian"]
    AV_PIX_FMT_GRAY12LE = 169,
    #[doc = "<        Y        , 10bpp, big-endian"]
    AV_PIX_FMT_GRAY10BE = 170,
    #[doc = "<        Y        , 10bpp, little-endian"]
    AV_PIX_FMT_GRAY10LE = 171,
    #[doc = "< like NV12, with 16bpp per component, little-endian"]
    AV_PIX_FMT_P016LE = 172,
    #[doc = "< like NV12, with 16bpp per component, big-endian"]
    AV_PIX_FMT_P016BE = 173,
    #[doc = " Hardware surfaces for Direct3D11.\n\n This is preferred over the legacy AV_PIX_FMT_D3D11VA_VLD. The new D3D11\n hwaccel API and filtering support AV_PIX_FMT_D3D11 only.\n\n data[0] contains a ID3D11Texture2D pointer, and data[1] contains the\n texture array index of the frame as intptr_t if the ID3D11Texture2D is\n an array texture (or always 0 if it's a normal texture)."]
    AV_PIX_FMT_D3D11 = 174,
    #[doc = "<        Y        , 9bpp, big-endian"]
    AV_PIX_FMT_GRAY9BE = 175,
    #[doc = "<        Y        , 9bpp, little-endian"]
    AV_PIX_FMT_GRAY9LE = 176,
    #[doc = "< IEEE-754 single precision planar GBR 4:4:4,     96bpp, big-endian"]
    AV_PIX_FMT_GBRPF32BE = 177,
    #[doc = "< IEEE-754 single precision planar GBR 4:4:4,     96bpp, little-endian"]
    AV_PIX_FMT_GBRPF32LE = 178,
    #[doc = "< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, big-endian"]
    AV_PIX_FMT_GBRAPF32BE = 179,
    #[doc = "< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, little-endian"]
    AV_PIX_FMT_GBRAPF32LE = 180,
    #[doc = " DRM-managed buffers exposed through PRIME buffer sharing.\n\n data[0] points to an AVDRMFrameDescriptor."]
    AV_PIX_FMT_DRM_PRIME = 181,
    #[doc = " Hardware surfaces for OpenCL.\n\n data[i] contain 2D image objects (typed in C as cl_mem, used\n in OpenCL as image2d_t) for each plane of the surface."]
    AV_PIX_FMT_OPENCL = 182,
    #[doc = "<        Y        , 14bpp, big-endian"]
    AV_PIX_FMT_GRAY14BE = 183,
    #[doc = "<        Y        , 14bpp, little-endian"]
    AV_PIX_FMT_GRAY14LE = 184,
    #[doc = "< IEEE-754 single precision Y, 32bpp, big-endian"]
    AV_PIX_FMT_GRAYF32BE = 185,
    #[doc = "< IEEE-754 single precision Y, 32bpp, little-endian"]
    AV_PIX_FMT_GRAYF32LE = 186,
    #[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, big-endian"]
    AV_PIX_FMT_YUVA422P12BE = 187,
    #[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, little-endian"]
    AV_PIX_FMT_YUVA422P12LE = 188,
    #[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, big-endian"]
    AV_PIX_FMT_YUVA444P12BE = 189,
    #[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, little-endian"]
    AV_PIX_FMT_YUVA444P12LE = 190,
    #[doc = "< planar YUV 4:4:4, 24bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
    AV_PIX_FMT_NV24 = 191,
    #[doc = "< as above, but U and V bytes are swapped"]
    AV_PIX_FMT_NV42 = 192,
    #[doc = " Vulkan hardware images.\n\n data[0] points to an AVVkFrame"]
    AV_PIX_FMT_VULKAN = 193,
    #[doc = "< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, big-endian"]
    AV_PIX_FMT_Y210BE = 194,
    #[doc = "< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, little-endian"]
    AV_PIX_FMT_Y210LE = 195,
    #[doc = "< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), little-endian, X=unused/undefined"]
    AV_PIX_FMT_X2RGB10LE = 196,
    #[doc = "< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), big-endian, X=unused/undefined"]
    AV_PIX_FMT_X2RGB10BE = 197,
    #[doc = "< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions"]
    AV_PIX_FMT_NB = 198,
}
impl AVColorPrimaries {
    pub const AVCOL_PRI_SMPTEST428_1: AVColorPrimaries = AVColorPrimaries::AVCOL_PRI_SMPTE428;
}
impl AVColorPrimaries {
    pub const AVCOL_PRI_JEDEC_P22: AVColorPrimaries = AVColorPrimaries::AVCOL_PRI_EBU3213;
}
#[repr(u32)]
#[doc = " Chromaticity coordinates of the source primaries.\n These values match the ones defined by ISO/IEC 23001-8_2013  7.1."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVColorPrimaries {
    AVCOL_PRI_RESERVED0 = 0,
    #[doc = "< also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B"]
    AVCOL_PRI_BT709 = 1,
    AVCOL_PRI_UNSPECIFIED = 2,
    AVCOL_PRI_RESERVED = 3,
    #[doc = "< also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)"]
    AVCOL_PRI_BT470M = 4,
    #[doc = "< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM"]
    AVCOL_PRI_BT470BG = 5,
    #[doc = "< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC"]
    AVCOL_PRI_SMPTE170M = 6,
    #[doc = "< functionally identical to above"]
    AVCOL_PRI_SMPTE240M = 7,
    #[doc = "< colour filters using Illuminant C"]
    AVCOL_PRI_FILM = 8,
    #[doc = "< ITU-R BT2020"]
    AVCOL_PRI_BT2020 = 9,
    #[doc = "< SMPTE ST 428-1 (CIE 1931 XYZ)"]
    AVCOL_PRI_SMPTE428 = 10,
    #[doc = "< SMPTE ST 431-2 (2011) / DCI P3"]
    AVCOL_PRI_SMPTE431 = 11,
    #[doc = "< SMPTE ST 432-1 (2010) / P3 D65 / Display P3"]
    AVCOL_PRI_SMPTE432 = 12,
    #[doc = "< EBU Tech. 3213-E / JEDEC P22 phosphors"]
    AVCOL_PRI_EBU3213 = 22,
    #[doc = "< Not part of ABI"]
    AVCOL_PRI_NB = 23,
}
impl AVColorTransferCharacteristic {
    pub const AVCOL_TRC_SMPTEST2084: AVColorTransferCharacteristic =
        AVColorTransferCharacteristic::AVCOL_TRC_SMPTE2084;
}
impl AVColorTransferCharacteristic {
    pub const AVCOL_TRC_SMPTEST428_1: AVColorTransferCharacteristic =
        AVColorTransferCharacteristic::AVCOL_TRC_SMPTE428;
}
#[repr(u32)]
#[doc = " Color Transfer Characteristic.\n These values match the ones defined by ISO/IEC 23001-8_2013  7.2."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVColorTransferCharacteristic {
    AVCOL_TRC_RESERVED0 = 0,
    #[doc = "< also ITU-R BT1361"]
    AVCOL_TRC_BT709 = 1,
    AVCOL_TRC_UNSPECIFIED = 2,
    AVCOL_TRC_RESERVED = 3,
    #[doc = "< also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM"]
    AVCOL_TRC_GAMMA22 = 4,
    #[doc = "< also ITU-R BT470BG"]
    AVCOL_TRC_GAMMA28 = 5,
    #[doc = "< also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC"]
    AVCOL_TRC_SMPTE170M = 6,
    AVCOL_TRC_SMPTE240M = 7,
    #[doc = "< \"Linear transfer characteristics\""]
    AVCOL_TRC_LINEAR = 8,
    #[doc = "< \"Logarithmic transfer characteristic (100:1 range)\""]
    AVCOL_TRC_LOG = 9,
    #[doc = "< \"Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)\""]
    AVCOL_TRC_LOG_SQRT = 10,
    #[doc = "< IEC 61966-2-4"]
    AVCOL_TRC_IEC61966_2_4 = 11,
    #[doc = "< ITU-R BT1361 Extended Colour Gamut"]
    AVCOL_TRC_BT1361_ECG = 12,
    #[doc = "< IEC 61966-2-1 (sRGB or sYCC)"]
    AVCOL_TRC_IEC61966_2_1 = 13,
    #[doc = "< ITU-R BT2020 for 10-bit system"]
    AVCOL_TRC_BT2020_10 = 14,
    #[doc = "< ITU-R BT2020 for 12-bit system"]
    AVCOL_TRC_BT2020_12 = 15,
    #[doc = "< SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems"]
    AVCOL_TRC_SMPTE2084 = 16,
    #[doc = "< SMPTE ST 428-1"]
    AVCOL_TRC_SMPTE428 = 17,
    #[doc = "< ARIB STD-B67, known as \"Hybrid log-gamma\""]
    AVCOL_TRC_ARIB_STD_B67 = 18,
    #[doc = "< Not part of ABI"]
    AVCOL_TRC_NB = 19,
}
impl AVColorSpace {
    pub const AVCOL_SPC_YCOCG: AVColorSpace = AVColorSpace::AVCOL_SPC_YCGCO;
}
#[repr(u32)]
#[doc = " YUV colorspace type.\n These values match the ones defined by ISO/IEC 23001-8_2013  7.3."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVColorSpace {
    #[doc = "< order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB)"]
    AVCOL_SPC_RGB = 0,
    #[doc = "< also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B"]
    AVCOL_SPC_BT709 = 1,
    AVCOL_SPC_UNSPECIFIED = 2,
    AVCOL_SPC_RESERVED = 3,
    #[doc = "< FCC Title 47 Code of Federal Regulations 73.682 (a)(20)"]
    AVCOL_SPC_FCC = 4,
    #[doc = "< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601"]
    AVCOL_SPC_BT470BG = 5,
    #[doc = "< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC"]
    AVCOL_SPC_SMPTE170M = 6,
    #[doc = "< functionally identical to above"]
    AVCOL_SPC_SMPTE240M = 7,
    #[doc = "< Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16"]
    AVCOL_SPC_YCGCO = 8,
    #[doc = "< ITU-R BT2020 non-constant luminance system"]
    AVCOL_SPC_BT2020_NCL = 9,
    #[doc = "< ITU-R BT2020 constant luminance system"]
    AVCOL_SPC_BT2020_CL = 10,
    #[doc = "< SMPTE 2085, Y'D'zD'x"]
    AVCOL_SPC_SMPTE2085 = 11,
    #[doc = "< Chromaticity-derived non-constant luminance system"]
    AVCOL_SPC_CHROMA_DERIVED_NCL = 12,
    #[doc = "< Chromaticity-derived constant luminance system"]
    AVCOL_SPC_CHROMA_DERIVED_CL = 13,
    #[doc = "< ITU-R BT.2100-0, ICtCp"]
    AVCOL_SPC_ICTCP = 14,
    #[doc = "< Not part of ABI"]
    AVCOL_SPC_NB = 15,
}
#[repr(u32)]
#[doc = " Visual content value range.\n\n These values are based on definitions that can be found in multiple\n specifications, such as ITU-T BT.709 (3.4 - Quantization of RGB, luminance\n and colour-difference signals), ITU-T BT.2020 (Table 5 - Digital\n Representation) as well as ITU-T BT.2100 (Table 9 - Digital 10- and 12-bit\n integer representation). At the time of writing, the BT.2100 one is\n recommended, as it also defines the full range representation.\n\n Common definitions:\n   - For RGB and luminance planes such as Y in YCbCr and I in ICtCp,\n     'E' is the original value in range of 0.0 to 1.0.\n   - For chrominance planes such as Cb,Cr and Ct,Cp, 'E' is the original\n     value in range of -0.5 to 0.5.\n   - 'n' is the output bit depth.\n   - For additional definitions such as rounding and clipping to valid n\n     bit unsigned integer range, please refer to BT.2100 (Table 9)."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVColorRange {
    AVCOL_RANGE_UNSPECIFIED = 0,
    #[doc = " Narrow or limited range content.\n\n - For luminance planes:\n\n       (219 * E + 16) * 2^(n-8)\n\n   F.ex. the range of 16-235 for 8 bits\n\n - For chrominance planes:\n\n       (224 * E + 128) * 2^(n-8)\n\n   F.ex. the range of 16-240 for 8 bits"]
    AVCOL_RANGE_MPEG = 1,
    #[doc = " Full range content.\n\n - For RGB and luminance planes:\n\n       (2^n - 1) * E\n\n   F.ex. the range of 0-255 for 8 bits\n\n - For chrominance planes:\n\n       (2^n - 1) * E + 2^(n - 1)\n\n   F.ex. the range of 1-255 for 8 bits"]
    AVCOL_RANGE_JPEG = 2,
    #[doc = "< Not part of ABI"]
    AVCOL_RANGE_NB = 3,
}
#[repr(u32)]
#[doc = " Location of chroma samples.\n\n Illustration showing the location of the first (top left) chroma sample of the\n image, the left shows only luma, the right\n shows the location of the chroma sample, the 2 could be imagined to overlay\n each other but are drawn separately due to limitations of ASCII\n\n                1st 2nd       1st 2nd horizontal luma sample positions\n                 v   v         v   v\n                 ______        ______\n1st luma line > |X   X ...    |3 4 X ...     X are luma samples,\n                |             |1 2           1-6 are possible chroma positions\n2nd luma line > |X   X ...    |5 6 X ...     0 is undefined/unknown position"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVChromaLocation {
    AVCHROMA_LOC_UNSPECIFIED = 0,
    #[doc = "< MPEG-2/4 4:2:0, H.264 default for 4:2:0"]
    AVCHROMA_LOC_LEFT = 1,
    #[doc = "< MPEG-1 4:2:0, JPEG 4:2:0, H.263 4:2:0"]
    AVCHROMA_LOC_CENTER = 2,
    #[doc = "< ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2"]
    AVCHROMA_LOC_TOPLEFT = 3,
    AVCHROMA_LOC_TOP = 4,
    AVCHROMA_LOC_BOTTOMLEFT = 5,
    AVCHROMA_LOC_BOTTOM = 6,
    #[doc = "< Not part of ABI"]
    AVCHROMA_LOC_NB = 7,
}
extern "C" {
    #[doc = " Compute the length of an integer list.\n\n @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)\n @param term    list terminator (usually 0 or -1)\n @param list    pointer to the list\n @return  length of the list, in elements, not counting the terminator"]
    pub fn av_int_list_length_for_size(
        elsize: libc::c_uint,
        list: *const libc::c_void,
        term: u64,
    ) -> libc::c_uint;
}
extern "C" {
    #[doc = " Open a file using a UTF-8 filename.\n The API of this function matches POSIX fopen(), errors are returned through\n errno."]
    pub fn av_fopen_utf8(path: *const libc::c_char, mode: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    #[doc = " Return the fractional representation of the internal time base."]
    pub fn av_get_time_base_q() -> AVRational;
}
extern "C" {
    #[doc = " Fill the provided buffer with a string containing a FourCC (four-character\n code) representation.\n\n @param buf    a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE\n @param fourcc the fourcc to represent\n @return the buffer in input"]
    pub fn av_fourcc_make_string(buf: *mut libc::c_char, fourcc: u32) -> *mut libc::c_char;
}
#[repr(i32)]
#[doc = " Audio sample formats\n\n - The data described by the sample format is always in native-endian order.\n   Sample values can be expressed by native C types, hence the lack of a signed\n   24-bit sample format even though it is a common raw audio data format.\n\n - The floating-point formats are based on full volume being in the range\n   [-1.0, 1.0]. Any values outside this range are beyond full volume level.\n\n - The data layout as used in av_samples_fill_arrays() and elsewhere in FFmpeg\n   (such as AVFrame in libavcodec) is as follows:\n\n @par\n For planar sample formats, each audio channel is in a separate data plane,\n and linesize is the buffer size, in bytes, for a single plane. All data\n planes must be the same size. For packed sample formats, only the first data\n plane is used, and samples for each channel are interleaved. In this case,\n linesize is the buffer size, in bytes, for the 1 plane.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVSampleFormat {
    AV_SAMPLE_FMT_NONE = -1,
    #[doc = "< unsigned 8 bits"]
    AV_SAMPLE_FMT_U8 = 0,
    #[doc = "< signed 16 bits"]
    AV_SAMPLE_FMT_S16 = 1,
    #[doc = "< signed 32 bits"]
    AV_SAMPLE_FMT_S32 = 2,
    #[doc = "< float"]
    AV_SAMPLE_FMT_FLT = 3,
    #[doc = "< double"]
    AV_SAMPLE_FMT_DBL = 4,
    #[doc = "< unsigned 8 bits, planar"]
    AV_SAMPLE_FMT_U8P = 5,
    #[doc = "< signed 16 bits, planar"]
    AV_SAMPLE_FMT_S16P = 6,
    #[doc = "< signed 32 bits, planar"]
    AV_SAMPLE_FMT_S32P = 7,
    #[doc = "< float, planar"]
    AV_SAMPLE_FMT_FLTP = 8,
    #[doc = "< double, planar"]
    AV_SAMPLE_FMT_DBLP = 9,
    #[doc = "< signed 64 bits"]
    AV_SAMPLE_FMT_S64 = 10,
    #[doc = "< signed 64 bits, planar"]
    AV_SAMPLE_FMT_S64P = 11,
    #[doc = "< Number of sample formats. DO NOT USE if linking dynamically"]
    AV_SAMPLE_FMT_NB = 12,
}
extern "C" {
    #[doc = " Return the name of sample_fmt, or NULL if sample_fmt is not\n recognized."]
    pub fn av_get_sample_fmt_name(sample_fmt: AVSampleFormat) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE\n on error."]
    pub fn av_get_sample_fmt(name: *const libc::c_char) -> AVSampleFormat;
}
extern "C" {
    #[doc = " Return the planar<->packed alternative form of the given sample format, or\n AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the\n requested planar/packed format, the format returned is the same as the\n input."]
    pub fn av_get_alt_sample_fmt(sample_fmt: AVSampleFormat, planar: libc::c_int)
        -> AVSampleFormat;
}
extern "C" {
    #[doc = " Get the packed alternative form of the given sample format.\n\n If the passed sample_fmt is already in packed format, the format returned is\n the same as the input.\n\n @return  the packed alternative form of the given sample format or\nAV_SAMPLE_FMT_NONE on error."]
    pub fn av_get_packed_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    #[doc = " Get the planar alternative form of the given sample format.\n\n If the passed sample_fmt is already in planar format, the format returned is\n the same as the input.\n\n @return  the planar alternative form of the given sample format or\nAV_SAMPLE_FMT_NONE on error."]
    pub fn av_get_planar_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    #[doc = " Generate a string corresponding to the sample format with\n sample_fmt, or a header if sample_fmt is negative.\n\n @param buf the buffer where to write the string\n @param buf_size the size of buf\n @param sample_fmt the number of the sample format to print the\n corresponding info string, or a negative value to print the\n corresponding header.\n @return the pointer to the filled buffer or NULL if sample_fmt is\n unknown or in case of other errors"]
    pub fn av_get_sample_fmt_string(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        sample_fmt: AVSampleFormat,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Return number of bytes per sample.\n\n @param sample_fmt the sample format\n @return number of bytes per sample or zero if unknown for the given\n sample format"]
    pub fn av_get_bytes_per_sample(sample_fmt: AVSampleFormat) -> libc::c_int;
}
extern "C" {
    #[doc = " Check if the sample format is planar.\n\n @param sample_fmt the sample format to inspect\n @return 1 if the sample format is planar, 0 if it is interleaved"]
    pub fn av_sample_fmt_is_planar(sample_fmt: AVSampleFormat) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the required buffer size for the given audio parameters.\n\n @param[out] linesize calculated linesize, may be NULL\n @param nb_channels   the number of channels\n @param nb_samples    the number of samples in a single channel\n @param sample_fmt    the sample format\n @param align         buffer size alignment (0 = default, 1 = no alignment)\n @return              required buffer size, or negative error code on failure"]
    pub fn av_samples_get_buffer_size(
        linesize: *mut libc::c_int,
        nb_channels: libc::c_int,
        nb_samples: libc::c_int,
        sample_fmt: AVSampleFormat,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill plane data pointers and linesize for samples with sample\n format sample_fmt.\n\n The audio_data array is filled with the pointers to the samples data planes:\n for planar, set the start point of each channel's data within the buffer,\n for packed, set the start point of the entire buffer only.\n\n The value pointed to by linesize is set to the aligned size of each\n channel's data buffer for planar layout, or to the aligned size of the\n buffer for all channels for packed layout.\n\n The buffer in buf must be big enough to contain all the samples\n (use av_samples_get_buffer_size() to compute its minimum size),\n otherwise the audio_data pointers will point to invalid data.\n\n @see enum AVSampleFormat\n The documentation for AVSampleFormat describes the data layout.\n\n @param[out] audio_data  array to be filled with the pointer for each channel\n @param[out] linesize    calculated linesize, may be NULL\n @param buf              the pointer to a buffer containing the samples\n @param nb_channels      the number of channels\n @param nb_samples       the number of samples in a single channel\n @param sample_fmt       the sample format\n @param align            buffer size alignment (0 = default, 1 = no alignment)\n @return                 >=0 on success or a negative error code on failure\n @todo return minimum size in bytes required for the buffer in case\n of success at the next bump"]
    pub fn av_samples_fill_arrays(
        audio_data: *mut *mut u8,
        linesize: *mut libc::c_int,
        buf: *const u8,
        nb_channels: libc::c_int,
        nb_samples: libc::c_int,
        sample_fmt: AVSampleFormat,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate a samples buffer for nb_samples samples, and fill data pointers and\n linesize accordingly.\n The allocated samples buffer can be freed by using av_freep(&audio_data[0])\n Allocated data will be initialized to silence.\n\n @see enum AVSampleFormat\n The documentation for AVSampleFormat describes the data layout.\n\n @param[out] audio_data  array to be filled with the pointer for each channel\n @param[out] linesize    aligned size for audio buffer(s), may be NULL\n @param nb_channels      number of audio channels\n @param nb_samples       number of samples per channel\n @param align            buffer size alignment (0 = default, 1 = no alignment)\n @return                 >=0 on success or a negative error code on failure\n @todo return the size of the allocated buffer in case of success at the next bump\n @see av_samples_fill_arrays()\n @see av_samples_alloc_array_and_samples()"]
    pub fn av_samples_alloc(
        audio_data: *mut *mut u8,
        linesize: *mut libc::c_int,
        nb_channels: libc::c_int,
        nb_samples: libc::c_int,
        sample_fmt: AVSampleFormat,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate a data pointers array, samples buffer for nb_samples\n samples, and fill data pointers and linesize accordingly.\n\n This is the same as av_samples_alloc(), but also allocates the data\n pointers array.\n\n @see av_samples_alloc()"]
    pub fn av_samples_alloc_array_and_samples(
        audio_data: *mut *mut *mut u8,
        linesize: *mut libc::c_int,
        nb_channels: libc::c_int,
        nb_samples: libc::c_int,
        sample_fmt: AVSampleFormat,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy samples from src to dst.\n\n @param dst destination array of pointers to data planes\n @param src source array of pointers to data planes\n @param dst_offset offset in samples at which the data will be written to dst\n @param src_offset offset in samples at which the data will be read from src\n @param nb_samples number of samples to be copied\n @param nb_channels number of audio channels\n @param sample_fmt audio sample format"]
    pub fn av_samples_copy(
        dst: *mut *mut u8,
        src: *const *mut u8,
        dst_offset: libc::c_int,
        src_offset: libc::c_int,
        nb_samples: libc::c_int,
        nb_channels: libc::c_int,
        sample_fmt: AVSampleFormat,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill an audio buffer with silence.\n\n @param audio_data  array of pointers to data planes\n @param offset      offset in samples at which to start filling\n @param nb_samples  number of samples to fill\n @param nb_channels number of audio channels\n @param sample_fmt  audio sample format"]
    pub fn av_samples_set_silence(
        audio_data: *mut *mut u8,
        offset: libc::c_int,
        nb_samples: libc::c_int,
        nb_channels: libc::c_int,
        sample_fmt: AVSampleFormat,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBuffer {
    _unused: [u8; 0],
}
#[doc = " A reference to a data buffer.\n\n The size of this struct is not a part of the public ABI and it is not meant\n to be allocated directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVBufferRef {
    pub buffer: *mut AVBuffer,
    #[doc = " The data buffer. It is considered writable if and only if\n this is the only reference to the buffer, in which case\n av_buffer_is_writable() returns 1."]
    pub data: *mut u8,
    pub size: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVBufferRef"][::std::mem::size_of::<AVBufferRef>() - 24usize];
    ["Alignment of AVBufferRef"][::std::mem::align_of::<AVBufferRef>() - 8usize];
    ["Offset of field: AVBufferRef::buffer"][::std::mem::offset_of!(AVBufferRef, buffer) - 0usize];
    ["Offset of field: AVBufferRef::data"][::std::mem::offset_of!(AVBufferRef, data) - 8usize];
    ["Offset of field: AVBufferRef::size"][::std::mem::offset_of!(AVBufferRef, size) - 16usize];
};
extern "C" {
    pub fn av_buffer_alloc(size: libc::c_int) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_allocz(size: libc::c_int) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_create(
        data: *mut u8,
        size: libc::c_int,
        free: ::std::option::Option<unsafe extern "C" fn(opaque: *mut libc::c_void, data: *mut u8)>,
        opaque: *mut libc::c_void,
        flags: libc::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Default free callback, which calls av_free() on the buffer data.\n This function is meant to be passed to av_buffer_create(), not called\n directly."]
    pub fn av_buffer_default_free(opaque: *mut libc::c_void, data: *mut u8);
}
extern "C" {
    #[doc = " Create a new reference to an AVBuffer.\n\n @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on\n failure."]
    pub fn av_buffer_ref(buf: *mut AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Free a given reference and automatically free the buffer if there are no more\n references to it.\n\n @param buf the reference to be freed. The pointer is set to NULL on return."]
    pub fn av_buffer_unref(buf: *mut *mut AVBufferRef);
}
extern "C" {
    #[doc = " @return 1 if the caller may write to the data referred to by buf (which is\n true if and only if buf is the only reference to the underlying AVBuffer).\n Return 0 otherwise.\n A positive answer is valid until av_buffer_ref() is called on buf."]
    pub fn av_buffer_is_writable(buf: *const AVBufferRef) -> libc::c_int;
}
extern "C" {
    #[doc = " @return the opaque parameter set by av_buffer_create."]
    pub fn av_buffer_get_opaque(buf: *const AVBufferRef) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_buffer_get_ref_count(buf: *const AVBufferRef) -> libc::c_int;
}
extern "C" {
    #[doc = " Create a writable reference from a given buffer reference, avoiding data copy\n if possible.\n\n @param buf buffer reference to make writable. On success, buf is either left\n            untouched, or it is unreferenced and a new writable AVBufferRef is\n            written in its place. On failure, buf is left untouched.\n @return 0 on success, a negative AVERROR on failure."]
    pub fn av_buffer_make_writable(buf: *mut *mut AVBufferRef) -> libc::c_int;
}
extern "C" {
    pub fn av_buffer_realloc(buf: *mut *mut AVBufferRef, size: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Ensure dst refers to the same data as src.\n\n When *dst is already equivalent to src, do nothing. Otherwise unreference dst\n and replace it with a new reference to src.\n\n @param dst Pointer to either a valid buffer reference or NULL. On success,\n            this will point to a buffer reference equivalent to src. On\n            failure, dst will be left untouched.\n @param src A buffer reference to replace dst with. May be NULL, then this\n            function is equivalent to av_buffer_unref(dst).\n @return 0 on success\n         AVERROR(ENOMEM) on memory allocation failure."]
    pub fn av_buffer_replace(dst: *mut *mut AVBufferRef, src: *mut AVBufferRef) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferPool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn av_buffer_pool_init(
        size: libc::c_int,
        alloc: ::std::option::Option<unsafe extern "C" fn(size: libc::c_int) -> *mut AVBufferRef>,
    ) -> *mut AVBufferPool;
}
extern "C" {
    pub fn av_buffer_pool_init2(
        size: libc::c_int,
        opaque: *mut libc::c_void,
        alloc: ::std::option::Option<
            unsafe extern "C" fn(opaque: *mut libc::c_void, size: libc::c_int) -> *mut AVBufferRef,
        >,
        pool_free: ::std::option::Option<unsafe extern "C" fn(opaque: *mut libc::c_void)>,
    ) -> *mut AVBufferPool;
}
extern "C" {
    #[doc = " Mark the pool as being available for freeing. It will actually be freed only\n once all the allocated buffers associated with the pool are released. Thus it\n is safe to call this function while some of the allocated buffers are still\n in use.\n\n @param pool pointer to the pool to be freed. It will be set to NULL."]
    pub fn av_buffer_pool_uninit(pool: *mut *mut AVBufferPool);
}
extern "C" {
    #[doc = " Allocate a new AVBuffer, reusing an old buffer from the pool when available.\n This function may be called simultaneously from multiple threads.\n\n @return a reference to the new buffer on success, NULL on error."]
    pub fn av_buffer_pool_get(pool: *mut AVBufferPool) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Query the original opaque parameter of an allocated buffer in the pool.\n\n @param ref a buffer reference to a buffer returned by av_buffer_pool_get.\n @return the opaque parameter set by the buffer allocator function of the\n         buffer pool.\n\n @note the opaque parameter of ref is used by the buffer pool implementation,\n therefore you have to use this function to access the original opaque\n parameter of an allocated buffer."]
    pub fn av_buffer_pool_buffer_get_opaque(ref_: *mut AVBufferRef) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Return the flags which specify extensions supported by the CPU.\n The returned value is affected by av_force_cpu_flags() if that was used\n before. So av_get_cpu_flags() can easily be used in an application to\n detect the enabled cpu flags."]
    pub fn av_get_cpu_flags() -> libc::c_int;
}
extern "C" {
    #[doc = " Disables cpu detection and forces the specified flags.\n -1 is a special case that disables forcing of specific flags."]
    pub fn av_force_cpu_flags(flags: libc::c_int);
}
extern "C" {
    #[doc = " Set a mask on flags returned by av_get_cpu_flags().\n This function is mainly useful for testing.\n Please use av_force_cpu_flags() and av_get_cpu_flags() instead which are more flexible"]
    pub fn av_set_cpu_flags_mask(mask: libc::c_int);
}
extern "C" {
    #[doc = " Parse CPU flags from a string.\n\n The returned flags contain the specified flags as well as related unspecified flags.\n\n This function exists only for compatibility with libav.\n Please use av_parse_cpu_caps() when possible.\n @return a combination of AV_CPU_* flags, negative on error."]
    pub fn av_parse_cpu_flags(s: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Parse CPU caps from a string and update the given AV_CPU_* flags based on that.\n\n @return negative on error."]
    pub fn av_parse_cpu_caps(flags: *mut libc::c_uint, s: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " @return the number of logical CPU cores present."]
    pub fn av_cpu_count() -> libc::c_int;
}
extern "C" {
    #[doc = " Get the maximum data alignment that may be required by FFmpeg.\n\n Note that this is affected by the build configuration and the CPU flags mask,\n so e.g. if the CPU supports AVX, but libavutil has been built with\n --disable-avx or the AV_CPU_FLAG_AVX flag has been disabled through\n  av_set_cpu_flags_mask(), then this function will behave as if AVX is not\n  present."]
    pub fn av_cpu_max_align() -> usize;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVMatrixEncoding {
    AV_MATRIX_ENCODING_NONE = 0,
    AV_MATRIX_ENCODING_DOLBY = 1,
    AV_MATRIX_ENCODING_DPLII = 2,
    AV_MATRIX_ENCODING_DPLIIX = 3,
    AV_MATRIX_ENCODING_DPLIIZ = 4,
    AV_MATRIX_ENCODING_DOLBYEX = 5,
    AV_MATRIX_ENCODING_DOLBYHEADPHONE = 6,
    AV_MATRIX_ENCODING_NB = 7,
}
extern "C" {
    #[doc = " Return a channel layout id that matches name, or 0 if no match is found.\n\n name can be one or several of the following notations,\n separated by '+' or '|':\n - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,\n   5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);\n - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,\n   SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);\n - a number of channels, in decimal, followed by 'c', yielding\n   the default channel layout for that number of channels (@see\n   av_get_default_channel_layout);\n - a channel layout mask, in hexadecimal starting with \"0x\" (see the\n   AV_CH_* macros).\n\n Example: \"stereo+FC\" = \"2c+FC\" = \"2c+1c\" = \"0x7\""]
    pub fn av_get_channel_layout(name: *const libc::c_char) -> u64;
}
extern "C" {
    #[doc = " Return a channel layout and the number of channels based on the specified name.\n\n This function is similar to (@see av_get_channel_layout), but can also parse\n unknown channel layout specifications.\n\n @param[in]  name             channel layout specification string\n @param[out] channel_layout   parsed channel layout (0 if unknown)\n @param[out] nb_channels      number of channels\n\n @return 0 on success, AVERROR(EINVAL) if the parsing fails."]
    pub fn av_get_extended_channel_layout(
        name: *const libc::c_char,
        channel_layout: *mut u64,
        nb_channels: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return a description of a channel layout.\n If nb_channels is <= 0, it is guessed from the channel_layout.\n\n @param buf put here the string containing the channel layout\n @param buf_size size in bytes of the buffer"]
    pub fn av_get_channel_layout_string(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        nb_channels: libc::c_int,
        channel_layout: u64,
    );
}
extern "C" {
    #[doc = " Append a description of a channel layout to a bprint buffer."]
    pub fn av_bprint_channel_layout(
        bp: *mut AVBPrint,
        nb_channels: libc::c_int,
        channel_layout: u64,
    );
}
extern "C" {
    #[doc = " Return the number of channels in the channel layout."]
    pub fn av_get_channel_layout_nb_channels(channel_layout: u64) -> libc::c_int;
}
extern "C" {
    #[doc = " Return default channel layout for a given number of channels."]
    pub fn av_get_default_channel_layout(nb_channels: libc::c_int) -> i64;
}
extern "C" {
    #[doc = " Get the index of a channel in channel_layout.\n\n @param channel a channel layout describing exactly one channel which must be\n                present in channel_layout.\n\n @return index of channel in channel_layout on success, a negative AVERROR\n         on error."]
    pub fn av_get_channel_layout_channel_index(channel_layout: u64, channel: u64) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the channel with the given index in channel_layout."]
    pub fn av_channel_layout_extract_channel(channel_layout: u64, index: libc::c_int) -> u64;
}
extern "C" {
    #[doc = " Get the name of a given channel.\n\n @return channel name on success, NULL on error."]
    pub fn av_get_channel_name(channel: u64) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the description of a given channel.\n\n @param channel  a channel layout with a single channel\n @return  channel description on success, NULL on error"]
    pub fn av_get_channel_description(channel: u64) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the value and name of a standard channel layout.\n\n @param[in]  index   index in an internal list, starting at 0\n @param[out] layout  channel layout mask\n @param[out] name    name of the layout\n @return  0  if the layout exists,\n          <0 if index is beyond the limits"]
    pub fn av_get_standard_channel_layout(
        index: libc::c_uint,
        layout: *mut u64,
        name: *mut *const libc::c_char,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDictionaryEntry {
    pub key: *mut libc::c_char,
    pub value: *mut libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVDictionaryEntry"][::std::mem::size_of::<AVDictionaryEntry>() - 16usize];
    ["Alignment of AVDictionaryEntry"][::std::mem::align_of::<AVDictionaryEntry>() - 8usize];
    ["Offset of field: AVDictionaryEntry::key"]
        [::std::mem::offset_of!(AVDictionaryEntry, key) - 0usize];
    ["Offset of field: AVDictionaryEntry::value"]
        [::std::mem::offset_of!(AVDictionaryEntry, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionary {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get a dictionary entry with matching key.\n\n The returned entry key or value must not be changed, or it will\n cause undefined behavior.\n\n To iterate through all the dictionary entries, you can set the matching key\n to the null string \"\" and set the AV_DICT_IGNORE_SUFFIX flag.\n\n @param prev Set to the previous matching element to find the next.\n             If set to NULL the first matching element is returned.\n @param key matching key\n @param flags a collection of AV_DICT_* flags controlling how the entry is retrieved\n @return found entry or NULL in case no matching entry was found in the dictionary"]
    pub fn av_dict_get(
        m: *const AVDictionary,
        key: *const libc::c_char,
        prev: *const AVDictionaryEntry,
        flags: libc::c_int,
    ) -> *mut AVDictionaryEntry;
}
extern "C" {
    #[doc = " Get number of entries in dictionary.\n\n @param m dictionary\n @return  number of entries in dictionary"]
    pub fn av_dict_count(m: *const AVDictionary) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the given entry in *pm, overwriting an existing entry.\n\n Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,\n these arguments will be freed on error.\n\n Warning: Adding a new entry to a dictionary invalidates all existing entries\n previously returned with av_dict_get.\n\n @param pm pointer to a pointer to a dictionary struct. If *pm is NULL\n a dictionary struct is allocated and put in *pm.\n @param key entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)\n @param value entry value to add to *pm (will be av_strduped or added as a new key depending on flags).\n        Passing a NULL value will cause an existing entry to be deleted.\n @return >= 0 on success otherwise an error code <0"]
    pub fn av_dict_set(
        pm: *mut *mut AVDictionary,
        key: *const libc::c_char,
        value: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Convenience wrapper for av_dict_set that converts the value to a string\n and stores it.\n\n Note: If AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error."]
    pub fn av_dict_set_int(
        pm: *mut *mut AVDictionary,
        key: *const libc::c_char,
        value: i64,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Parse the key/value pairs list and add the parsed entries to a dictionary.\n\n In case of failure, all the successfully set entries are stored in\n *pm. You may need to manually free the created dictionary.\n\n @param key_val_sep  a 0-terminated list of characters used to separate\n                     key from value\n @param pairs_sep    a 0-terminated list of characters used to separate\n                     two pairs from each other\n @param flags        flags to use when adding to dictionary.\n                     AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL\n                     are ignored since the key/value tokens will always\n                     be duplicated.\n @return             0 on success, negative AVERROR code on failure"]
    pub fn av_dict_parse_string(
        pm: *mut *mut AVDictionary,
        str_: *const libc::c_char,
        key_val_sep: *const libc::c_char,
        pairs_sep: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy entries from one AVDictionary struct into another.\n @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,\n            this function will allocate a struct for you and put it in *dst\n @param src pointer to source AVDictionary struct\n @param flags flags to use when setting entries in *dst\n @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag\n @return 0 on success, negative AVERROR code on failure. If dst was allocated\n           by this function, callers should free the associated memory."]
    pub fn av_dict_copy(
        dst: *mut *mut AVDictionary,
        src: *const AVDictionary,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Free all the memory allocated for an AVDictionary struct\n and all keys and values."]
    pub fn av_dict_free(m: *mut *mut AVDictionary);
}
extern "C" {
    #[doc = " Get dictionary entries as a string.\n\n Create a string containing dictionary's entries.\n Such string may be passed back to av_dict_parse_string().\n @note String is escaped with backslashes ('\\').\n\n @param[in]  m             dictionary\n @param[out] buffer        Pointer to buffer that will be allocated with string containg entries.\n                           Buffer must be freed by the caller when is no longer needed.\n @param[in]  key_val_sep   character used to separate key from value\n @param[in]  pairs_sep     character used to separate two pairs from each other\n @return                   >= 0 on success, negative on error\n @warning Separators cannot be neither '\\\\' nor '\\0'. They also cannot be the same."]
    pub fn av_dict_get_string(
        m: *const AVDictionary,
        buffer: *mut *mut libc::c_char,
        key_val_sep: libc::c_char,
        pairs_sep: libc::c_char,
    ) -> libc::c_int;
}
#[repr(u32)]
#[doc = " @defgroup lavu_frame AVFrame\n @ingroup lavu_data\n\n @{\n AVFrame is an abstraction for reference-counted raw multimedia data."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVFrameSideDataType {
    #[doc = " The data is the AVPanScan struct defined in libavcodec."]
    AV_FRAME_DATA_PANSCAN = 0,
    #[doc = " ATSC A53 Part 4 Closed Captions.\n A53 CC bitstream is stored as uint8_t in AVFrameSideData.data.\n The number of bytes of CC data is AVFrameSideData.size."]
    AV_FRAME_DATA_A53_CC = 1,
    #[doc = " Stereoscopic 3d metadata.\n The data is the AVStereo3D struct defined in libavutil/stereo3d.h."]
    AV_FRAME_DATA_STEREO3D = 2,
    #[doc = " The data is the AVMatrixEncoding enum defined in libavutil/channel_layout.h."]
    AV_FRAME_DATA_MATRIXENCODING = 3,
    #[doc = " Metadata relevant to a downmix procedure.\n The data is the AVDownmixInfo struct defined in libavutil/downmix_info.h."]
    AV_FRAME_DATA_DOWNMIX_INFO = 4,
    #[doc = " ReplayGain information in the form of the AVReplayGain struct."]
    AV_FRAME_DATA_REPLAYGAIN = 5,
    #[doc = " This side data contains a 3x3 transformation matrix describing an affine\n transformation that needs to be applied to the frame for correct\n presentation.\n\n See libavutil/display.h for a detailed description of the data."]
    AV_FRAME_DATA_DISPLAYMATRIX = 6,
    #[doc = " Active Format Description data consisting of a single byte as specified\n in ETSI TS 101 154 using AVActiveFormatDescription enum."]
    AV_FRAME_DATA_AFD = 7,
    #[doc = " Motion vectors exported by some codecs (on demand through the export_mvs\n flag set in the libavcodec AVCodecContext flags2 option).\n The data is the AVMotionVector struct defined in\n libavutil/motion_vector.h."]
    AV_FRAME_DATA_MOTION_VECTORS = 8,
    #[doc = " Recommmends skipping the specified number of samples. This is exported\n only if the \"skip_manual\" AVOption is set in libavcodec.\n This has the same format as AV_PKT_DATA_SKIP_SAMPLES.\n @code\n u32le number of samples to skip from start of this packet\n u32le number of samples to skip from end of this packet\n u8    reason for start skip\n u8    reason for end   skip (0=padding silence, 1=convergence)\n @endcode"]
    AV_FRAME_DATA_SKIP_SAMPLES = 9,
    #[doc = " This side data must be associated with an audio frame and corresponds to\n enum AVAudioServiceType defined in avcodec.h."]
    AV_FRAME_DATA_AUDIO_SERVICE_TYPE = 10,
    #[doc = " Mastering display metadata associated with a video frame. The payload is\n an AVMasteringDisplayMetadata type and contains information about the\n mastering display color volume."]
    AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = 11,
    #[doc = " The GOP timecode in 25 bit timecode format. Data format is 64-bit integer.\n This is set on the first frame of a GOP that has a temporal reference of 0."]
    AV_FRAME_DATA_GOP_TIMECODE = 12,
    #[doc = " The data represents the AVSphericalMapping structure defined in\n libavutil/spherical.h."]
    AV_FRAME_DATA_SPHERICAL = 13,
    #[doc = " Content light level (based on CTA-861.3). This payload contains data in\n the form of the AVContentLightMetadata struct."]
    AV_FRAME_DATA_CONTENT_LIGHT_LEVEL = 14,
    #[doc = " The data contains an ICC profile as an opaque octet buffer following the\n format described by ISO 15076-1 with an optional name defined in the\n metadata key entry \"name\"."]
    AV_FRAME_DATA_ICC_PROFILE = 15,
    #[doc = " Implementation-specific description of the format of AV_FRAME_QP_TABLE_DATA.\n The contents of this side data are undocumented and internal; use\n av_frame_set_qp_table() and av_frame_get_qp_table() to access this in a\n meaningful way instead."]
    AV_FRAME_DATA_QP_TABLE_PROPERTIES = 16,
    #[doc = " Raw QP table data. Its format is described by\n AV_FRAME_DATA_QP_TABLE_PROPERTIES. Use av_frame_set_qp_table() and\n av_frame_get_qp_table() to access this instead."]
    AV_FRAME_DATA_QP_TABLE_DATA = 17,
    #[doc = " Timecode which conforms to SMPTE ST 12-1. The data is an array of 4 uint32_t\n where the first uint32_t describes how many (1-3) of the other timecodes are used.\n The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()\n function in libavutil/timecode.h."]
    AV_FRAME_DATA_S12M_TIMECODE = 18,
    #[doc = " HDR dynamic metadata associated with a video frame. The payload is\n an AVDynamicHDRPlus type and contains information for color\n volume transform - application 4 of SMPTE 2094-40:2016 standard."]
    AV_FRAME_DATA_DYNAMIC_HDR_PLUS = 19,
    #[doc = " Regions Of Interest, the data is an array of AVRegionOfInterest type, the number of\n array element is implied by AVFrameSideData.size / AVRegionOfInterest.self_size."]
    AV_FRAME_DATA_REGIONS_OF_INTEREST = 20,
    #[doc = " Encoding parameters for a video frame, as described by AVVideoEncParams."]
    AV_FRAME_DATA_VIDEO_ENC_PARAMS = 21,
    #[doc = " User data unregistered metadata associated with a video frame.\n This is the H.26[45] UDU SEI message, and shouldn't be used for any other purpose\n The data is stored as uint8_t in AVFrameSideData.data which is 16 bytes of\n uuid_iso_iec_11578 followed by AVFrameSideData.size - 16 bytes of user_data_payload_byte."]
    AV_FRAME_DATA_SEI_UNREGISTERED = 22,
    #[doc = " Film grain parameters for a frame, described by AVFilmGrainParams.\n Must be present for every frame which should have film grain applied."]
    AV_FRAME_DATA_FILM_GRAIN_PARAMS = 23,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVActiveFormatDescription {
    AV_AFD_SAME = 8,
    AV_AFD_4_3 = 9,
    AV_AFD_16_9 = 10,
    AV_AFD_14_9 = 11,
    AV_AFD_4_3_SP_14_9 = 13,
    AV_AFD_16_9_SP_14_9 = 14,
    AV_AFD_SP_4_3 = 15,
}
#[doc = " Structure to hold side data for an AVFrame.\n\n sizeof(AVFrameSideData) is not a part of the public ABI, so new fields may be added\n to the end with a minor bump."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFrameSideData {
    pub type_: AVFrameSideDataType,
    pub data: *mut u8,
    pub size: libc::c_int,
    pub metadata: *mut AVDictionary,
    pub buf: *mut AVBufferRef,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVFrameSideData"][::std::mem::size_of::<AVFrameSideData>() - 40usize];
    ["Alignment of AVFrameSideData"][::std::mem::align_of::<AVFrameSideData>() - 8usize];
    ["Offset of field: AVFrameSideData::type_"]
        [::std::mem::offset_of!(AVFrameSideData, type_) - 0usize];
    ["Offset of field: AVFrameSideData::data"]
        [::std::mem::offset_of!(AVFrameSideData, data) - 8usize];
    ["Offset of field: AVFrameSideData::size"]
        [::std::mem::offset_of!(AVFrameSideData, size) - 16usize];
    ["Offset of field: AVFrameSideData::metadata"]
        [::std::mem::offset_of!(AVFrameSideData, metadata) - 24usize];
    ["Offset of field: AVFrameSideData::buf"]
        [::std::mem::offset_of!(AVFrameSideData, buf) - 32usize];
};
#[doc = " Structure describing a single Region Of Interest.\n\n When multiple regions are defined in a single side-data block, they\n should be ordered from most to least important - some encoders are only\n capable of supporting a limited number of distinct regions, so will have\n to truncate the list.\n\n When overlapping regions are defined, the first region containing a given\n area of the frame applies."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVRegionOfInterest {
    #[doc = " Must be set to the size of this data structure (that is,\n sizeof(AVRegionOfInterest))."]
    pub self_size: u32,
    #[doc = " Distance in pixels from the top edge of the frame to the top and\n bottom edges and from the left edge of the frame to the left and\n right edges of the rectangle defining this region of interest.\n\n The constraints on a region are encoder dependent, so the region\n actually affected may be slightly larger for alignment or other\n reasons."]
    pub top: libc::c_int,
    pub bottom: libc::c_int,
    pub left: libc::c_int,
    pub right: libc::c_int,
    #[doc = " Quantisation offset.\n\n Must be in the range -1 to +1.  A value of zero indicates no quality\n change.  A negative value asks for better quality (less quantisation),\n while a positive value asks for worse quality (greater quantisation).\n\n The range is calibrated so that the extreme values indicate the\n largest possible offset - if the rest of the frame is encoded with the\n worst possible quality, an offset of -1 indicates that this region\n should be encoded with the best possible quality anyway.  Intermediate\n values are then interpolated in some codec-dependent way.\n\n For example, in 10-bit H.264 the quantisation parameter varies between\n -12 and 51.  A typical qoffset value of -1/10 therefore indicates that\n this region should be encoded with a QP around one-tenth of the full\n range better than the rest of the frame.  So, if most of the frame\n were to be encoded with a QP of around 30, this region would get a QP\n of around 24 (an offset of approximately -1/10 * (51 - -12) = -6.3).\n An extreme value of -1 would indicate that this region should be\n encoded with the best possible quality regardless of the treatment of\n the rest of the frame - that is, should be encoded at a QP of -12."]
    pub qoffset: AVRational,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVRegionOfInterest"][::std::mem::size_of::<AVRegionOfInterest>() - 28usize];
    ["Alignment of AVRegionOfInterest"][::std::mem::align_of::<AVRegionOfInterest>() - 4usize];
    ["Offset of field: AVRegionOfInterest::self_size"]
        [::std::mem::offset_of!(AVRegionOfInterest, self_size) - 0usize];
    ["Offset of field: AVRegionOfInterest::top"]
        [::std::mem::offset_of!(AVRegionOfInterest, top) - 4usize];
    ["Offset of field: AVRegionOfInterest::bottom"]
        [::std::mem::offset_of!(AVRegionOfInterest, bottom) - 8usize];
    ["Offset of field: AVRegionOfInterest::left"]
        [::std::mem::offset_of!(AVRegionOfInterest, left) - 12usize];
    ["Offset of field: AVRegionOfInterest::right"]
        [::std::mem::offset_of!(AVRegionOfInterest, right) - 16usize];
    ["Offset of field: AVRegionOfInterest::qoffset"]
        [::std::mem::offset_of!(AVRegionOfInterest, qoffset) - 20usize];
};
#[doc = " This structure describes decoded (raw) audio or video data.\n\n AVFrame must be allocated using av_frame_alloc(). Note that this only\n allocates the AVFrame itself, the buffers for the data must be managed\n through other means (see below).\n AVFrame must be freed with av_frame_free().\n\n AVFrame is typically allocated once and then reused multiple times to hold\n different data (e.g. a single AVFrame to hold frames received from a\n decoder). In such a case, av_frame_unref() will free any references held by\n the frame and reset it to its original clean state before it\n is reused again.\n\n The data described by an AVFrame is usually reference counted through the\n AVBuffer API. The underlying buffer references are stored in AVFrame.buf /\n AVFrame.extended_buf. An AVFrame is considered to be reference counted if at\n least one reference is set, i.e. if AVFrame.buf[0] != NULL. In such a case,\n every single data plane must be contained in one of the buffers in\n AVFrame.buf or AVFrame.extended_buf.\n There may be a single buffer for all the data, or one separate buffer for\n each plane, or anything in between.\n\n sizeof(AVFrame) is not a part of the public ABI, so new fields may be added\n to the end with a minor bump.\n\n Fields can be accessed through AVOptions, the name string used, matches the\n C structure field name for fields accessible through AVOptions. The AVClass\n for AVFrame can be obtained from avcodec_get_frame_class()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFrame {
    #[doc = " pointer to the picture/channel planes.\n This might be different from the first allocated byte\n\n Some decoders access areas outside 0,0 - width,height, please\n see avcodec_align_dimensions2(). Some filters and swscale can read\n up to 16 bytes beyond the planes, if these filters are to be used,\n then 16 extra bytes must be allocated.\n\n NOTE: Except for hwaccel formats, pointers not needed by the format\n MUST be set to NULL."]
    pub data: [*mut u8; 8usize],
    #[doc = " For video, size in bytes of each picture line.\n For audio, size in bytes of each plane.\n\n For audio, only linesize[0] may be set. For planar audio, each channel\n plane must be the same size.\n\n For video the linesizes should be multiples of the CPUs alignment\n preference, this is 16 or 32 for modern desktop CPUs.\n Some code requires such alignment other code can be slower without\n correct alignment, for yet other it makes no difference.\n\n @note The linesize may be larger than the size of usable data -- there\n may be extra padding present for performance reasons."]
    pub linesize: [libc::c_int; 8usize],
    #[doc = " pointers to the data planes/channels.\n\n For video, this should simply point to data[].\n\n For planar audio, each channel has a separate data pointer, and\n linesize[0] contains the size of each channel buffer.\n For packed audio, there is just one data pointer, and linesize[0]\n contains the total size of the buffer for all channels.\n\n Note: Both data and extended_data should always be set in a valid frame,\n but for planar audio with more channels that can fit in data,\n extended_data must be used in order to access all channels."]
    pub extended_data: *mut *mut u8,
    #[doc = " @name Video dimensions\n Video frames only. The coded dimensions (in pixels) of the video frame,\n i.e. the size of the rectangle that contains some well-defined values.\n\n @note The part of the frame intended for display/presentation is further\n restricted by the @ref cropping \"Cropping rectangle\".\n @{"]
    pub width: libc::c_int,
    #[doc = " @name Video dimensions\n Video frames only. The coded dimensions (in pixels) of the video frame,\n i.e. the size of the rectangle that contains some well-defined values.\n\n @note The part of the frame intended for display/presentation is further\n restricted by the @ref cropping \"Cropping rectangle\".\n @{"]
    pub height: libc::c_int,
    #[doc = " number of audio samples (per channel) described by this frame"]
    pub nb_samples: libc::c_int,
    #[doc = " format of the frame, -1 if unknown or unset\n Values correspond to enum AVPixelFormat for video frames,\n enum AVSampleFormat for audio)"]
    pub format: libc::c_int,
    #[doc = " 1 -> keyframe, 0-> not"]
    pub key_frame: libc::c_int,
    #[doc = " Picture type of the frame."]
    pub pict_type: AVPictureType,
    #[doc = " Sample aspect ratio for the video frame, 0/1 if unknown/unspecified."]
    pub sample_aspect_ratio: AVRational,
    #[doc = " Presentation timestamp in time_base units (time when frame should be shown to user)."]
    pub pts: i64,
    #[doc = " PTS copied from the AVPacket that was decoded to produce this frame.\n @deprecated use the pts field instead"]
    pub pkt_pts: i64,
    #[doc = " DTS copied from the AVPacket that triggered returning this frame. (if frame threading isn't used)\n This is also the Presentation time of this AVFrame calculated from\n only AVPacket.dts values without pts values."]
    pub pkt_dts: i64,
    #[doc = " picture number in bitstream order"]
    pub coded_picture_number: libc::c_int,
    #[doc = " picture number in display order"]
    pub display_picture_number: libc::c_int,
    #[doc = " quality (between 1 (good) and FF_LAMBDA_MAX (bad))"]
    pub quality: libc::c_int,
    #[doc = " for some private data of the user"]
    pub opaque: *mut libc::c_void,
    #[doc = " @deprecated unused"]
    pub error: [u64; 8usize],
    #[doc = " When decoding, this signals how much the picture must be delayed.\n extra_delay = repeat_pict / (2*fps)"]
    pub repeat_pict: libc::c_int,
    #[doc = " The content of the picture is interlaced."]
    pub interlaced_frame: libc::c_int,
    #[doc = " If the content is interlaced, is top field displayed first."]
    pub top_field_first: libc::c_int,
    #[doc = " Tell user application that palette has changed from previous frame."]
    pub palette_has_changed: libc::c_int,
    #[doc = " reordered opaque 64 bits (generally an integer or a double precision float\n PTS but can be anything).\n The user sets AVCodecContext.reordered_opaque to represent the input at\n that time,\n the decoder reorders values as needed and sets AVFrame.reordered_opaque\n to exactly one of the values provided by the user through AVCodecContext.reordered_opaque"]
    pub reordered_opaque: i64,
    #[doc = " Sample rate of the audio data."]
    pub sample_rate: libc::c_int,
    #[doc = " Channel layout of the audio data."]
    pub channel_layout: u64,
    #[doc = " AVBuffer references backing the data for this frame. If all elements of\n this array are NULL, then this frame is not reference counted. This array\n must be filled contiguously -- if buf[i] is non-NULL then buf[j] must\n also be non-NULL for all j < i.\n\n There may be at most one AVBuffer per data plane, so for video this array\n always contains all the references. For planar audio with more than\n AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in\n this array. Then the extra AVBufferRef pointers are stored in the\n extended_buf array."]
    pub buf: [*mut AVBufferRef; 8usize],
    #[doc = " For planar audio which requires more than AV_NUM_DATA_POINTERS\n AVBufferRef pointers, this array will hold all the references which\n cannot fit into AVFrame.buf.\n\n Note that this is different from AVFrame.extended_data, which always\n contains all the pointers. This array only contains the extra pointers,\n which cannot fit into AVFrame.buf.\n\n This array is always allocated using av_malloc() by whoever constructs\n the frame. It is freed in av_frame_unref()."]
    pub extended_buf: *mut *mut AVBufferRef,
    #[doc = " Number of elements in extended_buf."]
    pub nb_extended_buf: libc::c_int,
    pub side_data: *mut *mut AVFrameSideData,
    pub nb_side_data: libc::c_int,
    #[doc = " Frame flags, a combination of @ref lavu_frame_flags"]
    pub flags: libc::c_int,
    #[doc = " MPEG vs JPEG YUV range.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    #[doc = " YUV colorspace type.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub colorspace: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    #[doc = " frame timestamp estimated using various heuristics, in stream time base\n - encoding: unused\n - decoding: set by libavcodec, read by user."]
    pub best_effort_timestamp: i64,
    #[doc = " reordered pos from the last AVPacket that has been input into the decoder\n - encoding: unused\n - decoding: Read by user."]
    pub pkt_pos: i64,
    #[doc = " duration of the corresponding packet, expressed in\n AVStream->time_base units, 0 if unknown.\n - encoding: unused\n - decoding: Read by user."]
    pub pkt_duration: i64,
    #[doc = " metadata.\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub metadata: *mut AVDictionary,
    #[doc = " decode error flags of the frame, set to a combination of\n FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there\n were errors during the decoding.\n - encoding: unused\n - decoding: set by libavcodec, read by user."]
    pub decode_error_flags: libc::c_int,
    #[doc = " number of audio channels, only used for audio.\n - encoding: unused\n - decoding: Read by user."]
    pub channels: libc::c_int,
    #[doc = " size of the corresponding packet containing the compressed\n frame.\n It is set to a negative value if unknown.\n - encoding: unused\n - decoding: set by libavcodec, read by user."]
    pub pkt_size: libc::c_int,
    #[doc = " QP table"]
    pub qscale_table: *mut i8,
    #[doc = " QP store stride"]
    pub qstride: libc::c_int,
    pub qscale_type: libc::c_int,
    pub qp_table_buf: *mut AVBufferRef,
    #[doc = " For hwaccel-format frames, this should be a reference to the\n AVHWFramesContext describing the frame."]
    pub hw_frames_ctx: *mut AVBufferRef,
    #[doc = " AVBufferRef for free use by the API user. FFmpeg will never check the\n contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when\n the frame is unreferenced. av_frame_copy_props() calls create a new\n reference with av_buffer_ref() for the target frame's opaque_ref field.\n\n This is unrelated to the opaque field, although it serves a similar\n purpose."]
    pub opaque_ref: *mut AVBufferRef,
    #[doc = " @anchor cropping\n @name Cropping\n Video frames only. The number of pixels to discard from the the\n top/bottom/left/right border of the frame to obtain the sub-rectangle of\n the frame intended for presentation.\n @{"]
    pub crop_top: usize,
    pub crop_bottom: usize,
    pub crop_left: usize,
    pub crop_right: usize,
    #[doc = " AVBufferRef for internal use by a single libav* library.\n Must not be used to transfer data between libraries.\n Has to be NULL when ownership of the frame leaves the respective library.\n\n Code outside the FFmpeg libs should never check or change the contents of the buffer ref.\n\n FFmpeg calls av_buffer_unref() on it when the frame is unreferenced.\n av_frame_copy_props() calls create a new reference with av_buffer_ref()\n for the target frame's private_ref field."]
    pub private_ref: *mut AVBufferRef,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVFrame"][::std::mem::size_of::<AVFrame>() - 536usize];
    ["Alignment of AVFrame"][::std::mem::align_of::<AVFrame>() - 8usize];
    ["Offset of field: AVFrame::data"][::std::mem::offset_of!(AVFrame, data) - 0usize];
    ["Offset of field: AVFrame::linesize"][::std::mem::offset_of!(AVFrame, linesize) - 64usize];
    ["Offset of field: AVFrame::extended_data"]
        [::std::mem::offset_of!(AVFrame, extended_data) - 96usize];
    ["Offset of field: AVFrame::width"][::std::mem::offset_of!(AVFrame, width) - 104usize];
    ["Offset of field: AVFrame::height"][::std::mem::offset_of!(AVFrame, height) - 108usize];
    ["Offset of field: AVFrame::nb_samples"]
        [::std::mem::offset_of!(AVFrame, nb_samples) - 112usize];
    ["Offset of field: AVFrame::format"][::std::mem::offset_of!(AVFrame, format) - 116usize];
    ["Offset of field: AVFrame::key_frame"][::std::mem::offset_of!(AVFrame, key_frame) - 120usize];
    ["Offset of field: AVFrame::pict_type"][::std::mem::offset_of!(AVFrame, pict_type) - 124usize];
    ["Offset of field: AVFrame::sample_aspect_ratio"]
        [::std::mem::offset_of!(AVFrame, sample_aspect_ratio) - 128usize];
    ["Offset of field: AVFrame::pts"][::std::mem::offset_of!(AVFrame, pts) - 136usize];
    ["Offset of field: AVFrame::pkt_pts"][::std::mem::offset_of!(AVFrame, pkt_pts) - 144usize];
    ["Offset of field: AVFrame::pkt_dts"][::std::mem::offset_of!(AVFrame, pkt_dts) - 152usize];
    ["Offset of field: AVFrame::coded_picture_number"]
        [::std::mem::offset_of!(AVFrame, coded_picture_number) - 160usize];
    ["Offset of field: AVFrame::display_picture_number"]
        [::std::mem::offset_of!(AVFrame, display_picture_number) - 164usize];
    ["Offset of field: AVFrame::quality"][::std::mem::offset_of!(AVFrame, quality) - 168usize];
    ["Offset of field: AVFrame::opaque"][::std::mem::offset_of!(AVFrame, opaque) - 176usize];
    ["Offset of field: AVFrame::error"][::std::mem::offset_of!(AVFrame, error) - 184usize];
    ["Offset of field: AVFrame::repeat_pict"]
        [::std::mem::offset_of!(AVFrame, repeat_pict) - 248usize];
    ["Offset of field: AVFrame::interlaced_frame"]
        [::std::mem::offset_of!(AVFrame, interlaced_frame) - 252usize];
    ["Offset of field: AVFrame::top_field_first"]
        [::std::mem::offset_of!(AVFrame, top_field_first) - 256usize];
    ["Offset of field: AVFrame::palette_has_changed"]
        [::std::mem::offset_of!(AVFrame, palette_has_changed) - 260usize];
    ["Offset of field: AVFrame::reordered_opaque"]
        [::std::mem::offset_of!(AVFrame, reordered_opaque) - 264usize];
    ["Offset of field: AVFrame::sample_rate"]
        [::std::mem::offset_of!(AVFrame, sample_rate) - 272usize];
    ["Offset of field: AVFrame::channel_layout"]
        [::std::mem::offset_of!(AVFrame, channel_layout) - 280usize];
    ["Offset of field: AVFrame::buf"][::std::mem::offset_of!(AVFrame, buf) - 288usize];
    ["Offset of field: AVFrame::extended_buf"]
        [::std::mem::offset_of!(AVFrame, extended_buf) - 352usize];
    ["Offset of field: AVFrame::nb_extended_buf"]
        [::std::mem::offset_of!(AVFrame, nb_extended_buf) - 360usize];
    ["Offset of field: AVFrame::side_data"][::std::mem::offset_of!(AVFrame, side_data) - 368usize];
    ["Offset of field: AVFrame::nb_side_data"]
        [::std::mem::offset_of!(AVFrame, nb_side_data) - 376usize];
    ["Offset of field: AVFrame::flags"][::std::mem::offset_of!(AVFrame, flags) - 380usize];
    ["Offset of field: AVFrame::color_range"]
        [::std::mem::offset_of!(AVFrame, color_range) - 384usize];
    ["Offset of field: AVFrame::color_primaries"]
        [::std::mem::offset_of!(AVFrame, color_primaries) - 388usize];
    ["Offset of field: AVFrame::color_trc"][::std::mem::offset_of!(AVFrame, color_trc) - 392usize];
    ["Offset of field: AVFrame::colorspace"]
        [::std::mem::offset_of!(AVFrame, colorspace) - 396usize];
    ["Offset of field: AVFrame::chroma_location"]
        [::std::mem::offset_of!(AVFrame, chroma_location) - 400usize];
    ["Offset of field: AVFrame::best_effort_timestamp"]
        [::std::mem::offset_of!(AVFrame, best_effort_timestamp) - 408usize];
    ["Offset of field: AVFrame::pkt_pos"][::std::mem::offset_of!(AVFrame, pkt_pos) - 416usize];
    ["Offset of field: AVFrame::pkt_duration"]
        [::std::mem::offset_of!(AVFrame, pkt_duration) - 424usize];
    ["Offset of field: AVFrame::metadata"][::std::mem::offset_of!(AVFrame, metadata) - 432usize];
    ["Offset of field: AVFrame::decode_error_flags"]
        [::std::mem::offset_of!(AVFrame, decode_error_flags) - 440usize];
    ["Offset of field: AVFrame::channels"][::std::mem::offset_of!(AVFrame, channels) - 444usize];
    ["Offset of field: AVFrame::pkt_size"][::std::mem::offset_of!(AVFrame, pkt_size) - 448usize];
    ["Offset of field: AVFrame::qscale_table"]
        [::std::mem::offset_of!(AVFrame, qscale_table) - 456usize];
    ["Offset of field: AVFrame::qstride"][::std::mem::offset_of!(AVFrame, qstride) - 464usize];
    ["Offset of field: AVFrame::qscale_type"]
        [::std::mem::offset_of!(AVFrame, qscale_type) - 468usize];
    ["Offset of field: AVFrame::qp_table_buf"]
        [::std::mem::offset_of!(AVFrame, qp_table_buf) - 472usize];
    ["Offset of field: AVFrame::hw_frames_ctx"]
        [::std::mem::offset_of!(AVFrame, hw_frames_ctx) - 480usize];
    ["Offset of field: AVFrame::opaque_ref"]
        [::std::mem::offset_of!(AVFrame, opaque_ref) - 488usize];
    ["Offset of field: AVFrame::crop_top"][::std::mem::offset_of!(AVFrame, crop_top) - 496usize];
    ["Offset of field: AVFrame::crop_bottom"]
        [::std::mem::offset_of!(AVFrame, crop_bottom) - 504usize];
    ["Offset of field: AVFrame::crop_left"][::std::mem::offset_of!(AVFrame, crop_left) - 512usize];
    ["Offset of field: AVFrame::crop_right"]
        [::std::mem::offset_of!(AVFrame, crop_right) - 520usize];
    ["Offset of field: AVFrame::private_ref"]
        [::std::mem::offset_of!(AVFrame, private_ref) - 528usize];
};
extern "C" {
    #[doc = " Accessors for some AVFrame fields. These used to be provided for ABI\n compatibility, and do not need to be used anymore."]
    pub fn av_frame_get_best_effort_timestamp(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_best_effort_timestamp(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_pkt_duration(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_pkt_duration(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_pkt_pos(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_pkt_pos(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_channel_layout(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_channel_layout(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_channels(frame: *const AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_set_channels(frame: *mut AVFrame, val: libc::c_int);
}
extern "C" {
    pub fn av_frame_get_sample_rate(frame: *const AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_set_sample_rate(frame: *mut AVFrame, val: libc::c_int);
}
extern "C" {
    pub fn av_frame_get_metadata(frame: *const AVFrame) -> *mut AVDictionary;
}
extern "C" {
    pub fn av_frame_set_metadata(frame: *mut AVFrame, val: *mut AVDictionary);
}
extern "C" {
    pub fn av_frame_get_decode_error_flags(frame: *const AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_set_decode_error_flags(frame: *mut AVFrame, val: libc::c_int);
}
extern "C" {
    pub fn av_frame_get_pkt_size(frame: *const AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_set_pkt_size(frame: *mut AVFrame, val: libc::c_int);
}
extern "C" {
    pub fn av_frame_get_qp_table(
        f: *mut AVFrame,
        stride: *mut libc::c_int,
        type_: *mut libc::c_int,
    ) -> *mut i8;
}
extern "C" {
    pub fn av_frame_set_qp_table(
        f: *mut AVFrame,
        buf: *mut AVBufferRef,
        stride: libc::c_int,
        type_: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_get_colorspace(frame: *const AVFrame) -> AVColorSpace;
}
extern "C" {
    pub fn av_frame_set_colorspace(frame: *mut AVFrame, val: AVColorSpace);
}
extern "C" {
    pub fn av_frame_get_color_range(frame: *const AVFrame) -> AVColorRange;
}
extern "C" {
    pub fn av_frame_set_color_range(frame: *mut AVFrame, val: AVColorRange);
}
extern "C" {
    #[doc = " Get the name of a colorspace.\n @return a static string identifying the colorspace; can be NULL."]
    pub fn av_get_colorspace_name(val: AVColorSpace) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Allocate an AVFrame and set its fields to default values.  The resulting\n struct must be freed using av_frame_free().\n\n @return An AVFrame filled with default values or NULL on failure.\n\n @note this only allocates the AVFrame itself, not the data buffers. Those\n must be allocated through other means, e.g. with av_frame_get_buffer() or\n manually."]
    pub fn av_frame_alloc() -> *mut AVFrame;
}
extern "C" {
    #[doc = " Free the frame and any dynamically allocated objects in it,\n e.g. extended_data. If the frame is reference counted, it will be\n unreferenced first.\n\n @param frame frame to be freed. The pointer will be set to NULL."]
    pub fn av_frame_free(frame: *mut *mut AVFrame);
}
extern "C" {
    #[doc = " Set up a new reference to the data described by the source frame.\n\n Copy frame properties from src to dst and create a new reference for each\n AVBufferRef from src.\n\n If src is not reference counted, new buffers are allocated and the data is\n copied.\n\n @warning: dst MUST have been either unreferenced with av_frame_unref(dst),\n           or newly allocated with av_frame_alloc() before calling this\n           function, or undefined behavior will occur.\n\n @return 0 on success, a negative AVERROR on error"]
    pub fn av_frame_ref(dst: *mut AVFrame, src: *const AVFrame) -> libc::c_int;
}
extern "C" {
    #[doc = " Create a new frame that references the same data as src.\n\n This is a shortcut for av_frame_alloc()+av_frame_ref().\n\n @return newly created AVFrame on success, NULL on error."]
    pub fn av_frame_clone(src: *const AVFrame) -> *mut AVFrame;
}
extern "C" {
    #[doc = " Unreference all the buffers referenced by frame and reset the frame fields."]
    pub fn av_frame_unref(frame: *mut AVFrame);
}
extern "C" {
    #[doc = " Move everything contained in src to dst and reset src.\n\n @warning: dst is not unreferenced, but directly overwritten without reading\n           or deallocating its contents. Call av_frame_unref(dst) manually\n           before calling this function to ensure that no memory is leaked."]
    pub fn av_frame_move_ref(dst: *mut AVFrame, src: *mut AVFrame);
}
extern "C" {
    #[doc = " Allocate new buffer(s) for audio or video data.\n\n The following fields must be set on frame before calling this function:\n - format (pixel format for video, sample format for audio)\n - width and height for video\n - nb_samples and channel_layout for audio\n\n This function will fill AVFrame.data and AVFrame.buf arrays and, if\n necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf.\n For planar formats, one buffer will be allocated for each plane.\n\n @warning: if frame already has been allocated, calling this function will\n           leak memory. In addition, undefined behavior can occur in certain\n           cases.\n\n @param frame frame in which to store the new buffers.\n @param align Required buffer size alignment. If equal to 0, alignment will be\n              chosen automatically for the current CPU. It is highly\n              recommended to pass 0 here unless you know what you are doing.\n\n @return 0 on success, a negative AVERROR on error."]
    pub fn av_frame_get_buffer(frame: *mut AVFrame, align: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Check if the frame data is writable.\n\n @return A positive value if the frame data is writable (which is true if and\n only if each of the underlying buffers has only one reference, namely the one\n stored in this frame). Return 0 otherwise.\n\n If 1 is returned the answer is valid until av_buffer_ref() is called on any\n of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly).\n\n @see av_frame_make_writable(), av_buffer_is_writable()"]
    pub fn av_frame_is_writable(frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    #[doc = " Ensure that the frame data is writable, avoiding data copy if possible.\n\n Do nothing if the frame is writable, allocate new buffers and copy the data\n if it is not.\n\n @return 0 on success, a negative AVERROR on error.\n\n @see av_frame_is_writable(), av_buffer_is_writable(),\n av_buffer_make_writable()"]
    pub fn av_frame_make_writable(frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy the frame data from src to dst.\n\n This function does not allocate anything, dst must be already initialized and\n allocated with the same parameters as src.\n\n This function only copies the frame data (i.e. the contents of the data /\n extended data arrays), not any other properties.\n\n @return >= 0 on success, a negative AVERROR on error."]
    pub fn av_frame_copy(dst: *mut AVFrame, src: *const AVFrame) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy only \"metadata\" fields from src to dst.\n\n Metadata for the purpose of this function are those fields that do not affect\n the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample\n aspect ratio (for video), but not width/height or channel layout.\n Side data is also copied."]
    pub fn av_frame_copy_props(dst: *mut AVFrame, src: *const AVFrame) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the buffer reference a given data plane is stored in.\n\n @param plane index of the data plane of interest in frame->extended_data.\n\n @return the buffer reference that contains the plane or NULL if the input\n frame is not valid."]
    pub fn av_frame_get_plane_buffer(frame: *mut AVFrame, plane: libc::c_int) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Add a new side data to a frame.\n\n @param frame a frame to which the side data should be added\n @param type type of the added side data\n @param size size of the side data\n\n @return newly added side data on success, NULL on error"]
    pub fn av_frame_new_side_data(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        size: libc::c_int,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    #[doc = " Add a new side data to a frame from an existing AVBufferRef\n\n @param frame a frame to which the side data should be added\n @param type  the type of the added side data\n @param buf   an AVBufferRef to add as side data. The ownership of\n              the reference is transferred to the frame.\n\n @return newly added side data on success, NULL on error. On failure\n         the frame is unchanged and the AVBufferRef remains owned by\n         the caller."]
    pub fn av_frame_new_side_data_from_buf(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        buf: *mut AVBufferRef,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    #[doc = " @return a pointer to the side data of a given type on success, NULL if there\n is no side data with such type in this frame."]
    pub fn av_frame_get_side_data(
        frame: *const AVFrame,
        type_: AVFrameSideDataType,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    #[doc = " Remove and free all side data instances of the given type."]
    pub fn av_frame_remove_side_data(frame: *mut AVFrame, type_: AVFrameSideDataType);
}
pub const AV_FRAME_CROP_UNALIGNED: _bindgen_ty_2 = _bindgen_ty_2::AV_FRAME_CROP_UNALIGNED;
#[repr(u32)]
#[doc = " Flags for frame cropping."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    #[doc = " Apply the maximum possible cropping, even if it requires setting the\n AVFrame.data[] entries to unaligned pointers. Passing unaligned data\n to FFmpeg API is generally not allowed, and causes undefined behavior\n (such as crashes). You can pass unaligned data only to FFmpeg APIs that\n are explicitly documented to accept it. Use this flag only if you\n absolutely know what you are doing."]
    AV_FRAME_CROP_UNALIGNED = 1,
}
extern "C" {
    #[doc = " Crop the given video AVFrame according to its crop_left/crop_top/crop_right/\n crop_bottom fields. If cropping is successful, the function will adjust the\n data pointers and the width/height fields, and set the crop fields to 0.\n\n In all cases, the cropping boundaries will be rounded to the inherent\n alignment of the pixel format. In some cases, such as for opaque hwaccel\n formats, the left/top cropping is ignored. The crop fields are set to 0 even\n if the cropping was rounded or ignored.\n\n @param frame the frame which should be cropped\n @param flags Some combination of AV_FRAME_CROP_* flags, or 0.\n\n @return >= 0 on success, a negative AVERROR on error. If the cropping fields\n were invalid, AVERROR(ERANGE) is returned, and nothing is changed."]
    pub fn av_frame_apply_cropping(frame: *mut AVFrame, flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @return a string identifying the side data type"]
    pub fn av_frame_side_data_name(type_: AVFrameSideDataType) -> *const libc::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVHWDeviceType {
    AV_HWDEVICE_TYPE_NONE = 0,
    AV_HWDEVICE_TYPE_VDPAU = 1,
    AV_HWDEVICE_TYPE_CUDA = 2,
    AV_HWDEVICE_TYPE_VAAPI = 3,
    AV_HWDEVICE_TYPE_DXVA2 = 4,
    AV_HWDEVICE_TYPE_QSV = 5,
    AV_HWDEVICE_TYPE_VIDEOTOOLBOX = 6,
    AV_HWDEVICE_TYPE_D3D11VA = 7,
    AV_HWDEVICE_TYPE_DRM = 8,
    AV_HWDEVICE_TYPE_OPENCL = 9,
    AV_HWDEVICE_TYPE_MEDIACODEC = 10,
    AV_HWDEVICE_TYPE_VULKAN = 11,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWDeviceInternal {
    _unused: [u8; 0],
}
#[doc = " This struct aggregates all the (hardware/vendor-specific) \"high-level\" state,\n i.e. state that is not tied to a concrete processing configuration.\n E.g., in an API that supports hardware-accelerated encoding and decoding,\n this struct will (if possible) wrap the state that is common to both encoding\n and decoding and from which specific instances of encoders or decoders can be\n derived.\n\n This struct is reference-counted with the AVBuffer mechanism. The\n av_hwdevice_ctx_alloc() constructor yields a reference, whose data field\n points to the actual AVHWDeviceContext. Further objects derived from\n AVHWDeviceContext (such as AVHWFramesContext, describing a frame pool with\n specific properties) will hold an internal reference to it. After all the\n references are released, the AVHWDeviceContext itself will be freed,\n optionally invoking a user-specified callback for uninitializing the hardware\n state."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVHWDeviceContext {
    #[doc = " A class for logging. Set by av_hwdevice_ctx_alloc()."]
    pub av_class: *const AVClass,
    #[doc = " Private data used internally by libavutil. Must not be accessed in any\n way by the caller."]
    pub internal: *mut AVHWDeviceInternal,
    #[doc = " This field identifies the underlying API used for hardware access.\n\n This field is set when this struct is allocated and never changed\n afterwards."]
    pub type_: AVHWDeviceType,
    #[doc = " The format-specific data, allocated and freed by libavutil along with\n this context.\n\n Should be cast by the user to the format-specific context defined in the\n corresponding header (hwcontext_*.h) and filled as described in the\n documentation before calling av_hwdevice_ctx_init().\n\n After calling av_hwdevice_ctx_init() this struct should not be modified\n by the caller."]
    pub hwctx: *mut libc::c_void,
    #[doc = " This field may be set by the caller before calling av_hwdevice_ctx_init().\n\n If non-NULL, this callback will be called when the last reference to\n this context is unreferenced, immediately before it is freed.\n\n @note when other objects (e.g an AVHWFramesContext) are derived from this\n       struct, this callback will be invoked after all such child objects\n       are fully uninitialized and their respective destructors invoked."]
    pub free: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVHWDeviceContext)>,
    #[doc = " Arbitrary user data, to be used e.g. by the free() callback."]
    pub user_opaque: *mut libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVHWDeviceContext"][::std::mem::size_of::<AVHWDeviceContext>() - 48usize];
    ["Alignment of AVHWDeviceContext"][::std::mem::align_of::<AVHWDeviceContext>() - 8usize];
    ["Offset of field: AVHWDeviceContext::av_class"]
        [::std::mem::offset_of!(AVHWDeviceContext, av_class) - 0usize];
    ["Offset of field: AVHWDeviceContext::internal"]
        [::std::mem::offset_of!(AVHWDeviceContext, internal) - 8usize];
    ["Offset of field: AVHWDeviceContext::type_"]
        [::std::mem::offset_of!(AVHWDeviceContext, type_) - 16usize];
    ["Offset of field: AVHWDeviceContext::hwctx"]
        [::std::mem::offset_of!(AVHWDeviceContext, hwctx) - 24usize];
    ["Offset of field: AVHWDeviceContext::free"]
        [::std::mem::offset_of!(AVHWDeviceContext, free) - 32usize];
    ["Offset of field: AVHWDeviceContext::user_opaque"]
        [::std::mem::offset_of!(AVHWDeviceContext, user_opaque) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWFramesInternal {
    _unused: [u8; 0],
}
#[doc = " This struct describes a set or pool of \"hardware\" frames (i.e. those with\n data not located in normal system memory). All the frames in the pool are\n assumed to be allocated in the same way and interchangeable.\n\n This struct is reference-counted with the AVBuffer mechanism and tied to a\n given AVHWDeviceContext instance. The av_hwframe_ctx_alloc() constructor\n yields a reference, whose data field points to the actual AVHWFramesContext\n struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVHWFramesContext {
    #[doc = " A class for logging."]
    pub av_class: *const AVClass,
    #[doc = " Private data used internally by libavutil. Must not be accessed in any\n way by the caller."]
    pub internal: *mut AVHWFramesInternal,
    #[doc = " A reference to the parent AVHWDeviceContext. This reference is owned and\n managed by the enclosing AVHWFramesContext, but the caller may derive\n additional references from it."]
    pub device_ref: *mut AVBufferRef,
    #[doc = " The parent AVHWDeviceContext. This is simply a pointer to\n device_ref->data provided for convenience.\n\n Set by libavutil in av_hwframe_ctx_init()."]
    pub device_ctx: *mut AVHWDeviceContext,
    #[doc = " The format-specific data, allocated and freed automatically along with\n this context.\n\n Should be cast by the user to the format-specific context defined in the\n corresponding header (hwframe_*.h) and filled as described in the\n documentation before calling av_hwframe_ctx_init().\n\n After any frames using this context are created, the contents of this\n struct should not be modified by the caller."]
    pub hwctx: *mut libc::c_void,
    #[doc = " This field may be set by the caller before calling av_hwframe_ctx_init().\n\n If non-NULL, this callback will be called when the last reference to\n this context is unreferenced, immediately before it is freed."]
    pub free: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVHWFramesContext)>,
    #[doc = " Arbitrary user data, to be used e.g. by the free() callback."]
    pub user_opaque: *mut libc::c_void,
    #[doc = " A pool from which the frames are allocated by av_hwframe_get_buffer().\n This field may be set by the caller before calling av_hwframe_ctx_init().\n The buffers returned by calling av_buffer_pool_get() on this pool must\n have the properties described in the documentation in the corresponding hw\n type's header (hwcontext_*.h). The pool will be freed strictly before\n this struct's free() callback is invoked.\n\n This field may be NULL, then libavutil will attempt to allocate a pool\n internally. Note that certain device types enforce pools allocated at\n fixed size (frame count), which cannot be extended dynamically. In such a\n case, initial_pool_size must be set appropriately."]
    pub pool: *mut AVBufferPool,
    #[doc = " Initial size of the frame pool. If a device type does not support\n dynamically resizing the pool, then this is also the maximum pool size.\n\n May be set by the caller before calling av_hwframe_ctx_init(). Must be\n set if pool is NULL and the device type does not support dynamic pools."]
    pub initial_pool_size: libc::c_int,
    #[doc = " The pixel format identifying the underlying HW surface type.\n\n Must be a hwaccel format, i.e. the corresponding descriptor must have the\n AV_PIX_FMT_FLAG_HWACCEL flag set.\n\n Must be set by the user before calling av_hwframe_ctx_init()."]
    pub format: AVPixelFormat,
    #[doc = " The pixel format identifying the actual data layout of the hardware\n frames.\n\n Must be set by the caller before calling av_hwframe_ctx_init().\n\n @note when the underlying API does not provide the exact data layout, but\n only the colorspace/bit depth, this field should be set to the fully\n planar version of that format (e.g. for 8-bit 420 YUV it should be\n AV_PIX_FMT_YUV420P, not AV_PIX_FMT_NV12 or anything else)."]
    pub sw_format: AVPixelFormat,
    #[doc = " The allocated dimensions of the frames in this pool.\n\n Must be set by the user before calling av_hwframe_ctx_init()."]
    pub width: libc::c_int,
    #[doc = " The allocated dimensions of the frames in this pool.\n\n Must be set by the user before calling av_hwframe_ctx_init()."]
    pub height: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVHWFramesContext"][::std::mem::size_of::<AVHWFramesContext>() - 88usize];
    ["Alignment of AVHWFramesContext"][::std::mem::align_of::<AVHWFramesContext>() - 8usize];
    ["Offset of field: AVHWFramesContext::av_class"]
        [::std::mem::offset_of!(AVHWFramesContext, av_class) - 0usize];
    ["Offset of field: AVHWFramesContext::internal"]
        [::std::mem::offset_of!(AVHWFramesContext, internal) - 8usize];
    ["Offset of field: AVHWFramesContext::device_ref"]
        [::std::mem::offset_of!(AVHWFramesContext, device_ref) - 16usize];
    ["Offset of field: AVHWFramesContext::device_ctx"]
        [::std::mem::offset_of!(AVHWFramesContext, device_ctx) - 24usize];
    ["Offset of field: AVHWFramesContext::hwctx"]
        [::std::mem::offset_of!(AVHWFramesContext, hwctx) - 32usize];
    ["Offset of field: AVHWFramesContext::free"]
        [::std::mem::offset_of!(AVHWFramesContext, free) - 40usize];
    ["Offset of field: AVHWFramesContext::user_opaque"]
        [::std::mem::offset_of!(AVHWFramesContext, user_opaque) - 48usize];
    ["Offset of field: AVHWFramesContext::pool"]
        [::std::mem::offset_of!(AVHWFramesContext, pool) - 56usize];
    ["Offset of field: AVHWFramesContext::initial_pool_size"]
        [::std::mem::offset_of!(AVHWFramesContext, initial_pool_size) - 64usize];
    ["Offset of field: AVHWFramesContext::format"]
        [::std::mem::offset_of!(AVHWFramesContext, format) - 68usize];
    ["Offset of field: AVHWFramesContext::sw_format"]
        [::std::mem::offset_of!(AVHWFramesContext, sw_format) - 72usize];
    ["Offset of field: AVHWFramesContext::width"]
        [::std::mem::offset_of!(AVHWFramesContext, width) - 76usize];
    ["Offset of field: AVHWFramesContext::height"]
        [::std::mem::offset_of!(AVHWFramesContext, height) - 80usize];
};
extern "C" {
    #[doc = " Look up an AVHWDeviceType by name.\n\n @param name String name of the device type (case-insensitive).\n @return The type from enum AVHWDeviceType, or AV_HWDEVICE_TYPE_NONE if\n         not found."]
    pub fn av_hwdevice_find_type_by_name(name: *const libc::c_char) -> AVHWDeviceType;
}
extern "C" {
    #[doc = " Get the string name of an AVHWDeviceType.\n\n @param type Type from enum AVHWDeviceType.\n @return Pointer to a static string containing the name, or NULL if the type\n         is not valid."]
    pub fn av_hwdevice_get_type_name(type_: AVHWDeviceType) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Iterate over supported device types.\n\n @param type AV_HWDEVICE_TYPE_NONE initially, then the previous type\n             returned by this function in subsequent iterations.\n @return The next usable device type from enum AVHWDeviceType, or\n         AV_HWDEVICE_TYPE_NONE if there are no more."]
    pub fn av_hwdevice_iterate_types(prev: AVHWDeviceType) -> AVHWDeviceType;
}
extern "C" {
    #[doc = " Allocate an AVHWDeviceContext for a given hardware type.\n\n @param type the type of the hardware device to allocate.\n @return a reference to the newly created AVHWDeviceContext on success or NULL\n         on failure."]
    pub fn av_hwdevice_ctx_alloc(type_: AVHWDeviceType) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Finalize the device context before use. This function must be called after\n the context is filled with all the required information and before it is\n used in any way.\n\n @param ref a reference to the AVHWDeviceContext\n @return 0 on success, a negative AVERROR code on failure"]
    pub fn av_hwdevice_ctx_init(ref_: *mut AVBufferRef) -> libc::c_int;
}
extern "C" {
    #[doc = " Open a device of the specified type and create an AVHWDeviceContext for it.\n\n This is a convenience function intended to cover the simple cases. Callers\n who need to fine-tune device creation/management should open the device\n manually and then wrap it in an AVHWDeviceContext using\n av_hwdevice_ctx_alloc()/av_hwdevice_ctx_init().\n\n The returned context is already initialized and ready for use, the caller\n should not call av_hwdevice_ctx_init() on it. The user_opaque/free fields of\n the created AVHWDeviceContext are set by this function and should not be\n touched by the caller.\n\n @param device_ctx On success, a reference to the newly-created device context\n                   will be written here. The reference is owned by the caller\n                   and must be released with av_buffer_unref() when no longer\n                   needed. On failure, NULL will be written to this pointer.\n @param type The type of the device to create.\n @param device A type-specific string identifying the device to open.\n @param opts A dictionary of additional (type-specific) options to use in\n             opening the device. The dictionary remains owned by the caller.\n @param flags currently unused\n\n @return 0 on success, a negative AVERROR code on failure."]
    pub fn av_hwdevice_ctx_create(
        device_ctx: *mut *mut AVBufferRef,
        type_: AVHWDeviceType,
        device: *const libc::c_char,
        opts: *mut AVDictionary,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Create a new device of the specified type from an existing device.\n\n If the source device is a device of the target type or was originally\n derived from such a device (possibly through one or more intermediate\n devices of other types), then this will return a reference to the\n existing device of the same type as is requested.\n\n Otherwise, it will attempt to derive a new device from the given source\n device.  If direct derivation to the new type is not implemented, it will\n attempt the same derivation from each ancestor of the source device in\n turn looking for an implemented derivation method.\n\n @param dst_ctx On success, a reference to the newly-created\n                AVHWDeviceContext.\n @param type    The type of the new device to create.\n @param src_ctx A reference to an existing AVHWDeviceContext which will be\n                used to create the new device.\n @param flags   Currently unused; should be set to zero.\n @return        Zero on success, a negative AVERROR code on failure."]
    pub fn av_hwdevice_ctx_create_derived(
        dst_ctx: *mut *mut AVBufferRef,
        type_: AVHWDeviceType,
        src_ctx: *mut AVBufferRef,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Create a new device of the specified type from an existing device.\n\n This function performs the same action as av_hwdevice_ctx_create_derived,\n however, it is able to set options for the new device to be derived.\n\n @param dst_ctx On success, a reference to the newly-created\n                AVHWDeviceContext.\n @param type    The type of the new device to create.\n @param src_ctx A reference to an existing AVHWDeviceContext which will be\n                used to create the new device.\n @param options Options for the new device to create, same format as in\n                av_hwdevice_ctx_create.\n @param flags   Currently unused; should be set to zero.\n @return        Zero on success, a negative AVERROR code on failure."]
    pub fn av_hwdevice_ctx_create_derived_opts(
        dst_ctx: *mut *mut AVBufferRef,
        type_: AVHWDeviceType,
        src_ctx: *mut AVBufferRef,
        options: *mut AVDictionary,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate an AVHWFramesContext tied to a given device context.\n\n @param device_ctx a reference to a AVHWDeviceContext. This function will make\n                   a new reference for internal use, the one passed to the\n                   function remains owned by the caller.\n @return a reference to the newly created AVHWFramesContext on success or NULL\n         on failure."]
    pub fn av_hwframe_ctx_alloc(device_ctx: *mut AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Finalize the context before use. This function must be called after the\n context is filled with all the required information and before it is attached\n to any frames.\n\n @param ref a reference to the AVHWFramesContext\n @return 0 on success, a negative AVERROR code on failure"]
    pub fn av_hwframe_ctx_init(ref_: *mut AVBufferRef) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate a new frame attached to the given AVHWFramesContext.\n\n @param hwframe_ctx a reference to an AVHWFramesContext\n @param frame an empty (freshly allocated or unreffed) frame to be filled with\n              newly allocated buffers.\n @param flags currently unused, should be set to zero\n @return 0 on success, a negative AVERROR code on failure"]
    pub fn av_hwframe_get_buffer(
        hwframe_ctx: *mut AVBufferRef,
        frame: *mut AVFrame,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy data to or from a hw surface. At least one of dst/src must have an\n AVHWFramesContext attached.\n\n If src has an AVHWFramesContext attached, then the format of dst (if set)\n must use one of the formats returned by av_hwframe_transfer_get_formats(src,\n AV_HWFRAME_TRANSFER_DIRECTION_FROM).\n If dst has an AVHWFramesContext attached, then the format of src must use one\n of the formats returned by av_hwframe_transfer_get_formats(dst,\n AV_HWFRAME_TRANSFER_DIRECTION_TO)\n\n dst may be \"clean\" (i.e. with data/buf pointers unset), in which case the\n data buffers will be allocated by this function using av_frame_get_buffer().\n If dst->format is set, then this format will be used, otherwise (when\n dst->format is AV_PIX_FMT_NONE) the first acceptable format will be chosen.\n\n The two frames must have matching allocated dimensions (i.e. equal to\n AVHWFramesContext.width/height), since not all device types support\n transferring a sub-rectangle of the whole surface. The display dimensions\n (i.e. AVFrame.width/height) may be smaller than the allocated dimensions, but\n also have to be equal for both frames. When the display dimensions are\n smaller than the allocated dimensions, the content of the padding in the\n destination frame is unspecified.\n\n @param dst the destination frame. dst is not touched on failure.\n @param src the source frame.\n @param flags currently unused, should be set to zero\n @return 0 on success, a negative AVERROR error code on failure."]
    pub fn av_hwframe_transfer_data(
        dst: *mut AVFrame,
        src: *const AVFrame,
        flags: libc::c_int,
    ) -> libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVHWFrameTransferDirection {
    #[doc = " Transfer the data from the queried hw frame."]
    AV_HWFRAME_TRANSFER_DIRECTION_FROM = 0,
    #[doc = " Transfer the data to the queried hw frame."]
    AV_HWFRAME_TRANSFER_DIRECTION_TO = 1,
}
extern "C" {
    #[doc = " Get a list of possible source or target formats usable in\n av_hwframe_transfer_data().\n\n @param hwframe_ctx the frame context to obtain the information for\n @param dir the direction of the transfer\n @param formats the pointer to the output format list will be written here.\n                The list is terminated with AV_PIX_FMT_NONE and must be freed\n                by the caller when no longer needed using av_free().\n                If this function returns successfully, the format list will\n                have at least one item (not counting the terminator).\n                On failure, the contents of this pointer are unspecified.\n @param flags currently unused, should be set to zero\n @return 0 on success, a negative AVERROR code on failure."]
    pub fn av_hwframe_transfer_get_formats(
        hwframe_ctx: *mut AVBufferRef,
        dir: AVHWFrameTransferDirection,
        formats: *mut *mut AVPixelFormat,
        flags: libc::c_int,
    ) -> libc::c_int;
}
#[doc = " This struct describes the constraints on hardware frames attached to\n a given device with a hardware-specific configuration.  This is returned\n by av_hwdevice_get_hwframe_constraints() and must be freed by\n av_hwframe_constraints_free() after use."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVHWFramesConstraints {
    #[doc = " A list of possible values for format in the hw_frames_ctx,\n terminated by AV_PIX_FMT_NONE.  This member will always be filled."]
    pub valid_hw_formats: *mut AVPixelFormat,
    #[doc = " A list of possible values for sw_format in the hw_frames_ctx,\n terminated by AV_PIX_FMT_NONE.  Can be NULL if this information is\n not known."]
    pub valid_sw_formats: *mut AVPixelFormat,
    #[doc = " The minimum size of frames in this hw_frames_ctx.\n (Zero if not known.)"]
    pub min_width: libc::c_int,
    pub min_height: libc::c_int,
    #[doc = " The maximum size of frames in this hw_frames_ctx.\n (INT_MAX if not known / no limit.)"]
    pub max_width: libc::c_int,
    pub max_height: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVHWFramesConstraints"][::std::mem::size_of::<AVHWFramesConstraints>() - 32usize];
    ["Alignment of AVHWFramesConstraints"]
        [::std::mem::align_of::<AVHWFramesConstraints>() - 8usize];
    ["Offset of field: AVHWFramesConstraints::valid_hw_formats"]
        [::std::mem::offset_of!(AVHWFramesConstraints, valid_hw_formats) - 0usize];
    ["Offset of field: AVHWFramesConstraints::valid_sw_formats"]
        [::std::mem::offset_of!(AVHWFramesConstraints, valid_sw_formats) - 8usize];
    ["Offset of field: AVHWFramesConstraints::min_width"]
        [::std::mem::offset_of!(AVHWFramesConstraints, min_width) - 16usize];
    ["Offset of field: AVHWFramesConstraints::min_height"]
        [::std::mem::offset_of!(AVHWFramesConstraints, min_height) - 20usize];
    ["Offset of field: AVHWFramesConstraints::max_width"]
        [::std::mem::offset_of!(AVHWFramesConstraints, max_width) - 24usize];
    ["Offset of field: AVHWFramesConstraints::max_height"]
        [::std::mem::offset_of!(AVHWFramesConstraints, max_height) - 28usize];
};
extern "C" {
    #[doc = " Allocate a HW-specific configuration structure for a given HW device.\n After use, the user must free all members as required by the specific\n hardware structure being used, then free the structure itself with\n av_free().\n\n @param device_ctx a reference to the associated AVHWDeviceContext.\n @return The newly created HW-specific configuration structure on\n         success or NULL on failure."]
    pub fn av_hwdevice_hwconfig_alloc(device_ctx: *mut AVBufferRef) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Get the constraints on HW frames given a device and the HW-specific\n configuration to be used with that device.  If no HW-specific\n configuration is provided, returns the maximum possible capabilities\n of the device.\n\n @param ref a reference to the associated AVHWDeviceContext.\n @param hwconfig a filled HW-specific configuration structure, or NULL\n        to return the maximum possible capabilities of the device.\n @return AVHWFramesConstraints structure describing the constraints\n         on the device, or NULL if not available."]
    pub fn av_hwdevice_get_hwframe_constraints(
        ref_: *mut AVBufferRef,
        hwconfig: *const libc::c_void,
    ) -> *mut AVHWFramesConstraints;
}
extern "C" {
    #[doc = " Free an AVHWFrameConstraints structure.\n\n @param constraints The (filled or unfilled) AVHWFrameConstraints structure."]
    pub fn av_hwframe_constraints_free(constraints: *mut *mut AVHWFramesConstraints);
}
pub const AV_HWFRAME_MAP_READ: _bindgen_ty_3 = _bindgen_ty_3::AV_HWFRAME_MAP_READ;
pub const AV_HWFRAME_MAP_WRITE: _bindgen_ty_3 = _bindgen_ty_3::AV_HWFRAME_MAP_WRITE;
pub const AV_HWFRAME_MAP_OVERWRITE: _bindgen_ty_3 = _bindgen_ty_3::AV_HWFRAME_MAP_OVERWRITE;
pub const AV_HWFRAME_MAP_DIRECT: _bindgen_ty_3 = _bindgen_ty_3::AV_HWFRAME_MAP_DIRECT;
#[repr(u32)]
#[doc = " Flags to apply to frame mappings."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_3 {
    #[doc = " The mapping must be readable."]
    AV_HWFRAME_MAP_READ = 1,
    #[doc = " The mapping must be writeable."]
    AV_HWFRAME_MAP_WRITE = 2,
    #[doc = " The mapped frame will be overwritten completely in subsequent\n operations, so the current frame data need not be loaded.  Any values\n which are not overwritten are unspecified."]
    AV_HWFRAME_MAP_OVERWRITE = 4,
    #[doc = " The mapping must be direct.  That is, there must not be any copying in\n the map or unmap steps.  Note that performance of direct mappings may\n be much lower than normal memory."]
    AV_HWFRAME_MAP_DIRECT = 8,
}
extern "C" {
    #[doc = " Map a hardware frame.\n\n This has a number of different possible effects, depending on the format\n and origin of the src and dst frames.  On input, src should be a usable\n frame with valid buffers and dst should be blank (typically as just created\n by av_frame_alloc()).  src should have an associated hwframe context, and\n dst may optionally have a format and associated hwframe context.\n\n If src was created by mapping a frame from the hwframe context of dst,\n then this function undoes the mapping - dst is replaced by a reference to\n the frame that src was originally mapped from.\n\n If both src and dst have an associated hwframe context, then this function\n attempts to map the src frame from its hardware context to that of dst and\n then fill dst with appropriate data to be usable there.  This will only be\n possible if the hwframe contexts and associated devices are compatible -\n given compatible devices, av_hwframe_ctx_create_derived() can be used to\n create a hwframe context for dst in which mapping should be possible.\n\n If src has a hwframe context but dst does not, then the src frame is\n mapped to normal memory and should thereafter be usable as a normal frame.\n If the format is set on dst, then the mapping will attempt to create dst\n with that format and fail if it is not possible.  If format is unset (is\n AV_PIX_FMT_NONE) then dst will be mapped with whatever the most appropriate\n format to use is (probably the sw_format of the src hwframe context).\n\n A return value of AVERROR(ENOSYS) indicates that the mapping is not\n possible with the given arguments and hwframe setup, while other return\n values indicate that it failed somehow.\n\n @param dst Destination frame, to contain the mapping.\n @param src Source frame, to be mapped.\n @param flags Some combination of AV_HWFRAME_MAP_* flags.\n @return Zero on success, negative AVERROR code on failure."]
    pub fn av_hwframe_map(
        dst: *mut AVFrame,
        src: *const AVFrame,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Create and initialise an AVHWFramesContext as a mapping of another existing\n AVHWFramesContext on a different device.\n\n av_hwframe_ctx_init() should not be called after this.\n\n @param derived_frame_ctx  On success, a reference to the newly created\n                           AVHWFramesContext.\n @param derived_device_ctx A reference to the device to create the new\n                           AVHWFramesContext on.\n @param source_frame_ctx   A reference to an existing AVHWFramesContext\n                           which will be mapped to the derived context.\n @param flags  Some combination of AV_HWFRAME_MAP_* flags, defining the\n               mapping parameters to apply to frames which are allocated\n               in the derived device.\n @return       Zero on success, negative AVERROR code on failure."]
    pub fn av_hwframe_ctx_create_derived(
        derived_frame_ctx: *mut *mut AVBufferRef,
        format: AVPixelFormat,
        derived_device_ctx: *mut AVBufferRef,
        source_frame_ctx: *mut AVBufferRef,
        flags: libc::c_int,
    ) -> libc::c_int;
}
impl AVCodecID {
    pub const AV_CODEC_ID_FIRST_AUDIO: AVCodecID = AVCodecID::AV_CODEC_ID_PCM_S16LE;
}
impl AVCodecID {
    pub const AV_CODEC_ID_FIRST_SUBTITLE: AVCodecID = AVCodecID::AV_CODEC_ID_DVD_SUBTITLE;
}
impl AVCodecID {
    pub const AV_CODEC_ID_FIRST_UNKNOWN: AVCodecID = AVCodecID::AV_CODEC_ID_TTF;
}
#[repr(u32)]
#[doc = " Identify the syntax and semantics of the bitstream.\n The principle is roughly:\n Two decoders with the same ID can decode the same streams.\n Two encoders with the same ID can encode compatible streams.\n There may be slight deviations from the principle due to implementation\n details.\n\n If you add a codec ID to this list, add it so that\n 1. no value of an existing codec ID changes (that would break ABI),\n 2. it is as close as possible to similar codecs\n\n After adding new codec IDs, do not forget to add an entry to the codec\n descriptor list and bump libavcodec minor version."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVCodecID {
    AV_CODEC_ID_NONE = 0,
    AV_CODEC_ID_MPEG1VIDEO = 1,
    #[doc = "< preferred ID for MPEG-1/2 video decoding"]
    AV_CODEC_ID_MPEG2VIDEO = 2,
    AV_CODEC_ID_H261 = 3,
    AV_CODEC_ID_H263 = 4,
    AV_CODEC_ID_RV10 = 5,
    AV_CODEC_ID_RV20 = 6,
    AV_CODEC_ID_MJPEG = 7,
    AV_CODEC_ID_MJPEGB = 8,
    AV_CODEC_ID_LJPEG = 9,
    AV_CODEC_ID_SP5X = 10,
    AV_CODEC_ID_JPEGLS = 11,
    AV_CODEC_ID_MPEG4 = 12,
    AV_CODEC_ID_RAWVIDEO = 13,
    AV_CODEC_ID_MSMPEG4V1 = 14,
    AV_CODEC_ID_MSMPEG4V2 = 15,
    AV_CODEC_ID_MSMPEG4V3 = 16,
    AV_CODEC_ID_WMV1 = 17,
    AV_CODEC_ID_WMV2 = 18,
    AV_CODEC_ID_H263P = 19,
    AV_CODEC_ID_H263I = 20,
    AV_CODEC_ID_FLV1 = 21,
    AV_CODEC_ID_SVQ1 = 22,
    AV_CODEC_ID_SVQ3 = 23,
    AV_CODEC_ID_DVVIDEO = 24,
    AV_CODEC_ID_HUFFYUV = 25,
    AV_CODEC_ID_CYUV = 26,
    AV_CODEC_ID_H264 = 27,
    AV_CODEC_ID_INDEO3 = 28,
    AV_CODEC_ID_VP3 = 29,
    AV_CODEC_ID_THEORA = 30,
    AV_CODEC_ID_ASV1 = 31,
    AV_CODEC_ID_ASV2 = 32,
    AV_CODEC_ID_FFV1 = 33,
    AV_CODEC_ID_4XM = 34,
    AV_CODEC_ID_VCR1 = 35,
    AV_CODEC_ID_CLJR = 36,
    AV_CODEC_ID_MDEC = 37,
    AV_CODEC_ID_ROQ = 38,
    AV_CODEC_ID_INTERPLAY_VIDEO = 39,
    AV_CODEC_ID_XAN_WC3 = 40,
    AV_CODEC_ID_XAN_WC4 = 41,
    AV_CODEC_ID_RPZA = 42,
    AV_CODEC_ID_CINEPAK = 43,
    AV_CODEC_ID_WS_VQA = 44,
    AV_CODEC_ID_MSRLE = 45,
    AV_CODEC_ID_MSVIDEO1 = 46,
    AV_CODEC_ID_IDCIN = 47,
    AV_CODEC_ID_8BPS = 48,
    AV_CODEC_ID_SMC = 49,
    AV_CODEC_ID_FLIC = 50,
    AV_CODEC_ID_TRUEMOTION1 = 51,
    AV_CODEC_ID_VMDVIDEO = 52,
    AV_CODEC_ID_MSZH = 53,
    AV_CODEC_ID_ZLIB = 54,
    AV_CODEC_ID_QTRLE = 55,
    AV_CODEC_ID_TSCC = 56,
    AV_CODEC_ID_ULTI = 57,
    AV_CODEC_ID_QDRAW = 58,
    AV_CODEC_ID_VIXL = 59,
    AV_CODEC_ID_QPEG = 60,
    AV_CODEC_ID_PNG = 61,
    AV_CODEC_ID_PPM = 62,
    AV_CODEC_ID_PBM = 63,
    AV_CODEC_ID_PGM = 64,
    AV_CODEC_ID_PGMYUV = 65,
    AV_CODEC_ID_PAM = 66,
    AV_CODEC_ID_FFVHUFF = 67,
    AV_CODEC_ID_RV30 = 68,
    AV_CODEC_ID_RV40 = 69,
    AV_CODEC_ID_VC1 = 70,
    AV_CODEC_ID_WMV3 = 71,
    AV_CODEC_ID_LOCO = 72,
    AV_CODEC_ID_WNV1 = 73,
    AV_CODEC_ID_AASC = 74,
    AV_CODEC_ID_INDEO2 = 75,
    AV_CODEC_ID_FRAPS = 76,
    AV_CODEC_ID_TRUEMOTION2 = 77,
    AV_CODEC_ID_BMP = 78,
    AV_CODEC_ID_CSCD = 79,
    AV_CODEC_ID_MMVIDEO = 80,
    AV_CODEC_ID_ZMBV = 81,
    AV_CODEC_ID_AVS = 82,
    AV_CODEC_ID_SMACKVIDEO = 83,
    AV_CODEC_ID_NUV = 84,
    AV_CODEC_ID_KMVC = 85,
    AV_CODEC_ID_FLASHSV = 86,
    AV_CODEC_ID_CAVS = 87,
    AV_CODEC_ID_JPEG2000 = 88,
    AV_CODEC_ID_VMNC = 89,
    AV_CODEC_ID_VP5 = 90,
    AV_CODEC_ID_VP6 = 91,
    AV_CODEC_ID_VP6F = 92,
    AV_CODEC_ID_TARGA = 93,
    AV_CODEC_ID_DSICINVIDEO = 94,
    AV_CODEC_ID_TIERTEXSEQVIDEO = 95,
    AV_CODEC_ID_TIFF = 96,
    AV_CODEC_ID_GIF = 97,
    AV_CODEC_ID_DXA = 98,
    AV_CODEC_ID_DNXHD = 99,
    AV_CODEC_ID_THP = 100,
    AV_CODEC_ID_SGI = 101,
    AV_CODEC_ID_C93 = 102,
    AV_CODEC_ID_BETHSOFTVID = 103,
    AV_CODEC_ID_PTX = 104,
    AV_CODEC_ID_TXD = 105,
    AV_CODEC_ID_VP6A = 106,
    AV_CODEC_ID_AMV = 107,
    AV_CODEC_ID_VB = 108,
    AV_CODEC_ID_PCX = 109,
    AV_CODEC_ID_SUNRAST = 110,
    AV_CODEC_ID_INDEO4 = 111,
    AV_CODEC_ID_INDEO5 = 112,
    AV_CODEC_ID_MIMIC = 113,
    AV_CODEC_ID_RL2 = 114,
    AV_CODEC_ID_ESCAPE124 = 115,
    AV_CODEC_ID_DIRAC = 116,
    AV_CODEC_ID_BFI = 117,
    AV_CODEC_ID_CMV = 118,
    AV_CODEC_ID_MOTIONPIXELS = 119,
    AV_CODEC_ID_TGV = 120,
    AV_CODEC_ID_TGQ = 121,
    AV_CODEC_ID_TQI = 122,
    AV_CODEC_ID_AURA = 123,
    AV_CODEC_ID_AURA2 = 124,
    AV_CODEC_ID_V210X = 125,
    AV_CODEC_ID_TMV = 126,
    AV_CODEC_ID_V210 = 127,
    AV_CODEC_ID_DPX = 128,
    AV_CODEC_ID_MAD = 129,
    AV_CODEC_ID_FRWU = 130,
    AV_CODEC_ID_FLASHSV2 = 131,
    AV_CODEC_ID_CDGRAPHICS = 132,
    AV_CODEC_ID_R210 = 133,
    AV_CODEC_ID_ANM = 134,
    AV_CODEC_ID_BINKVIDEO = 135,
    AV_CODEC_ID_IFF_ILBM = 136,
    AV_CODEC_ID_KGV1 = 137,
    AV_CODEC_ID_YOP = 138,
    AV_CODEC_ID_VP8 = 139,
    AV_CODEC_ID_PICTOR = 140,
    AV_CODEC_ID_ANSI = 141,
    AV_CODEC_ID_A64_MULTI = 142,
    AV_CODEC_ID_A64_MULTI5 = 143,
    AV_CODEC_ID_R10K = 144,
    AV_CODEC_ID_MXPEG = 145,
    AV_CODEC_ID_LAGARITH = 146,
    AV_CODEC_ID_PRORES = 147,
    AV_CODEC_ID_JV = 148,
    AV_CODEC_ID_DFA = 149,
    AV_CODEC_ID_WMV3IMAGE = 150,
    AV_CODEC_ID_VC1IMAGE = 151,
    AV_CODEC_ID_UTVIDEO = 152,
    AV_CODEC_ID_BMV_VIDEO = 153,
    AV_CODEC_ID_VBLE = 154,
    AV_CODEC_ID_DXTORY = 155,
    AV_CODEC_ID_V410 = 156,
    AV_CODEC_ID_XWD = 157,
    AV_CODEC_ID_CDXL = 158,
    AV_CODEC_ID_XBM = 159,
    AV_CODEC_ID_ZEROCODEC = 160,
    AV_CODEC_ID_MSS1 = 161,
    AV_CODEC_ID_MSA1 = 162,
    AV_CODEC_ID_TSCC2 = 163,
    AV_CODEC_ID_MTS2 = 164,
    AV_CODEC_ID_CLLC = 165,
    AV_CODEC_ID_MSS2 = 166,
    AV_CODEC_ID_VP9 = 167,
    AV_CODEC_ID_AIC = 168,
    AV_CODEC_ID_ESCAPE130 = 169,
    AV_CODEC_ID_G2M = 170,
    AV_CODEC_ID_WEBP = 171,
    AV_CODEC_ID_HNM4_VIDEO = 172,
    AV_CODEC_ID_HEVC = 173,
    AV_CODEC_ID_FIC = 174,
    AV_CODEC_ID_ALIAS_PIX = 175,
    AV_CODEC_ID_BRENDER_PIX = 176,
    AV_CODEC_ID_PAF_VIDEO = 177,
    AV_CODEC_ID_EXR = 178,
    AV_CODEC_ID_VP7 = 179,
    AV_CODEC_ID_SANM = 180,
    AV_CODEC_ID_SGIRLE = 181,
    AV_CODEC_ID_MVC1 = 182,
    AV_CODEC_ID_MVC2 = 183,
    AV_CODEC_ID_HQX = 184,
    AV_CODEC_ID_TDSC = 185,
    AV_CODEC_ID_HQ_HQA = 186,
    AV_CODEC_ID_HAP = 187,
    AV_CODEC_ID_DDS = 188,
    AV_CODEC_ID_DXV = 189,
    AV_CODEC_ID_SCREENPRESSO = 190,
    AV_CODEC_ID_RSCC = 191,
    AV_CODEC_ID_AVS2 = 192,
    AV_CODEC_ID_PGX = 193,
    AV_CODEC_ID_AVS3 = 194,
    AV_CODEC_ID_MSP2 = 195,
    AV_CODEC_ID_VVC = 196,
    AV_CODEC_ID_Y41P = 32768,
    AV_CODEC_ID_AVRP = 32769,
    AV_CODEC_ID_012V = 32770,
    AV_CODEC_ID_AVUI = 32771,
    AV_CODEC_ID_AYUV = 32772,
    AV_CODEC_ID_TARGA_Y216 = 32773,
    AV_CODEC_ID_V308 = 32774,
    AV_CODEC_ID_V408 = 32775,
    AV_CODEC_ID_YUV4 = 32776,
    AV_CODEC_ID_AVRN = 32777,
    AV_CODEC_ID_CPIA = 32778,
    AV_CODEC_ID_XFACE = 32779,
    AV_CODEC_ID_SNOW = 32780,
    AV_CODEC_ID_SMVJPEG = 32781,
    AV_CODEC_ID_APNG = 32782,
    AV_CODEC_ID_DAALA = 32783,
    AV_CODEC_ID_CFHD = 32784,
    AV_CODEC_ID_TRUEMOTION2RT = 32785,
    AV_CODEC_ID_M101 = 32786,
    AV_CODEC_ID_MAGICYUV = 32787,
    AV_CODEC_ID_SHEERVIDEO = 32788,
    AV_CODEC_ID_YLC = 32789,
    AV_CODEC_ID_PSD = 32790,
    AV_CODEC_ID_PIXLET = 32791,
    AV_CODEC_ID_SPEEDHQ = 32792,
    AV_CODEC_ID_FMVC = 32793,
    AV_CODEC_ID_SCPR = 32794,
    AV_CODEC_ID_CLEARVIDEO = 32795,
    AV_CODEC_ID_XPM = 32796,
    AV_CODEC_ID_AV1 = 32797,
    AV_CODEC_ID_BITPACKED = 32798,
    AV_CODEC_ID_MSCC = 32799,
    AV_CODEC_ID_SRGC = 32800,
    AV_CODEC_ID_SVG = 32801,
    AV_CODEC_ID_GDV = 32802,
    AV_CODEC_ID_FITS = 32803,
    AV_CODEC_ID_IMM4 = 32804,
    AV_CODEC_ID_PROSUMER = 32805,
    AV_CODEC_ID_MWSC = 32806,
    AV_CODEC_ID_WCMV = 32807,
    AV_CODEC_ID_RASC = 32808,
    AV_CODEC_ID_HYMT = 32809,
    AV_CODEC_ID_ARBC = 32810,
    AV_CODEC_ID_AGM = 32811,
    AV_CODEC_ID_LSCR = 32812,
    AV_CODEC_ID_VP4 = 32813,
    AV_CODEC_ID_IMM5 = 32814,
    AV_CODEC_ID_MVDV = 32815,
    AV_CODEC_ID_MVHA = 32816,
    AV_CODEC_ID_CDTOONS = 32817,
    AV_CODEC_ID_MV30 = 32818,
    AV_CODEC_ID_NOTCHLC = 32819,
    AV_CODEC_ID_PFM = 32820,
    AV_CODEC_ID_MOBICLIP = 32821,
    AV_CODEC_ID_PHOTOCD = 32822,
    AV_CODEC_ID_IPU = 32823,
    AV_CODEC_ID_ARGO = 32824,
    AV_CODEC_ID_CRI = 32825,
    AV_CODEC_ID_SIMBIOSIS_IMX = 32826,
    AV_CODEC_ID_SGA_VIDEO = 32827,
    AV_CODEC_ID_PCM_S16LE = 65536,
    AV_CODEC_ID_PCM_S16BE = 65537,
    AV_CODEC_ID_PCM_U16LE = 65538,
    AV_CODEC_ID_PCM_U16BE = 65539,
    AV_CODEC_ID_PCM_S8 = 65540,
    AV_CODEC_ID_PCM_U8 = 65541,
    AV_CODEC_ID_PCM_MULAW = 65542,
    AV_CODEC_ID_PCM_ALAW = 65543,
    AV_CODEC_ID_PCM_S32LE = 65544,
    AV_CODEC_ID_PCM_S32BE = 65545,
    AV_CODEC_ID_PCM_U32LE = 65546,
    AV_CODEC_ID_PCM_U32BE = 65547,
    AV_CODEC_ID_PCM_S24LE = 65548,
    AV_CODEC_ID_PCM_S24BE = 65549,
    AV_CODEC_ID_PCM_U24LE = 65550,
    AV_CODEC_ID_PCM_U24BE = 65551,
    AV_CODEC_ID_PCM_S24DAUD = 65552,
    AV_CODEC_ID_PCM_ZORK = 65553,
    AV_CODEC_ID_PCM_S16LE_PLANAR = 65554,
    AV_CODEC_ID_PCM_DVD = 65555,
    AV_CODEC_ID_PCM_F32BE = 65556,
    AV_CODEC_ID_PCM_F32LE = 65557,
    AV_CODEC_ID_PCM_F64BE = 65558,
    AV_CODEC_ID_PCM_F64LE = 65559,
    AV_CODEC_ID_PCM_BLURAY = 65560,
    AV_CODEC_ID_PCM_LXF = 65561,
    AV_CODEC_ID_S302M = 65562,
    AV_CODEC_ID_PCM_S8_PLANAR = 65563,
    AV_CODEC_ID_PCM_S24LE_PLANAR = 65564,
    AV_CODEC_ID_PCM_S32LE_PLANAR = 65565,
    AV_CODEC_ID_PCM_S16BE_PLANAR = 65566,
    AV_CODEC_ID_PCM_S64LE = 67584,
    AV_CODEC_ID_PCM_S64BE = 67585,
    AV_CODEC_ID_PCM_F16LE = 67586,
    AV_CODEC_ID_PCM_F24LE = 67587,
    AV_CODEC_ID_PCM_VIDC = 67588,
    AV_CODEC_ID_PCM_SGA = 67589,
    AV_CODEC_ID_ADPCM_IMA_QT = 69632,
    AV_CODEC_ID_ADPCM_IMA_WAV = 69633,
    AV_CODEC_ID_ADPCM_IMA_DK3 = 69634,
    AV_CODEC_ID_ADPCM_IMA_DK4 = 69635,
    AV_CODEC_ID_ADPCM_IMA_WS = 69636,
    AV_CODEC_ID_ADPCM_IMA_SMJPEG = 69637,
    AV_CODEC_ID_ADPCM_MS = 69638,
    AV_CODEC_ID_ADPCM_4XM = 69639,
    AV_CODEC_ID_ADPCM_XA = 69640,
    AV_CODEC_ID_ADPCM_ADX = 69641,
    AV_CODEC_ID_ADPCM_EA = 69642,
    AV_CODEC_ID_ADPCM_G726 = 69643,
    AV_CODEC_ID_ADPCM_CT = 69644,
    AV_CODEC_ID_ADPCM_SWF = 69645,
    AV_CODEC_ID_ADPCM_YAMAHA = 69646,
    AV_CODEC_ID_ADPCM_SBPRO_4 = 69647,
    AV_CODEC_ID_ADPCM_SBPRO_3 = 69648,
    AV_CODEC_ID_ADPCM_SBPRO_2 = 69649,
    AV_CODEC_ID_ADPCM_THP = 69650,
    AV_CODEC_ID_ADPCM_IMA_AMV = 69651,
    AV_CODEC_ID_ADPCM_EA_R1 = 69652,
    AV_CODEC_ID_ADPCM_EA_R3 = 69653,
    AV_CODEC_ID_ADPCM_EA_R2 = 69654,
    AV_CODEC_ID_ADPCM_IMA_EA_SEAD = 69655,
    AV_CODEC_ID_ADPCM_IMA_EA_EACS = 69656,
    AV_CODEC_ID_ADPCM_EA_XAS = 69657,
    AV_CODEC_ID_ADPCM_EA_MAXIS_XA = 69658,
    AV_CODEC_ID_ADPCM_IMA_ISS = 69659,
    AV_CODEC_ID_ADPCM_G722 = 69660,
    AV_CODEC_ID_ADPCM_IMA_APC = 69661,
    AV_CODEC_ID_ADPCM_VIMA = 69662,
    AV_CODEC_ID_ADPCM_AFC = 71680,
    AV_CODEC_ID_ADPCM_IMA_OKI = 71681,
    AV_CODEC_ID_ADPCM_DTK = 71682,
    AV_CODEC_ID_ADPCM_IMA_RAD = 71683,
    AV_CODEC_ID_ADPCM_G726LE = 71684,
    AV_CODEC_ID_ADPCM_THP_LE = 71685,
    AV_CODEC_ID_ADPCM_PSX = 71686,
    AV_CODEC_ID_ADPCM_AICA = 71687,
    AV_CODEC_ID_ADPCM_IMA_DAT4 = 71688,
    AV_CODEC_ID_ADPCM_MTAF = 71689,
    AV_CODEC_ID_ADPCM_AGM = 71690,
    AV_CODEC_ID_ADPCM_ARGO = 71691,
    AV_CODEC_ID_ADPCM_IMA_SSI = 71692,
    AV_CODEC_ID_ADPCM_ZORK = 71693,
    AV_CODEC_ID_ADPCM_IMA_APM = 71694,
    AV_CODEC_ID_ADPCM_IMA_ALP = 71695,
    AV_CODEC_ID_ADPCM_IMA_MTF = 71696,
    AV_CODEC_ID_ADPCM_IMA_CUNNING = 71697,
    AV_CODEC_ID_ADPCM_IMA_MOFLEX = 71698,
    AV_CODEC_ID_AMR_NB = 73728,
    AV_CODEC_ID_AMR_WB = 73729,
    AV_CODEC_ID_RA_144 = 77824,
    AV_CODEC_ID_RA_288 = 77825,
    AV_CODEC_ID_ROQ_DPCM = 81920,
    AV_CODEC_ID_INTERPLAY_DPCM = 81921,
    AV_CODEC_ID_XAN_DPCM = 81922,
    AV_CODEC_ID_SOL_DPCM = 81923,
    AV_CODEC_ID_SDX2_DPCM = 83968,
    AV_CODEC_ID_GREMLIN_DPCM = 83969,
    AV_CODEC_ID_DERF_DPCM = 83970,
    AV_CODEC_ID_MP2 = 86016,
    #[doc = "< preferred ID for decoding MPEG audio layer 1, 2 or 3"]
    AV_CODEC_ID_MP3 = 86017,
    AV_CODEC_ID_AAC = 86018,
    AV_CODEC_ID_AC3 = 86019,
    AV_CODEC_ID_DTS = 86020,
    AV_CODEC_ID_VORBIS = 86021,
    AV_CODEC_ID_DVAUDIO = 86022,
    AV_CODEC_ID_WMAV1 = 86023,
    AV_CODEC_ID_WMAV2 = 86024,
    AV_CODEC_ID_MACE3 = 86025,
    AV_CODEC_ID_MACE6 = 86026,
    AV_CODEC_ID_VMDAUDIO = 86027,
    AV_CODEC_ID_FLAC = 86028,
    AV_CODEC_ID_MP3ADU = 86029,
    AV_CODEC_ID_MP3ON4 = 86030,
    AV_CODEC_ID_SHORTEN = 86031,
    AV_CODEC_ID_ALAC = 86032,
    AV_CODEC_ID_WESTWOOD_SND1 = 86033,
    #[doc = "< as in Berlin toast format"]
    AV_CODEC_ID_GSM = 86034,
    AV_CODEC_ID_QDM2 = 86035,
    AV_CODEC_ID_COOK = 86036,
    AV_CODEC_ID_TRUESPEECH = 86037,
    AV_CODEC_ID_TTA = 86038,
    AV_CODEC_ID_SMACKAUDIO = 86039,
    AV_CODEC_ID_QCELP = 86040,
    AV_CODEC_ID_WAVPACK = 86041,
    AV_CODEC_ID_DSICINAUDIO = 86042,
    AV_CODEC_ID_IMC = 86043,
    AV_CODEC_ID_MUSEPACK7 = 86044,
    AV_CODEC_ID_MLP = 86045,
    AV_CODEC_ID_GSM_MS = 86046,
    AV_CODEC_ID_ATRAC3 = 86047,
    AV_CODEC_ID_APE = 86048,
    AV_CODEC_ID_NELLYMOSER = 86049,
    AV_CODEC_ID_MUSEPACK8 = 86050,
    AV_CODEC_ID_SPEEX = 86051,
    AV_CODEC_ID_WMAVOICE = 86052,
    AV_CODEC_ID_WMAPRO = 86053,
    AV_CODEC_ID_WMALOSSLESS = 86054,
    AV_CODEC_ID_ATRAC3P = 86055,
    AV_CODEC_ID_EAC3 = 86056,
    AV_CODEC_ID_SIPR = 86057,
    AV_CODEC_ID_MP1 = 86058,
    AV_CODEC_ID_TWINVQ = 86059,
    AV_CODEC_ID_TRUEHD = 86060,
    AV_CODEC_ID_MP4ALS = 86061,
    AV_CODEC_ID_ATRAC1 = 86062,
    AV_CODEC_ID_BINKAUDIO_RDFT = 86063,
    AV_CODEC_ID_BINKAUDIO_DCT = 86064,
    AV_CODEC_ID_AAC_LATM = 86065,
    AV_CODEC_ID_QDMC = 86066,
    AV_CODEC_ID_CELT = 86067,
    AV_CODEC_ID_G723_1 = 86068,
    AV_CODEC_ID_G729 = 86069,
    AV_CODEC_ID_8SVX_EXP = 86070,
    AV_CODEC_ID_8SVX_FIB = 86071,
    AV_CODEC_ID_BMV_AUDIO = 86072,
    AV_CODEC_ID_RALF = 86073,
    AV_CODEC_ID_IAC = 86074,
    AV_CODEC_ID_ILBC = 86075,
    AV_CODEC_ID_OPUS = 86076,
    AV_CODEC_ID_COMFORT_NOISE = 86077,
    AV_CODEC_ID_TAK = 86078,
    AV_CODEC_ID_METASOUND = 86079,
    AV_CODEC_ID_PAF_AUDIO = 86080,
    AV_CODEC_ID_ON2AVC = 86081,
    AV_CODEC_ID_DSS_SP = 86082,
    AV_CODEC_ID_CODEC2 = 86083,
    AV_CODEC_ID_FFWAVESYNTH = 88064,
    AV_CODEC_ID_SONIC = 88065,
    AV_CODEC_ID_SONIC_LS = 88066,
    AV_CODEC_ID_EVRC = 88067,
    AV_CODEC_ID_SMV = 88068,
    AV_CODEC_ID_DSD_LSBF = 88069,
    AV_CODEC_ID_DSD_MSBF = 88070,
    AV_CODEC_ID_DSD_LSBF_PLANAR = 88071,
    AV_CODEC_ID_DSD_MSBF_PLANAR = 88072,
    AV_CODEC_ID_4GV = 88073,
    AV_CODEC_ID_INTERPLAY_ACM = 88074,
    AV_CODEC_ID_XMA1 = 88075,
    AV_CODEC_ID_XMA2 = 88076,
    AV_CODEC_ID_DST = 88077,
    AV_CODEC_ID_ATRAC3AL = 88078,
    AV_CODEC_ID_ATRAC3PAL = 88079,
    AV_CODEC_ID_DOLBY_E = 88080,
    AV_CODEC_ID_APTX = 88081,
    AV_CODEC_ID_APTX_HD = 88082,
    AV_CODEC_ID_SBC = 88083,
    AV_CODEC_ID_ATRAC9 = 88084,
    AV_CODEC_ID_HCOM = 88085,
    AV_CODEC_ID_ACELP_KELVIN = 88086,
    AV_CODEC_ID_MPEGH_3D_AUDIO = 88087,
    AV_CODEC_ID_SIREN = 88088,
    AV_CODEC_ID_HCA = 88089,
    AV_CODEC_ID_FASTAUDIO = 88090,
    AV_CODEC_ID_DVD_SUBTITLE = 94208,
    AV_CODEC_ID_DVB_SUBTITLE = 94209,
    #[doc = "< raw UTF-8 text"]
    AV_CODEC_ID_TEXT = 94210,
    AV_CODEC_ID_XSUB = 94211,
    AV_CODEC_ID_SSA = 94212,
    AV_CODEC_ID_MOV_TEXT = 94213,
    AV_CODEC_ID_HDMV_PGS_SUBTITLE = 94214,
    AV_CODEC_ID_DVB_TELETEXT = 94215,
    AV_CODEC_ID_SRT = 94216,
    AV_CODEC_ID_MICRODVD = 96256,
    AV_CODEC_ID_EIA_608 = 96257,
    AV_CODEC_ID_JACOSUB = 96258,
    AV_CODEC_ID_SAMI = 96259,
    AV_CODEC_ID_REALTEXT = 96260,
    AV_CODEC_ID_STL = 96261,
    AV_CODEC_ID_SUBVIEWER1 = 96262,
    AV_CODEC_ID_SUBVIEWER = 96263,
    AV_CODEC_ID_SUBRIP = 96264,
    AV_CODEC_ID_WEBVTT = 96265,
    AV_CODEC_ID_MPL2 = 96266,
    AV_CODEC_ID_VPLAYER = 96267,
    AV_CODEC_ID_PJS = 96268,
    AV_CODEC_ID_ASS = 96269,
    AV_CODEC_ID_HDMV_TEXT_SUBTITLE = 96270,
    AV_CODEC_ID_TTML = 96271,
    AV_CODEC_ID_ARIB_CAPTION = 96272,
    AV_CODEC_ID_TTF = 98304,
    #[doc = "< Contain timestamp estimated through PCR of program stream."]
    AV_CODEC_ID_SCTE_35 = 98305,
    AV_CODEC_ID_EPG = 98306,
    AV_CODEC_ID_BINTEXT = 100352,
    AV_CODEC_ID_XBIN = 100353,
    AV_CODEC_ID_IDF = 100354,
    AV_CODEC_ID_OTF = 100355,
    AV_CODEC_ID_SMPTE_KLV = 100356,
    AV_CODEC_ID_DVD_NAV = 100357,
    AV_CODEC_ID_TIMED_ID3 = 100358,
    AV_CODEC_ID_BIN_DATA = 100359,
    #[doc = "< codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it"]
    AV_CODEC_ID_PROBE = 102400,
    #[doc = "< _FAKE_ codec to indicate a raw MPEG-2 TS\n stream (only used by libavformat)"]
    AV_CODEC_ID_MPEG2TS = 131072,
    #[doc = "< _FAKE_ codec to indicate a MPEG-4 Systems\n stream (only used by libavformat)"]
    AV_CODEC_ID_MPEG4SYSTEMS = 131073,
    #[doc = "< Dummy codec for streams containing only metadata information."]
    AV_CODEC_ID_FFMETADATA = 135168,
    #[doc = "< Passthrough codec, AVFrames wrapped in AVPacket"]
    AV_CODEC_ID_WRAPPED_AVFRAME = 135169,
}
extern "C" {
    #[doc = " Get the type of the given codec."]
    pub fn avcodec_get_type(codec_id: AVCodecID) -> AVMediaType;
}
extern "C" {
    #[doc = " Get the name of a codec.\n @return  a static string identifying the codec; never NULL"]
    pub fn avcodec_get_name(id: AVCodecID) -> *const libc::c_char;
}
#[repr(u32)]
#[doc = " @addtogroup lavc_core"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVFieldOrder {
    AV_FIELD_UNKNOWN = 0,
    AV_FIELD_PROGRESSIVE = 1,
    AV_FIELD_TT = 2,
    AV_FIELD_BB = 3,
    AV_FIELD_TB = 4,
    AV_FIELD_BT = 5,
}
#[doc = " This struct describes the properties of an encoded stream.\n\n sizeof(AVCodecParameters) is not a part of the public ABI, this struct must\n be allocated with avcodec_parameters_alloc() and freed with\n avcodec_parameters_free()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodecParameters {
    #[doc = " General type of the encoded data."]
    pub codec_type: AVMediaType,
    #[doc = " Specific type of the encoded data (the codec used)."]
    pub codec_id: AVCodecID,
    #[doc = " Additional information about the codec (corresponds to the AVI FOURCC)."]
    pub codec_tag: u32,
    #[doc = " Extra binary data needed for initializing the decoder, codec-dependent.\n\n Must be allocated with av_malloc() and will be freed by\n avcodec_parameters_free(). The allocated size of extradata must be at\n least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding\n bytes zeroed."]
    pub extradata: *mut u8,
    #[doc = " Size of the extradata content in bytes."]
    pub extradata_size: libc::c_int,
    #[doc = " - video: the pixel format, the value corresponds to enum AVPixelFormat.\n - audio: the sample format, the value corresponds to enum AVSampleFormat."]
    pub format: libc::c_int,
    #[doc = " The average bitrate of the encoded data (in bits per second)."]
    pub bit_rate: i64,
    #[doc = " The number of bits per sample in the codedwords.\n\n This is basically the bitrate per sample. It is mandatory for a bunch of\n formats to actually decode them. It's the number of bits for one sample in\n the actual coded bitstream.\n\n This could be for example 4 for ADPCM\n For PCM formats this matches bits_per_raw_sample\n Can be 0"]
    pub bits_per_coded_sample: libc::c_int,
    #[doc = " This is the number of valid bits in each output sample. If the\n sample format has more bits, the least significant bits are additional\n padding bits, which are always 0. Use right shifts to reduce the sample\n to its actual size. For example, audio formats with 24 bit samples will\n have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.\n To get the original sample use \"(int32_t)sample >> 8\".\"\n\n For ADPCM this might be 12 or 16 or similar\n Can be 0"]
    pub bits_per_raw_sample: libc::c_int,
    #[doc = " Codec-specific bitstream restrictions that the stream conforms to."]
    pub profile: libc::c_int,
    pub level: libc::c_int,
    #[doc = " Video only. The dimensions of the video frame in pixels."]
    pub width: libc::c_int,
    pub height: libc::c_int,
    #[doc = " Video only. The aspect ratio (width / height) which a single pixel\n should have when displayed.\n\n When the aspect ratio is unknown / undefined, the numerator should be\n set to 0 (the denominator may have any value)."]
    pub sample_aspect_ratio: AVRational,
    #[doc = " Video only. The order of the fields in interlaced video."]
    pub field_order: AVFieldOrder,
    #[doc = " Video only. Additional colorspace characteristics."]
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub color_space: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    #[doc = " Video only. Number of delayed frames."]
    pub video_delay: libc::c_int,
    #[doc = " Audio only. The channel layout bitmask. May be 0 if the channel layout is\n unknown or unspecified, otherwise the number of bits set must be equal to\n the channels field."]
    pub channel_layout: u64,
    #[doc = " Audio only. The number of audio channels."]
    pub channels: libc::c_int,
    #[doc = " Audio only. The number of audio samples per second."]
    pub sample_rate: libc::c_int,
    #[doc = " Audio only. The number of bytes per coded audio frame, required by some\n formats.\n\n Corresponds to nBlockAlign in WAVEFORMATEX."]
    pub block_align: libc::c_int,
    #[doc = " Audio only. Audio frame size, if known. Required by some formats to be static."]
    pub frame_size: libc::c_int,
    #[doc = " Audio only. The amount of padding (in samples) inserted by the encoder at\n the beginning of the audio. I.e. this number of leading decoded samples\n must be discarded by the caller to get the original audio without leading\n padding."]
    pub initial_padding: libc::c_int,
    #[doc = " Audio only. The amount of padding (in samples) appended by the encoder to\n the end of the audio. I.e. this number of decoded samples must be\n discarded by the caller from the end of the stream to get the original\n audio without any trailing padding."]
    pub trailing_padding: libc::c_int,
    #[doc = " Audio only. Number of samples to skip after a discontinuity."]
    pub seek_preroll: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVCodecParameters"][::std::mem::size_of::<AVCodecParameters>() - 144usize];
    ["Alignment of AVCodecParameters"][::std::mem::align_of::<AVCodecParameters>() - 8usize];
    ["Offset of field: AVCodecParameters::codec_type"]
        [::std::mem::offset_of!(AVCodecParameters, codec_type) - 0usize];
    ["Offset of field: AVCodecParameters::codec_id"]
        [::std::mem::offset_of!(AVCodecParameters, codec_id) - 4usize];
    ["Offset of field: AVCodecParameters::codec_tag"]
        [::std::mem::offset_of!(AVCodecParameters, codec_tag) - 8usize];
    ["Offset of field: AVCodecParameters::extradata"]
        [::std::mem::offset_of!(AVCodecParameters, extradata) - 16usize];
    ["Offset of field: AVCodecParameters::extradata_size"]
        [::std::mem::offset_of!(AVCodecParameters, extradata_size) - 24usize];
    ["Offset of field: AVCodecParameters::format"]
        [::std::mem::offset_of!(AVCodecParameters, format) - 28usize];
    ["Offset of field: AVCodecParameters::bit_rate"]
        [::std::mem::offset_of!(AVCodecParameters, bit_rate) - 32usize];
    ["Offset of field: AVCodecParameters::bits_per_coded_sample"]
        [::std::mem::offset_of!(AVCodecParameters, bits_per_coded_sample) - 40usize];
    ["Offset of field: AVCodecParameters::bits_per_raw_sample"]
        [::std::mem::offset_of!(AVCodecParameters, bits_per_raw_sample) - 44usize];
    ["Offset of field: AVCodecParameters::profile"]
        [::std::mem::offset_of!(AVCodecParameters, profile) - 48usize];
    ["Offset of field: AVCodecParameters::level"]
        [::std::mem::offset_of!(AVCodecParameters, level) - 52usize];
    ["Offset of field: AVCodecParameters::width"]
        [::std::mem::offset_of!(AVCodecParameters, width) - 56usize];
    ["Offset of field: AVCodecParameters::height"]
        [::std::mem::offset_of!(AVCodecParameters, height) - 60usize];
    ["Offset of field: AVCodecParameters::sample_aspect_ratio"]
        [::std::mem::offset_of!(AVCodecParameters, sample_aspect_ratio) - 64usize];
    ["Offset of field: AVCodecParameters::field_order"]
        [::std::mem::offset_of!(AVCodecParameters, field_order) - 72usize];
    ["Offset of field: AVCodecParameters::color_range"]
        [::std::mem::offset_of!(AVCodecParameters, color_range) - 76usize];
    ["Offset of field: AVCodecParameters::color_primaries"]
        [::std::mem::offset_of!(AVCodecParameters, color_primaries) - 80usize];
    ["Offset of field: AVCodecParameters::color_trc"]
        [::std::mem::offset_of!(AVCodecParameters, color_trc) - 84usize];
    ["Offset of field: AVCodecParameters::color_space"]
        [::std::mem::offset_of!(AVCodecParameters, color_space) - 88usize];
    ["Offset of field: AVCodecParameters::chroma_location"]
        [::std::mem::offset_of!(AVCodecParameters, chroma_location) - 92usize];
    ["Offset of field: AVCodecParameters::video_delay"]
        [::std::mem::offset_of!(AVCodecParameters, video_delay) - 96usize];
    ["Offset of field: AVCodecParameters::channel_layout"]
        [::std::mem::offset_of!(AVCodecParameters, channel_layout) - 104usize];
    ["Offset of field: AVCodecParameters::channels"]
        [::std::mem::offset_of!(AVCodecParameters, channels) - 112usize];
    ["Offset of field: AVCodecParameters::sample_rate"]
        [::std::mem::offset_of!(AVCodecParameters, sample_rate) - 116usize];
    ["Offset of field: AVCodecParameters::block_align"]
        [::std::mem::offset_of!(AVCodecParameters, block_align) - 120usize];
    ["Offset of field: AVCodecParameters::frame_size"]
        [::std::mem::offset_of!(AVCodecParameters, frame_size) - 124usize];
    ["Offset of field: AVCodecParameters::initial_padding"]
        [::std::mem::offset_of!(AVCodecParameters, initial_padding) - 128usize];
    ["Offset of field: AVCodecParameters::trailing_padding"]
        [::std::mem::offset_of!(AVCodecParameters, trailing_padding) - 132usize];
    ["Offset of field: AVCodecParameters::seek_preroll"]
        [::std::mem::offset_of!(AVCodecParameters, seek_preroll) - 136usize];
};
extern "C" {
    #[doc = " Allocate a new AVCodecParameters and set its fields to default values\n (unknown/invalid/0). The returned struct must be freed with\n avcodec_parameters_free()."]
    pub fn avcodec_parameters_alloc() -> *mut AVCodecParameters;
}
extern "C" {
    #[doc = " Free an AVCodecParameters instance and everything associated with it and\n write NULL to the supplied pointer."]
    pub fn avcodec_parameters_free(par: *mut *mut AVCodecParameters);
}
extern "C" {
    #[doc = " Copy the contents of src to dst. Any allocated fields in dst are freed and\n replaced with newly allocated duplicates of the corresponding fields in src.\n\n @return >= 0 on success, a negative AVERROR code on failure."]
    pub fn avcodec_parameters_copy(
        dst: *mut AVCodecParameters,
        src: *const AVCodecParameters,
    ) -> libc::c_int;
}
#[repr(u32)]
#[doc = " @defgroup lavc_packet AVPacket\n\n Types and functions for working with AVPacket.\n @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVPacketSideDataType {
    #[doc = " An AV_PKT_DATA_PALETTE side data packet contains exactly AVPALETTE_SIZE\n bytes worth of palette. This side data signals that a new palette is\n present."]
    AV_PKT_DATA_PALETTE = 0,
    #[doc = " The AV_PKT_DATA_NEW_EXTRADATA is used to notify the codec or the format\n that the extradata buffer was changed and the receiving side should\n act upon it appropriately. The new extradata is embedded in the side\n data buffer and should be immediately used for processing the current\n frame or packet."]
    AV_PKT_DATA_NEW_EXTRADATA = 1,
    #[doc = " An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:\n @code\n u32le param_flags\n if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT)\n     s32le channel_count\n if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)\n     u64le channel_layout\n if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)\n     s32le sample_rate\n if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)\n     s32le width\n     s32le height\n @endcode"]
    AV_PKT_DATA_PARAM_CHANGE = 2,
    #[doc = " An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of\n structures with info about macroblocks relevant to splitting the\n packet into smaller packets on macroblock edges (e.g. as for RFC 2190).\n That is, it does not necessarily contain info about all macroblocks,\n as long as the distance between macroblocks in the info is smaller\n than the target payload size.\n Each MB info structure is 12 bytes, and is laid out as follows:\n @code\n u32le bit offset from the start of the packet\n u8    current quantizer at the start of the macroblock\n u8    GOB number\n u16le macroblock address within the GOB\n u8    horizontal MV predictor\n u8    vertical MV predictor\n u8    horizontal MV predictor for block number 3\n u8    vertical MV predictor for block number 3\n @endcode"]
    AV_PKT_DATA_H263_MB_INFO = 3,
    #[doc = " This side data should be associated with an audio stream and contains\n ReplayGain information in form of the AVReplayGain struct."]
    AV_PKT_DATA_REPLAYGAIN = 4,
    #[doc = " This side data contains a 3x3 transformation matrix describing an affine\n transformation that needs to be applied to the decoded video frames for\n correct presentation.\n\n See libavutil/display.h for a detailed description of the data."]
    AV_PKT_DATA_DISPLAYMATRIX = 5,
    #[doc = " This side data should be associated with a video stream and contains\n Stereoscopic 3D information in form of the AVStereo3D struct."]
    AV_PKT_DATA_STEREO3D = 6,
    #[doc = " This side data should be associated with an audio stream and corresponds\n to enum AVAudioServiceType."]
    AV_PKT_DATA_AUDIO_SERVICE_TYPE = 7,
    #[doc = " This side data contains quality related information from the encoder.\n @code\n u32le quality factor of the compressed frame. Allowed range is between 1 (good) and FF_LAMBDA_MAX (bad).\n u8    picture type\n u8    error count\n u16   reserved\n u64le[error count] sum of squared differences between encoder in and output\n @endcode"]
    AV_PKT_DATA_QUALITY_STATS = 8,
    #[doc = " This side data contains an integer value representing the stream index\n of a \"fallback\" track.  A fallback track indicates an alternate\n track to use when the current track can not be decoded for some reason.\n e.g. no decoder available for codec."]
    AV_PKT_DATA_FALLBACK_TRACK = 9,
    #[doc = " This side data corresponds to the AVCPBProperties struct."]
    AV_PKT_DATA_CPB_PROPERTIES = 10,
    #[doc = " Recommmends skipping the specified number of samples\n @code\n u32le number of samples to skip from start of this packet\n u32le number of samples to skip from end of this packet\n u8    reason for start skip\n u8    reason for end   skip (0=padding silence, 1=convergence)\n @endcode"]
    AV_PKT_DATA_SKIP_SAMPLES = 11,
    #[doc = " An AV_PKT_DATA_JP_DUALMONO side data packet indicates that\n the packet may contain \"dual mono\" audio specific to Japanese DTV\n and if it is true, recommends only the selected channel to be used.\n @code\n u8    selected channels (0=mail/left, 1=sub/right, 2=both)\n @endcode"]
    AV_PKT_DATA_JP_DUALMONO = 12,
    #[doc = " A list of zero terminated key/value strings. There is no end marker for\n the list, so it is required to rely on the side data size to stop."]
    AV_PKT_DATA_STRINGS_METADATA = 13,
    #[doc = " Subtitle event position\n @code\n u32le x1\n u32le y1\n u32le x2\n u32le y2\n @endcode"]
    AV_PKT_DATA_SUBTITLE_POSITION = 14,
    #[doc = " Data found in BlockAdditional element of matroska container. There is\n no end marker for the data, so it is required to rely on the side data\n size to recognize the end. 8 byte id (as found in BlockAddId) followed\n by data."]
    AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = 15,
    #[doc = " The optional first identifier line of a WebVTT cue."]
    AV_PKT_DATA_WEBVTT_IDENTIFIER = 16,
    #[doc = " The optional settings (rendering instructions) that immediately\n follow the timestamp specifier of a WebVTT cue."]
    AV_PKT_DATA_WEBVTT_SETTINGS = 17,
    #[doc = " A list of zero terminated key/value strings. There is no end marker for\n the list, so it is required to rely on the side data size to stop. This\n side data includes updated metadata which appeared in the stream."]
    AV_PKT_DATA_METADATA_UPDATE = 18,
    #[doc = " MPEGTS stream ID as uint8_t, this is required to pass the stream ID\n information from the demuxer to the corresponding muxer."]
    AV_PKT_DATA_MPEGTS_STREAM_ID = 19,
    #[doc = " Mastering display metadata (based on SMPTE-2086:2014). This metadata\n should be associated with a video stream and contains data in the form\n of the AVMasteringDisplayMetadata struct."]
    AV_PKT_DATA_MASTERING_DISPLAY_METADATA = 20,
    #[doc = " This side data should be associated with a video stream and corresponds\n to the AVSphericalMapping structure."]
    AV_PKT_DATA_SPHERICAL = 21,
    #[doc = " Content light level (based on CTA-861.3). This metadata should be\n associated with a video stream and contains data in the form of the\n AVContentLightMetadata struct."]
    AV_PKT_DATA_CONTENT_LIGHT_LEVEL = 22,
    #[doc = " ATSC A53 Part 4 Closed Captions. This metadata should be associated with\n a video stream. A53 CC bitstream is stored as uint8_t in AVPacketSideData.data.\n The number of bytes of CC data is AVPacketSideData.size."]
    AV_PKT_DATA_A53_CC = 23,
    #[doc = " This side data is encryption initialization data.\n The format is not part of ABI, use av_encryption_init_info_* methods to\n access."]
    AV_PKT_DATA_ENCRYPTION_INIT_INFO = 24,
    #[doc = " This side data contains encryption info for how to decrypt the packet.\n The format is not part of ABI, use av_encryption_info_* methods to access."]
    AV_PKT_DATA_ENCRYPTION_INFO = 25,
    #[doc = " Active Format Description data consisting of a single byte as specified\n in ETSI TS 101 154 using AVActiveFormatDescription enum."]
    AV_PKT_DATA_AFD = 26,
    #[doc = " Producer Reference Time data corresponding to the AVProducerReferenceTime struct,\n usually exported by some encoders (on demand through the prft flag set in the\n AVCodecContext export_side_data field)."]
    AV_PKT_DATA_PRFT = 27,
    #[doc = " ICC profile data consisting of an opaque octet buffer following the\n format described by ISO 15076-1."]
    AV_PKT_DATA_ICC_PROFILE = 28,
    #[doc = " DOVI configuration\n ref:\n dolby-vision-bitstreams-within-the-iso-base-media-file-format-v2.1.2, section 2.2\n dolby-vision-bitstreams-in-mpeg-2-transport-stream-multiplex-v1.2, section 3.3\n Tags are stored in struct AVDOVIDecoderConfigurationRecord."]
    AV_PKT_DATA_DOVI_CONF = 29,
    #[doc = " Timecode which conforms to SMPTE ST 12-1:2014. The data is an array of 4 uint32_t\n where the first uint32_t describes how many (1-3) of the other timecodes are used.\n The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()\n function in libavutil/timecode.h."]
    AV_PKT_DATA_S12M_TIMECODE = 30,
    #[doc = " The number of side data types.\n This is not part of the public API/ABI in the sense that it may\n change when new side data types are added.\n This must stay the last enum value.\n If its value becomes huge, some code using it\n needs to be updated as it assumes it to be smaller than other limits."]
    AV_PKT_DATA_NB = 31,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPacketSideData {
    pub data: *mut u8,
    pub size: libc::c_int,
    pub type_: AVPacketSideDataType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVPacketSideData"][::std::mem::size_of::<AVPacketSideData>() - 16usize];
    ["Alignment of AVPacketSideData"][::std::mem::align_of::<AVPacketSideData>() - 8usize];
    ["Offset of field: AVPacketSideData::data"]
        [::std::mem::offset_of!(AVPacketSideData, data) - 0usize];
    ["Offset of field: AVPacketSideData::size"]
        [::std::mem::offset_of!(AVPacketSideData, size) - 8usize];
    ["Offset of field: AVPacketSideData::type_"]
        [::std::mem::offset_of!(AVPacketSideData, type_) - 12usize];
};
#[doc = " This structure stores compressed data. It is typically exported by demuxers\n and then passed as input to decoders, or received as output from encoders and\n then passed to muxers.\n\n For video, it should typically contain one compressed frame. For audio it may\n contain several compressed frames. Encoders are allowed to output empty\n packets, with no compressed data, containing only side data\n (e.g. to update some stream parameters at the end of encoding).\n\n The semantics of data ownership depends on the buf field.\n If it is set, the packet data is dynamically allocated and is\n valid indefinitely until a call to av_packet_unref() reduces the\n reference count to 0.\n\n If the buf field is not set av_packet_ref() would make a copy instead\n of increasing the reference count.\n\n The side data is always allocated with av_malloc(), copied by\n av_packet_ref() and freed by av_packet_unref().\n\n sizeof(AVPacket) being a part of the public ABI is deprecated. once\n av_init_packet() is removed, new packets will only be able to be allocated\n with av_packet_alloc(), and new fields may be added to the end of the struct\n with a minor bump.\n\n @see av_packet_alloc\n @see av_packet_ref\n @see av_packet_unref"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPacket {
    #[doc = " A reference to the reference-counted buffer where the packet data is\n stored.\n May be NULL, then the packet data is not reference-counted."]
    pub buf: *mut AVBufferRef,
    #[doc = " Presentation timestamp in AVStream->time_base units; the time at which\n the decompressed packet will be presented to the user.\n Can be AV_NOPTS_VALUE if it is not stored in the file.\n pts MUST be larger or equal to dts as presentation cannot happen before\n decompression, unless one wants to view hex dumps. Some formats misuse\n the terms dts and pts/cts to mean something different. Such timestamps\n must be converted to true pts/dts before they are stored in AVPacket."]
    pub pts: i64,
    #[doc = " Decompression timestamp in AVStream->time_base units; the time at which\n the packet is decompressed.\n Can be AV_NOPTS_VALUE if it is not stored in the file."]
    pub dts: i64,
    pub data: *mut u8,
    pub size: libc::c_int,
    pub stream_index: libc::c_int,
    #[doc = " A combination of AV_PKT_FLAG values"]
    pub flags: libc::c_int,
    #[doc = " Additional packet data that can be provided by the container.\n Packet can contain several types of side information."]
    pub side_data: *mut AVPacketSideData,
    pub side_data_elems: libc::c_int,
    #[doc = " Duration of this packet in AVStream->time_base units, 0 if unknown.\n Equals next_pts - this_pts in presentation order."]
    pub duration: i64,
    #[doc = "< byte position in stream, -1 if unknown"]
    pub pos: i64,
    #[doc = " @deprecated Same as the duration field, but as int64_t. This was required\n for Matroska subtitles, whose duration values could overflow when the\n duration field was still an int."]
    pub convergence_duration: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVPacket"][::std::mem::size_of::<AVPacket>() - 88usize];
    ["Alignment of AVPacket"][::std::mem::align_of::<AVPacket>() - 8usize];
    ["Offset of field: AVPacket::buf"][::std::mem::offset_of!(AVPacket, buf) - 0usize];
    ["Offset of field: AVPacket::pts"][::std::mem::offset_of!(AVPacket, pts) - 8usize];
    ["Offset of field: AVPacket::dts"][::std::mem::offset_of!(AVPacket, dts) - 16usize];
    ["Offset of field: AVPacket::data"][::std::mem::offset_of!(AVPacket, data) - 24usize];
    ["Offset of field: AVPacket::size"][::std::mem::offset_of!(AVPacket, size) - 32usize];
    ["Offset of field: AVPacket::stream_index"]
        [::std::mem::offset_of!(AVPacket, stream_index) - 36usize];
    ["Offset of field: AVPacket::flags"][::std::mem::offset_of!(AVPacket, flags) - 40usize];
    ["Offset of field: AVPacket::side_data"][::std::mem::offset_of!(AVPacket, side_data) - 48usize];
    ["Offset of field: AVPacket::side_data_elems"]
        [::std::mem::offset_of!(AVPacket, side_data_elems) - 56usize];
    ["Offset of field: AVPacket::duration"][::std::mem::offset_of!(AVPacket, duration) - 64usize];
    ["Offset of field: AVPacket::pos"][::std::mem::offset_of!(AVPacket, pos) - 72usize];
    ["Offset of field: AVPacket::convergence_duration"]
        [::std::mem::offset_of!(AVPacket, convergence_duration) - 80usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPacketList {
    pub pkt: AVPacket,
    pub next: *mut AVPacketList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVPacketList"][::std::mem::size_of::<AVPacketList>() - 96usize];
    ["Alignment of AVPacketList"][::std::mem::align_of::<AVPacketList>() - 8usize];
    ["Offset of field: AVPacketList::pkt"][::std::mem::offset_of!(AVPacketList, pkt) - 0usize];
    ["Offset of field: AVPacketList::next"][::std::mem::offset_of!(AVPacketList, next) - 88usize];
};
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVSideDataParamChangeFlags {
    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT = 1,
    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 2,
    AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = 4,
    AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = 8,
}
extern "C" {
    #[doc = " Allocate an AVPacket and set its fields to default values.  The resulting\n struct must be freed using av_packet_free().\n\n @return An AVPacket filled with default values or NULL on failure.\n\n @note this only allocates the AVPacket itself, not the data buffers. Those\n must be allocated through other means such as av_new_packet.\n\n @see av_new_packet"]
    pub fn av_packet_alloc() -> *mut AVPacket;
}
extern "C" {
    #[doc = " Create a new packet that references the same data as src.\n\n This is a shortcut for av_packet_alloc()+av_packet_ref().\n\n @return newly created AVPacket on success, NULL on error.\n\n @see av_packet_alloc\n @see av_packet_ref"]
    pub fn av_packet_clone(src: *const AVPacket) -> *mut AVPacket;
}
extern "C" {
    #[doc = " Free the packet, if the packet is reference counted, it will be\n unreferenced first.\n\n @param pkt packet to be freed. The pointer will be set to NULL.\n @note passing NULL is a no-op."]
    pub fn av_packet_free(pkt: *mut *mut AVPacket);
}
extern "C" {
    #[doc = " Initialize optional fields of a packet with default values.\n\n Note, this does not touch the data and size members, which have to be\n initialized separately.\n\n @param pkt packet\n\n @see av_packet_alloc\n @see av_packet_unref\n\n @deprecated This function is deprecated. Once it's removed,\nsizeof(AVPacket) will not be a part of the ABI anymore."]
    pub fn av_init_packet(pkt: *mut AVPacket);
}
extern "C" {
    #[doc = " Allocate the payload of a packet and initialize its fields with\n default values.\n\n @param pkt packet\n @param size wanted payload size\n @return 0 if OK, AVERROR_xxx otherwise"]
    pub fn av_new_packet(pkt: *mut AVPacket, size: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Reduce packet size, correctly zeroing padding\n\n @param pkt packet\n @param size new size"]
    pub fn av_shrink_packet(pkt: *mut AVPacket, size: libc::c_int);
}
extern "C" {
    #[doc = " Increase packet size, correctly zeroing padding\n\n @param pkt packet\n @param grow_by number of bytes by which to increase the size of the packet"]
    pub fn av_grow_packet(pkt: *mut AVPacket, grow_by: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Initialize a reference-counted packet from av_malloc()ed data.\n\n @param pkt packet to be initialized. This function will set the data, size,\n        and buf fields, all others are left untouched.\n @param data Data allocated by av_malloc() to be used as packet data. If this\n        function returns successfully, the data is owned by the underlying AVBuffer.\n        The caller may not access the data through other means.\n @param size size of data in bytes, without the padding. I.e. the full buffer\n        size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.\n\n @return 0 on success, a negative AVERROR on error"]
    pub fn av_packet_from_data(pkt: *mut AVPacket, data: *mut u8, size: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    #[doc = " @warning This is a hack - the packet memory allocation stuff is broken. The\n packet is allocated if it was not really allocated.\n\n @deprecated Use av_packet_ref or av_packet_make_refcounted"]
    pub fn av_dup_packet(pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy packet, including contents\n\n @return 0 on success, negative AVERROR on fail\n\n @deprecated Use av_packet_ref"]
    pub fn av_copy_packet(dst: *mut AVPacket, src: *const AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy packet side data\n\n @return 0 on success, negative AVERROR on fail\n\n @deprecated Use av_packet_copy_props"]
    pub fn av_copy_packet_side_data(dst: *mut AVPacket, src: *const AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Free a packet.\n\n @deprecated Use av_packet_unref\n\n @param pkt packet to free"]
    pub fn av_free_packet(pkt: *mut AVPacket);
}
extern "C" {
    #[doc = " Allocate new information of a packet.\n\n @param pkt packet\n @param type side information type\n @param size side information size\n @return pointer to fresh allocated data or NULL otherwise"]
    pub fn av_packet_new_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: libc::c_int,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Wrap an existing array as a packet side data.\n\n @param pkt packet\n @param type side information type\n @param data the side data array. It must be allocated with the av_malloc()\n             family of functions. The ownership of the data is transferred to\n             pkt.\n @param size side information size\n @return a non-negative number on success, a negative AVERROR code on\n         failure. On failure, the packet is unchanged and the data remains\n         owned by the caller."]
    pub fn av_packet_add_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        data: *mut u8,
        size: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Shrink the already allocated side data buffer\n\n @param pkt packet\n @param type side information type\n @param size new side information size\n @return 0 on success, < 0 on failure"]
    pub fn av_packet_shrink_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get side information from packet.\n\n @param pkt packet\n @param type desired side information type\n @param size If supplied, *size will be set to the size of the side data\n             or to zero if the desired side data is not present.\n @return pointer to data if present or NULL otherwise"]
    pub fn av_packet_get_side_data(
        pkt: *const AVPacket,
        type_: AVPacketSideDataType,
        size: *mut libc::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_packet_merge_side_data(pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    pub fn av_packet_split_side_data(pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    pub fn av_packet_side_data_name(type_: AVPacketSideDataType) -> *const libc::c_char;
}
extern "C" {
    pub fn av_packet_pack_dictionary(dict: *mut AVDictionary, size: *mut libc::c_int) -> *mut u8;
}
extern "C" {
    pub fn av_packet_unpack_dictionary(
        data: *const u8,
        size: libc::c_int,
        dict: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Convenience function to free all the side data stored.\n All the other fields stay untouched.\n\n @param pkt packet"]
    pub fn av_packet_free_side_data(pkt: *mut AVPacket);
}
extern "C" {
    #[doc = " Setup a new reference to the data described by a given packet\n\n If src is reference-counted, setup dst as a new reference to the\n buffer in src. Otherwise allocate a new buffer in dst and copy the\n data from src into it.\n\n All the other fields are copied from src.\n\n @see av_packet_unref\n\n @param dst Destination packet. Will be completely overwritten.\n @param src Source packet\n\n @return 0 on success, a negative AVERROR on error. On error, dst\n         will be blank (as if returned by av_packet_alloc())."]
    pub fn av_packet_ref(dst: *mut AVPacket, src: *const AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Wipe the packet.\n\n Unreference the buffer referenced by the packet and reset the\n remaining packet fields to their default values.\n\n @param pkt The packet to be unreferenced."]
    pub fn av_packet_unref(pkt: *mut AVPacket);
}
extern "C" {
    #[doc = " Move every field in src to dst and reset src.\n\n @see av_packet_unref\n\n @param src Source packet, will be reset\n @param dst Destination packet"]
    pub fn av_packet_move_ref(dst: *mut AVPacket, src: *mut AVPacket);
}
extern "C" {
    #[doc = " Copy only \"properties\" fields from src to dst.\n\n Properties for the purpose of this function are all the fields\n beside those related to the packet data (buf, data, size)\n\n @param dst Destination packet\n @param src Source packet\n\n @return 0 on success AVERROR on failure."]
    pub fn av_packet_copy_props(dst: *mut AVPacket, src: *const AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Ensure the data described by a given packet is reference counted.\n\n @note This function does not ensure that the reference will be writable.\n       Use av_packet_make_writable instead for that purpose.\n\n @see av_packet_ref\n @see av_packet_make_writable\n\n @param pkt packet whose data should be made reference counted.\n\n @return 0 on success, a negative AVERROR on error. On failure, the\n         packet is unchanged."]
    pub fn av_packet_make_refcounted(pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Create a writable reference for the data described by a given packet,\n avoiding data copy if possible.\n\n @param pkt Packet whose data should be made writable.\n\n @return 0 on success, a negative AVERROR on failure. On failure, the\n         packet is unchanged."]
    pub fn av_packet_make_writable(pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Convert valid timing fields (timestamps / durations) in a packet from one\n timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be\n ignored.\n\n @param pkt packet on which the conversion will be performed\n @param tb_src source timebase, in which the timing fields in pkt are\n               expressed\n @param tb_dst destination timebase, to which the timing fields will be\n               converted"]
    pub fn av_packet_rescale_ts(pkt: *mut AVPacket, tb_src: AVRational, tb_dst: AVRational);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFInternal {
    _unused: [u8; 0],
}
#[doc = " The bitstream filter state.\n\n This struct must be allocated with av_bsf_alloc() and freed with\n av_bsf_free().\n\n The fields in the struct will only be changed (by the caller or by the\n filter) as described in their documentation, and are to be considered\n immutable otherwise."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVBSFContext {
    #[doc = " A class for logging and AVOptions"]
    pub av_class: *const AVClass,
    #[doc = " The bitstream filter this context is an instance of."]
    pub filter: *const AVBitStreamFilter,
    #[doc = " Opaque libavcodec internal data. Must not be touched by the caller in any\n way."]
    pub internal: *mut AVBSFInternal,
    #[doc = " Opaque filter-specific private data. If filter->priv_class is non-NULL,\n this is an AVOptions-enabled struct."]
    pub priv_data: *mut libc::c_void,
    #[doc = " Parameters of the input stream. This field is allocated in\n av_bsf_alloc(), it needs to be filled by the caller before\n av_bsf_init()."]
    pub par_in: *mut AVCodecParameters,
    #[doc = " Parameters of the output stream. This field is allocated in\n av_bsf_alloc(), it is set by the filter in av_bsf_init()."]
    pub par_out: *mut AVCodecParameters,
    #[doc = " The timebase used for the timestamps of the input packets. Set by the\n caller before av_bsf_init()."]
    pub time_base_in: AVRational,
    #[doc = " The timebase used for the timestamps of the output packets. Set by the\n filter in av_bsf_init()."]
    pub time_base_out: AVRational,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVBSFContext"][::std::mem::size_of::<AVBSFContext>() - 64usize];
    ["Alignment of AVBSFContext"][::std::mem::align_of::<AVBSFContext>() - 8usize];
    ["Offset of field: AVBSFContext::av_class"]
        [::std::mem::offset_of!(AVBSFContext, av_class) - 0usize];
    ["Offset of field: AVBSFContext::filter"]
        [::std::mem::offset_of!(AVBSFContext, filter) - 8usize];
    ["Offset of field: AVBSFContext::internal"]
        [::std::mem::offset_of!(AVBSFContext, internal) - 16usize];
    ["Offset of field: AVBSFContext::priv_data"]
        [::std::mem::offset_of!(AVBSFContext, priv_data) - 24usize];
    ["Offset of field: AVBSFContext::par_in"]
        [::std::mem::offset_of!(AVBSFContext, par_in) - 32usize];
    ["Offset of field: AVBSFContext::par_out"]
        [::std::mem::offset_of!(AVBSFContext, par_out) - 40usize];
    ["Offset of field: AVBSFContext::time_base_in"]
        [::std::mem::offset_of!(AVBSFContext, time_base_in) - 48usize];
    ["Offset of field: AVBSFContext::time_base_out"]
        [::std::mem::offset_of!(AVBSFContext, time_base_out) - 56usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVBitStreamFilter {
    pub name: *const libc::c_char,
    #[doc = " A list of codec ids supported by the filter, terminated by\n AV_CODEC_ID_NONE.\n May be NULL, in that case the bitstream filter works with any codec id."]
    pub codec_ids: *const AVCodecID,
    #[doc = " A class for the private data, used to declare bitstream filter private\n AVOptions. This field is NULL for bitstream filters that do not declare\n any options.\n\n If this field is non-NULL, the first member of the filter private data\n must be a pointer to AVClass, which will be set by libavcodec generic\n code to this class."]
    pub priv_class: *const AVClass,
    #[doc = " No fields below this line are part of the public API. They\n may not be used outside of libavcodec and can be changed and\n removed at will.\n New public fields should be added right above.\n"]
    pub priv_data_size: libc::c_int,
    pub init: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVBSFContext) -> libc::c_int>,
    pub filter: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut AVBSFContext, pkt: *mut AVPacket) -> libc::c_int,
    >,
    pub close: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVBSFContext)>,
    pub flush: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVBSFContext)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVBitStreamFilter"][::std::mem::size_of::<AVBitStreamFilter>() - 64usize];
    ["Alignment of AVBitStreamFilter"][::std::mem::align_of::<AVBitStreamFilter>() - 8usize];
    ["Offset of field: AVBitStreamFilter::name"]
        [::std::mem::offset_of!(AVBitStreamFilter, name) - 0usize];
    ["Offset of field: AVBitStreamFilter::codec_ids"]
        [::std::mem::offset_of!(AVBitStreamFilter, codec_ids) - 8usize];
    ["Offset of field: AVBitStreamFilter::priv_class"]
        [::std::mem::offset_of!(AVBitStreamFilter, priv_class) - 16usize];
    ["Offset of field: AVBitStreamFilter::priv_data_size"]
        [::std::mem::offset_of!(AVBitStreamFilter, priv_data_size) - 24usize];
    ["Offset of field: AVBitStreamFilter::init"]
        [::std::mem::offset_of!(AVBitStreamFilter, init) - 32usize];
    ["Offset of field: AVBitStreamFilter::filter"]
        [::std::mem::offset_of!(AVBitStreamFilter, filter) - 40usize];
    ["Offset of field: AVBitStreamFilter::close"]
        [::std::mem::offset_of!(AVBitStreamFilter, close) - 48usize];
    ["Offset of field: AVBitStreamFilter::flush"]
        [::std::mem::offset_of!(AVBitStreamFilter, flush) - 56usize];
};
extern "C" {
    #[doc = " @return a bitstream filter with the specified name or NULL if no such\n         bitstream filter exists."]
    pub fn av_bsf_get_by_name(name: *const libc::c_char) -> *const AVBitStreamFilter;
}
extern "C" {
    #[doc = " Iterate over all registered bitstream filters.\n\n @param opaque a pointer where libavcodec will store the iteration state. Must\n               point to NULL to start the iteration.\n\n @return the next registered bitstream filter or NULL when the iteration is\n         finished"]
    pub fn av_bsf_iterate(opaque: *mut *mut libc::c_void) -> *const AVBitStreamFilter;
}
extern "C" {
    #[doc = " Allocate a context for a given bitstream filter. The caller must fill in the\n context parameters as described in the documentation and then call\n av_bsf_init() before sending any data to the filter.\n\n @param filter the filter for which to allocate an instance.\n @param ctx a pointer into which the pointer to the newly-allocated context\n            will be written. It must be freed with av_bsf_free() after the\n            filtering is done.\n\n @return 0 on success, a negative AVERROR code on failure"]
    pub fn av_bsf_alloc(
        filter: *const AVBitStreamFilter,
        ctx: *mut *mut AVBSFContext,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Prepare the filter for use, after all the parameters and options have been\n set."]
    pub fn av_bsf_init(ctx: *mut AVBSFContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Submit a packet for filtering.\n\n After sending each packet, the filter must be completely drained by calling\n av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or\n AVERROR_EOF.\n\n @param pkt the packet to filter. The bitstream filter will take ownership of\n the packet and reset the contents of pkt. pkt is not touched if an error occurs.\n If pkt is empty (i.e. NULL, or pkt->data is NULL and pkt->side_data_elems zero),\n it signals the end of the stream (i.e. no more non-empty packets will be sent;\n sending more empty packets does nothing) and will cause the filter to output\n any packets it may have buffered internally.\n\n @return 0 on success. AVERROR(EAGAIN) if packets need to be retrieved from the\n filter (using av_bsf_receive_packet()) before new input can be consumed. Another\n negative AVERROR value if an error occurs."]
    pub fn av_bsf_send_packet(ctx: *mut AVBSFContext, pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Retrieve a filtered packet.\n\n @param[out] pkt this struct will be filled with the contents of the filtered\n                 packet. It is owned by the caller and must be freed using\n                 av_packet_unref() when it is no longer needed.\n                 This parameter should be \"clean\" (i.e. freshly allocated\n                 with av_packet_alloc() or unreffed with av_packet_unref())\n                 when this function is called. If this function returns\n                 successfully, the contents of pkt will be completely\n                 overwritten by the returned data. On failure, pkt is not\n                 touched.\n\n @return 0 on success. AVERROR(EAGAIN) if more packets need to be sent to the\n filter (using av_bsf_send_packet()) to get more output. AVERROR_EOF if there\n will be no further output from the filter. Another negative AVERROR value if\n an error occurs.\n\n @note one input packet may result in several output packets, so after sending\n a packet with av_bsf_send_packet(), this function needs to be called\n repeatedly until it stops returning 0. It is also possible for a filter to\n output fewer packets than were sent to it, so this function may return\n AVERROR(EAGAIN) immediately after a successful av_bsf_send_packet() call."]
    pub fn av_bsf_receive_packet(ctx: *mut AVBSFContext, pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Reset the internal bitstream filter state. Should be called e.g. when seeking."]
    pub fn av_bsf_flush(ctx: *mut AVBSFContext);
}
extern "C" {
    #[doc = " Free a bitstream filter context and everything associated with it; write NULL\n into the supplied pointer."]
    pub fn av_bsf_free(ctx: *mut *mut AVBSFContext);
}
extern "C" {
    #[doc = " Get the AVClass for AVBSFContext. It can be used in combination with\n AV_OPT_SEARCH_FAKE_OBJ for examining options.\n\n @see av_opt_find()."]
    pub fn av_bsf_get_class() -> *const AVClass;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFList {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate empty list of bitstream filters.\n The list must be later freed by av_bsf_list_free()\n or finalized by av_bsf_list_finalize().\n\n @return Pointer to @ref AVBSFList on success, NULL in case of failure"]
    pub fn av_bsf_list_alloc() -> *mut AVBSFList;
}
extern "C" {
    #[doc = " Free list of bitstream filters.\n\n @param lst Pointer to pointer returned by av_bsf_list_alloc()"]
    pub fn av_bsf_list_free(lst: *mut *mut AVBSFList);
}
extern "C" {
    #[doc = " Append bitstream filter to the list of bitstream filters.\n\n @param lst List to append to\n @param bsf Filter context to be appended\n\n @return >=0 on success, negative AVERROR in case of failure"]
    pub fn av_bsf_list_append(lst: *mut AVBSFList, bsf: *mut AVBSFContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Construct new bitstream filter context given it's name and options\n and append it to the list of bitstream filters.\n\n @param lst      List to append to\n @param bsf_name Name of the bitstream filter\n @param options  Options for the bitstream filter, can be set to NULL\n\n @return >=0 on success, negative AVERROR in case of failure"]
    pub fn av_bsf_list_append2(
        lst: *mut AVBSFList,
        bsf_name: *const libc::c_char,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Finalize list of bitstream filters.\n\n This function will transform @ref AVBSFList to single @ref AVBSFContext,\n so the whole chain of bitstream filters can be treated as single filter\n freshly allocated by av_bsf_alloc().\n If the call is successful, @ref AVBSFList structure is freed and lst\n will be set to NULL. In case of failure, caller is responsible for\n freeing the structure by av_bsf_list_free()\n\n @param      lst Filter list structure to be transformed\n @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure\n                 representing the chain of bitstream filters\n\n @return >=0 on success, negative AVERROR in case of failure"]
    pub fn av_bsf_list_finalize(
        lst: *mut *mut AVBSFList,
        bsf: *mut *mut AVBSFContext,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Parse string describing list of bitstream filters and create single\n @ref AVBSFContext describing the whole chain of bitstream filters.\n Resulting @ref AVBSFContext can be treated as any other @ref AVBSFContext freshly\n allocated by av_bsf_alloc().\n\n @param      str String describing chain of bitstream filters in format\n                 `bsf1[=opt1=val1:opt2=val2][,bsf2]`\n @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure\n                 representing the chain of bitstream filters\n\n @return >=0 on success, negative AVERROR in case of failure"]
    pub fn av_bsf_list_parse_str(
        str_: *const libc::c_char,
        bsf: *mut *mut AVBSFContext,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get null/pass-through bitstream filter.\n\n @param[out] bsf Pointer to be set to new instance of pass-through bitstream filter\n\n @return"]
    pub fn av_bsf_get_null_filter(bsf: *mut *mut AVBSFContext) -> libc::c_int;
}
#[doc = " AVProfile."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVProfile {
    pub profile: libc::c_int,
    #[doc = "< short name for the profile"]
    pub name: *const libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVProfile"][::std::mem::size_of::<AVProfile>() - 16usize];
    ["Alignment of AVProfile"][::std::mem::align_of::<AVProfile>() - 8usize];
    ["Offset of field: AVProfile::profile"][::std::mem::offset_of!(AVProfile, profile) - 0usize];
    ["Offset of field: AVProfile::name"][::std::mem::offset_of!(AVProfile, name) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecDefault {
    _unused: [u8; 0],
}
#[doc = " AVCodec."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodec {
    #[doc = " Name of the codec implementation.\n The name is globally unique among encoders and among decoders (but an\n encoder and a decoder can share the same name).\n This is the primary way to find a codec from the user perspective."]
    pub name: *const libc::c_char,
    #[doc = " Descriptive name for the codec, meant to be more human readable than name.\n You should use the NULL_IF_CONFIG_SMALL() macro to define it."]
    pub long_name: *const libc::c_char,
    pub type_: AVMediaType,
    pub id: AVCodecID,
    #[doc = " Codec capabilities.\n see AV_CODEC_CAP_*"]
    pub capabilities: libc::c_int,
    #[doc = "< array of supported framerates, or NULL if any, array is terminated by {0,0}"]
    pub supported_framerates: *const AVRational,
    #[doc = "< array of supported pixel formats, or NULL if unknown, array is terminated by -1"]
    pub pix_fmts: *const AVPixelFormat,
    #[doc = "< array of supported audio samplerates, or NULL if unknown, array is terminated by 0"]
    pub supported_samplerates: *const libc::c_int,
    #[doc = "< array of supported sample formats, or NULL if unknown, array is terminated by -1"]
    pub sample_fmts: *const AVSampleFormat,
    #[doc = "< array of support channel layouts, or NULL if unknown. array is terminated by 0"]
    pub channel_layouts: *const u64,
    #[doc = "< maximum value for lowres supported by the decoder"]
    pub max_lowres: u8,
    #[doc = "< AVClass for the private context"]
    pub priv_class: *const AVClass,
    #[doc = "< array of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN}"]
    pub profiles: *const AVProfile,
    #[doc = " Group name of the codec implementation.\n This is a short symbolic name of the wrapper backing this codec. A\n wrapper uses some kind of external implementation for the codec, such\n as an external library, or a codec implementation provided by the OS or\n the hardware.\n If this field is NULL, this is a builtin, libavcodec native codec.\n If non-NULL, this will be the suffix in AVCodec.name in most cases\n (usually AVCodec.name will be of the form \"<codec_name>_<wrapper_name>\")."]
    pub wrapper_name: *const libc::c_char,
    #[doc = " No fields below this line are part of the public API. They\n may not be used outside of libavcodec and can be changed and\n removed at will.\n New public fields should be added right above.\n"]
    pub priv_data_size: libc::c_int,
    pub next: *mut AVCodec,
    #[doc = " @name Frame-level threading support functions\n @{\n/\n/**\n Copy necessary context variables from a previous thread context to the current one.\n If not defined, the next thread will start automatically; otherwise, the codec\n must call ff_thread_finish_setup().\n\n dst and src will (rarely) point to the same context, in which case memcpy should be skipped."]
    pub update_thread_context: ::std::option::Option<
        unsafe extern "C" fn(dst: *mut AVCodecContext, src: *const AVCodecContext) -> libc::c_int,
    >,
    #[doc = " Private codec-specific defaults."]
    pub defaults: *const AVCodecDefault,
    #[doc = " Initialize codec static data, called from av_codec_iterate().\n\n This is not intended for time consuming operations as it is\n run for every codec regardless of that codec being used."]
    pub init_static_data: ::std::option::Option<unsafe extern "C" fn(codec: *mut AVCodec)>,
    pub init: ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVCodecContext) -> libc::c_int>,
    pub encode_sub: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVCodecContext,
            buf: *mut u8,
            buf_size: libc::c_int,
            sub: *const AVSubtitle,
        ) -> libc::c_int,
    >,
    #[doc = " Encode data to an AVPacket.\n\n @param      avctx          codec context\n @param      avpkt          output AVPacket\n @param[in]  frame          AVFrame containing the raw data to be encoded\n @param[out] got_packet_ptr encoder sets to 0 or 1 to indicate that a\n                            non-empty packet was returned in avpkt.\n @return 0 on success, negative error code on failure"]
    pub encode2: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            avpkt: *mut AVPacket,
            frame: *const AVFrame,
            got_packet_ptr: *mut libc::c_int,
        ) -> libc::c_int,
    >,
    #[doc = " Decode picture or subtitle data.\n\n @param      avctx          codec context\n @param      outdata        codec type dependent output struct\n @param[out] got_frame_ptr  decoder sets to 0 or 1 to indicate that a\n                            non-empty frame or subtitle was returned in\n                            outdata.\n @param[in]  avpkt          AVPacket containing the data to be decoded\n @return amount of bytes read from the packet on success, negative error\n         code on failure"]
    pub decode: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            outdata: *mut libc::c_void,
            got_frame_ptr: *mut libc::c_int,
            avpkt: *mut AVPacket,
        ) -> libc::c_int,
    >,
    pub close:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVCodecContext) -> libc::c_int>,
    #[doc = " Encode API with decoupled frame/packet dataflow. This function is called\n to get one output packet. It should call ff_encode_get_frame() to obtain\n input data."]
    pub receive_packet: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, avpkt: *mut AVPacket) -> libc::c_int,
    >,
    #[doc = " Decode API with decoupled packet/frame dataflow. This function is called\n to get one output frame. It should call ff_decode_get_packet() to obtain\n input data."]
    pub receive_frame: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, frame: *mut AVFrame) -> libc::c_int,
    >,
    #[doc = " Flush buffers.\n Will be called when seeking"]
    pub flush: ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVCodecContext)>,
    #[doc = " Internal codec capabilities.\n See FF_CODEC_CAP_* in internal.h"]
    pub caps_internal: libc::c_int,
    #[doc = " Decoding only, a comma-separated list of bitstream filters to apply to\n packets before decoding."]
    pub bsfs: *const libc::c_char,
    #[doc = " Array of pointers to hardware configurations supported by the codec,\n or NULL if no hardware supported.  The array is terminated by a NULL\n pointer.\n\n The user can only access this field via avcodec_get_hw_config()."]
    pub hw_configs: *const *mut AVCodecHWConfigInternal,
    #[doc = " List of supported codec_tags, terminated by FF_CODEC_TAGS_END."]
    pub codec_tags: *const u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVCodec"][::std::mem::size_of::<AVCodec>() - 240usize];
    ["Alignment of AVCodec"][::std::mem::align_of::<AVCodec>() - 8usize];
    ["Offset of field: AVCodec::name"][::std::mem::offset_of!(AVCodec, name) - 0usize];
    ["Offset of field: AVCodec::long_name"][::std::mem::offset_of!(AVCodec, long_name) - 8usize];
    ["Offset of field: AVCodec::type_"][::std::mem::offset_of!(AVCodec, type_) - 16usize];
    ["Offset of field: AVCodec::id"][::std::mem::offset_of!(AVCodec, id) - 20usize];
    ["Offset of field: AVCodec::capabilities"]
        [::std::mem::offset_of!(AVCodec, capabilities) - 24usize];
    ["Offset of field: AVCodec::supported_framerates"]
        [::std::mem::offset_of!(AVCodec, supported_framerates) - 32usize];
    ["Offset of field: AVCodec::pix_fmts"][::std::mem::offset_of!(AVCodec, pix_fmts) - 40usize];
    ["Offset of field: AVCodec::supported_samplerates"]
        [::std::mem::offset_of!(AVCodec, supported_samplerates) - 48usize];
    ["Offset of field: AVCodec::sample_fmts"]
        [::std::mem::offset_of!(AVCodec, sample_fmts) - 56usize];
    ["Offset of field: AVCodec::channel_layouts"]
        [::std::mem::offset_of!(AVCodec, channel_layouts) - 64usize];
    ["Offset of field: AVCodec::max_lowres"][::std::mem::offset_of!(AVCodec, max_lowres) - 72usize];
    ["Offset of field: AVCodec::priv_class"][::std::mem::offset_of!(AVCodec, priv_class) - 80usize];
    ["Offset of field: AVCodec::profiles"][::std::mem::offset_of!(AVCodec, profiles) - 88usize];
    ["Offset of field: AVCodec::wrapper_name"]
        [::std::mem::offset_of!(AVCodec, wrapper_name) - 96usize];
    ["Offset of field: AVCodec::priv_data_size"]
        [::std::mem::offset_of!(AVCodec, priv_data_size) - 104usize];
    ["Offset of field: AVCodec::next"][::std::mem::offset_of!(AVCodec, next) - 112usize];
    ["Offset of field: AVCodec::update_thread_context"]
        [::std::mem::offset_of!(AVCodec, update_thread_context) - 120usize];
    ["Offset of field: AVCodec::defaults"][::std::mem::offset_of!(AVCodec, defaults) - 128usize];
    ["Offset of field: AVCodec::init_static_data"]
        [::std::mem::offset_of!(AVCodec, init_static_data) - 136usize];
    ["Offset of field: AVCodec::init"][::std::mem::offset_of!(AVCodec, init) - 144usize];
    ["Offset of field: AVCodec::encode_sub"]
        [::std::mem::offset_of!(AVCodec, encode_sub) - 152usize];
    ["Offset of field: AVCodec::encode2"][::std::mem::offset_of!(AVCodec, encode2) - 160usize];
    ["Offset of field: AVCodec::decode"][::std::mem::offset_of!(AVCodec, decode) - 168usize];
    ["Offset of field: AVCodec::close"][::std::mem::offset_of!(AVCodec, close) - 176usize];
    ["Offset of field: AVCodec::receive_packet"]
        [::std::mem::offset_of!(AVCodec, receive_packet) - 184usize];
    ["Offset of field: AVCodec::receive_frame"]
        [::std::mem::offset_of!(AVCodec, receive_frame) - 192usize];
    ["Offset of field: AVCodec::flush"][::std::mem::offset_of!(AVCodec, flush) - 200usize];
    ["Offset of field: AVCodec::caps_internal"]
        [::std::mem::offset_of!(AVCodec, caps_internal) - 208usize];
    ["Offset of field: AVCodec::bsfs"][::std::mem::offset_of!(AVCodec, bsfs) - 216usize];
    ["Offset of field: AVCodec::hw_configs"]
        [::std::mem::offset_of!(AVCodec, hw_configs) - 224usize];
    ["Offset of field: AVCodec::codec_tags"]
        [::std::mem::offset_of!(AVCodec, codec_tags) - 232usize];
};
extern "C" {
    #[doc = " Iterate over all registered codecs.\n\n @param opaque a pointer where libavcodec will store the iteration state. Must\n               point to NULL to start the iteration.\n\n @return the next registered codec or NULL when the iteration is\n         finished"]
    pub fn av_codec_iterate(opaque: *mut *mut libc::c_void) -> *const AVCodec;
}
extern "C" {
    #[doc = " Find a registered decoder with a matching codec ID.\n\n @param id AVCodecID of the requested decoder\n @return A decoder if one was found, NULL otherwise."]
    pub fn avcodec_find_decoder(id: AVCodecID) -> *mut AVCodec;
}
extern "C" {
    #[doc = " Find a registered decoder with the specified name.\n\n @param name name of the requested decoder\n @return A decoder if one was found, NULL otherwise."]
    pub fn avcodec_find_decoder_by_name(name: *const libc::c_char) -> *mut AVCodec;
}
extern "C" {
    #[doc = " Find a registered encoder with a matching codec ID.\n\n @param id AVCodecID of the requested encoder\n @return An encoder if one was found, NULL otherwise."]
    pub fn avcodec_find_encoder(id: AVCodecID) -> *mut AVCodec;
}
extern "C" {
    #[doc = " Find a registered encoder with the specified name.\n\n @param name name of the requested encoder\n @return An encoder if one was found, NULL otherwise."]
    pub fn avcodec_find_encoder_by_name(name: *const libc::c_char) -> *mut AVCodec;
}
extern "C" {
    #[doc = " @return a non-zero number if codec is an encoder, zero otherwise"]
    pub fn av_codec_is_encoder(codec: *const AVCodec) -> libc::c_int;
}
extern "C" {
    #[doc = " @return a non-zero number if codec is a decoder, zero otherwise"]
    pub fn av_codec_is_decoder(codec: *const AVCodec) -> libc::c_int;
}
pub const AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX: _bindgen_ty_4 =
    _bindgen_ty_4::AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX;
pub const AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX: _bindgen_ty_4 =
    _bindgen_ty_4::AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX;
pub const AV_CODEC_HW_CONFIG_METHOD_INTERNAL: _bindgen_ty_4 =
    _bindgen_ty_4::AV_CODEC_HW_CONFIG_METHOD_INTERNAL;
pub const AV_CODEC_HW_CONFIG_METHOD_AD_HOC: _bindgen_ty_4 =
    _bindgen_ty_4::AV_CODEC_HW_CONFIG_METHOD_AD_HOC;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_4 {
    #[doc = " The codec supports this format via the hw_device_ctx interface.\n\n When selecting this format, AVCodecContext.hw_device_ctx should\n have been set to a device of the specified type before calling\n avcodec_open2()."]
    AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX = 1,
    #[doc = " The codec supports this format via the hw_frames_ctx interface.\n\n When selecting this format for a decoder,\n AVCodecContext.hw_frames_ctx should be set to a suitable frames\n context inside the get_format() callback.  The frames context\n must have been created on a device of the specified type.\n\n When selecting this format for an encoder,\n AVCodecContext.hw_frames_ctx should be set to the context which\n will be used for the input frames before calling avcodec_open2()."]
    AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX = 2,
    #[doc = " The codec supports this format by some internal method.\n\n This format can be selected without any additional configuration -\n no device or frames context is required."]
    AV_CODEC_HW_CONFIG_METHOD_INTERNAL = 4,
    #[doc = " The codec supports this format by some ad-hoc method.\n\n Additional settings and/or function calls are required.  See the\n codec-specific documentation for details.  (Methods requiring\n this sort of configuration are deprecated and others should be\n used in preference.)"]
    AV_CODEC_HW_CONFIG_METHOD_AD_HOC = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodecHWConfig {
    #[doc = " For decoders, a hardware pixel format which that decoder may be\n able to decode to if suitable hardware is available.\n\n For encoders, a pixel format which the encoder may be able to\n accept.  If set to AV_PIX_FMT_NONE, this applies to all pixel\n formats supported by the codec."]
    pub pix_fmt: AVPixelFormat,
    #[doc = " Bit set of AV_CODEC_HW_CONFIG_METHOD_* flags, describing the possible\n setup methods which can be used with this configuration."]
    pub methods: libc::c_int,
    #[doc = " The device type associated with the configuration.\n\n Must be set for AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX and\n AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX, otherwise unused."]
    pub device_type: AVHWDeviceType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVCodecHWConfig"][::std::mem::size_of::<AVCodecHWConfig>() - 12usize];
    ["Alignment of AVCodecHWConfig"][::std::mem::align_of::<AVCodecHWConfig>() - 4usize];
    ["Offset of field: AVCodecHWConfig::pix_fmt"]
        [::std::mem::offset_of!(AVCodecHWConfig, pix_fmt) - 0usize];
    ["Offset of field: AVCodecHWConfig::methods"]
        [::std::mem::offset_of!(AVCodecHWConfig, methods) - 4usize];
    ["Offset of field: AVCodecHWConfig::device_type"]
        [::std::mem::offset_of!(AVCodecHWConfig, device_type) - 8usize];
};
extern "C" {
    #[doc = " Retrieve supported hardware configurations for a codec.\n\n Values of index from zero to some maximum return the indexed configuration\n descriptor; all other values return NULL.  If the codec does not support\n any hardware configurations then it will always return NULL."]
    pub fn avcodec_get_hw_config(
        codec: *const AVCodec,
        index: libc::c_int,
    ) -> *const AVCodecHWConfig;
}
#[doc = " This struct describes the properties of a single codec described by an\n AVCodecID.\n @see avcodec_descriptor_get()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodecDescriptor {
    pub id: AVCodecID,
    pub type_: AVMediaType,
    #[doc = " Name of the codec described by this descriptor. It is non-empty and\n unique for each codec descriptor. It should contain alphanumeric\n characters and '_' only."]
    pub name: *const libc::c_char,
    #[doc = " A more descriptive name for this codec. May be NULL."]
    pub long_name: *const libc::c_char,
    #[doc = " Codec properties, a combination of AV_CODEC_PROP_* flags."]
    pub props: libc::c_int,
    #[doc = " MIME type(s) associated with the codec.\n May be NULL; if not, a NULL-terminated array of MIME types.\n The first item is always non-NULL and is the preferred MIME type."]
    pub mime_types: *const *const libc::c_char,
    #[doc = " If non-NULL, an array of profiles recognized for this codec.\n Terminated with FF_PROFILE_UNKNOWN."]
    pub profiles: *const AVProfile,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVCodecDescriptor"][::std::mem::size_of::<AVCodecDescriptor>() - 48usize];
    ["Alignment of AVCodecDescriptor"][::std::mem::align_of::<AVCodecDescriptor>() - 8usize];
    ["Offset of field: AVCodecDescriptor::id"]
        [::std::mem::offset_of!(AVCodecDescriptor, id) - 0usize];
    ["Offset of field: AVCodecDescriptor::type_"]
        [::std::mem::offset_of!(AVCodecDescriptor, type_) - 4usize];
    ["Offset of field: AVCodecDescriptor::name"]
        [::std::mem::offset_of!(AVCodecDescriptor, name) - 8usize];
    ["Offset of field: AVCodecDescriptor::long_name"]
        [::std::mem::offset_of!(AVCodecDescriptor, long_name) - 16usize];
    ["Offset of field: AVCodecDescriptor::props"]
        [::std::mem::offset_of!(AVCodecDescriptor, props) - 24usize];
    ["Offset of field: AVCodecDescriptor::mime_types"]
        [::std::mem::offset_of!(AVCodecDescriptor, mime_types) - 32usize];
    ["Offset of field: AVCodecDescriptor::profiles"]
        [::std::mem::offset_of!(AVCodecDescriptor, profiles) - 40usize];
};
extern "C" {
    #[doc = " @return descriptor for given codec ID or NULL if no descriptor exists."]
    pub fn avcodec_descriptor_get(id: AVCodecID) -> *const AVCodecDescriptor;
}
extern "C" {
    #[doc = " Iterate over all codec descriptors known to libavcodec.\n\n @param prev previous descriptor. NULL to get the first descriptor.\n\n @return next descriptor or NULL after the last descriptor"]
    pub fn avcodec_descriptor_next(prev: *const AVCodecDescriptor) -> *const AVCodecDescriptor;
}
extern "C" {
    #[doc = " @return codec descriptor with the given name or NULL if no such descriptor\n         exists."]
    pub fn avcodec_descriptor_get_by_name(name: *const libc::c_char) -> *const AVCodecDescriptor;
}
#[repr(i32)]
#[doc = " @ingroup lavc_decoding"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVDiscard {
    #[doc = "< discard nothing"]
    AVDISCARD_NONE = -16,
    #[doc = "< discard useless packets like 0 size packets in avi"]
    AVDISCARD_DEFAULT = 0,
    #[doc = "< discard all non reference"]
    AVDISCARD_NONREF = 8,
    #[doc = "< discard all bidirectional frames"]
    AVDISCARD_BIDIR = 16,
    #[doc = "< discard all non intra frames"]
    AVDISCARD_NONINTRA = 24,
    #[doc = "< discard all frames except keyframes"]
    AVDISCARD_NONKEY = 32,
    #[doc = "< discard all"]
    AVDISCARD_ALL = 48,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVAudioServiceType {
    AV_AUDIO_SERVICE_TYPE_MAIN = 0,
    AV_AUDIO_SERVICE_TYPE_EFFECTS = 1,
    AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,
    AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3,
    AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4,
    AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5,
    AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6,
    AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7,
    AV_AUDIO_SERVICE_TYPE_KARAOKE = 8,
    #[doc = "< Not part of ABI"]
    AV_AUDIO_SERVICE_TYPE_NB = 9,
}
#[doc = " @ingroup lavc_encoding"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct RcOverride {
    pub start_frame: libc::c_int,
    pub end_frame: libc::c_int,
    pub qscale: libc::c_int,
    pub quality_factor: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RcOverride"][::std::mem::size_of::<RcOverride>() - 16usize];
    ["Alignment of RcOverride"][::std::mem::align_of::<RcOverride>() - 4usize];
    ["Offset of field: RcOverride::start_frame"]
        [::std::mem::offset_of!(RcOverride, start_frame) - 0usize];
    ["Offset of field: RcOverride::end_frame"]
        [::std::mem::offset_of!(RcOverride, end_frame) - 4usize];
    ["Offset of field: RcOverride::qscale"][::std::mem::offset_of!(RcOverride, qscale) - 8usize];
    ["Offset of field: RcOverride::quality_factor"]
        [::std::mem::offset_of!(RcOverride, quality_factor) - 12usize];
};
#[doc = " Pan Scan area.\n This specifies the area which should be displayed.\n Note there may be multiple such areas for one frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPanScan {
    #[doc = " id\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub id: libc::c_int,
    #[doc = " width and height in 1/16 pel\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub width: libc::c_int,
    pub height: libc::c_int,
    #[doc = " position of the top left corner in 1/16 pel for up to 3 fields/frames\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub position: [[i16; 2usize]; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVPanScan"][::std::mem::size_of::<AVPanScan>() - 24usize];
    ["Alignment of AVPanScan"][::std::mem::align_of::<AVPanScan>() - 4usize];
    ["Offset of field: AVPanScan::id"][::std::mem::offset_of!(AVPanScan, id) - 0usize];
    ["Offset of field: AVPanScan::width"][::std::mem::offset_of!(AVPanScan, width) - 4usize];
    ["Offset of field: AVPanScan::height"][::std::mem::offset_of!(AVPanScan, height) - 8usize];
    ["Offset of field: AVPanScan::position"][::std::mem::offset_of!(AVPanScan, position) - 12usize];
};
#[doc = " This structure describes the bitrate properties of an encoded bitstream. It\n roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD\n parameters for H.264/HEVC."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCPBProperties {
    pub max_bitrate: libc::c_int,
    pub min_bitrate: libc::c_int,
    pub avg_bitrate: libc::c_int,
    #[doc = " The size of the buffer to which the ratecontrol is applied, in bits.\n Zero if unknown or unspecified."]
    pub buffer_size: libc::c_int,
    #[doc = " The delay between the time the packet this structure is associated with\n is received and the time when it should be decoded, in periods of a 27MHz\n clock.\n\n UINT64_MAX when unknown or unspecified."]
    pub vbv_delay: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVCPBProperties"][::std::mem::size_of::<AVCPBProperties>() - 24usize];
    ["Alignment of AVCPBProperties"][::std::mem::align_of::<AVCPBProperties>() - 8usize];
    ["Offset of field: AVCPBProperties::max_bitrate"]
        [::std::mem::offset_of!(AVCPBProperties, max_bitrate) - 0usize];
    ["Offset of field: AVCPBProperties::min_bitrate"]
        [::std::mem::offset_of!(AVCPBProperties, min_bitrate) - 4usize];
    ["Offset of field: AVCPBProperties::avg_bitrate"]
        [::std::mem::offset_of!(AVCPBProperties, avg_bitrate) - 8usize];
    ["Offset of field: AVCPBProperties::buffer_size"]
        [::std::mem::offset_of!(AVCPBProperties, buffer_size) - 12usize];
    ["Offset of field: AVCPBProperties::vbv_delay"]
        [::std::mem::offset_of!(AVCPBProperties, vbv_delay) - 16usize];
};
#[doc = " This structure supplies correlation between a packet timestamp and a wall clock\n production time. The definition follows the Producer Reference Time ('prft')\n as defined in ISO/IEC 14496-12"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVProducerReferenceTime {
    #[doc = " A UTC timestamp, in microseconds, since Unix epoch (e.g, av_gettime())."]
    pub wallclock: i64,
    pub flags: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVProducerReferenceTime"][::std::mem::size_of::<AVProducerReferenceTime>() - 16usize];
    ["Alignment of AVProducerReferenceTime"]
        [::std::mem::align_of::<AVProducerReferenceTime>() - 8usize];
    ["Offset of field: AVProducerReferenceTime::wallclock"]
        [::std::mem::offset_of!(AVProducerReferenceTime, wallclock) - 0usize];
    ["Offset of field: AVProducerReferenceTime::flags"]
        [::std::mem::offset_of!(AVProducerReferenceTime, flags) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecInternal {
    _unused: [u8; 0],
}
#[doc = " main external API structure.\n New fields can be added to the end with minor version bumps.\n Removal, reordering and changes to existing fields require a major\n version bump.\n You can use AVOptions (av_opt* / av_set/get*()) to access these fields from user\n applications.\n The name string for AVOptions options matches the associated command line\n parameter name and can be found in libavcodec/options_table.h\n The AVOption/command line parameter names differ in some cases from the C\n structure field names for historic reasons or brevity.\n sizeof(AVCodecContext) must not be used outside libav*."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct AVCodecContext {
    #[doc = " information on struct for av_log\n - set by avcodec_alloc_context3"]
    pub av_class: *const AVClass,
    pub log_level_offset: libc::c_int,
    pub codec_type: AVMediaType,
    pub codec: *const AVCodec,
    pub codec_id: AVCodecID,
    #[doc = " fourcc (LSB first, so \"ABCD\" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').\n This is used to work around some encoder bugs.\n A demuxer should set this to what is stored in the field used to identify the codec.\n If there are multiple such fields in a container then the demuxer should choose the one\n which maximizes the information about the used codec.\n If the codec tag field in a container is larger than 32 bits then the demuxer should\n remap the longer ID to 32 bits with a table or other structure. Alternatively a new\n extra_codec_tag + size could be added but for this a clear advantage must be demonstrated\n first.\n - encoding: Set by user, if not then the default based on codec_id will be used.\n - decoding: Set by user, will be converted to uppercase by libavcodec during init."]
    pub codec_tag: libc::c_uint,
    pub priv_data: *mut libc::c_void,
    #[doc = " Private context used for internal data.\n\n Unlike priv_data, this is not codec-specific. It is used in general\n libavcodec functions."]
    pub internal: *mut AVCodecInternal,
    #[doc = " Private data of the user, can be used to carry app specific stuff.\n - encoding: Set by user.\n - decoding: Set by user."]
    pub opaque: *mut libc::c_void,
    #[doc = " the average bitrate\n - encoding: Set by user; unused for constant quantizer encoding.\n - decoding: Set by user, may be overwritten by libavcodec\n             if this info is available in the stream"]
    pub bit_rate: i64,
    #[doc = " number of bits the bitstream is allowed to diverge from the reference.\n           the reference can be CBR (for CBR pass1) or VBR (for pass2)\n - encoding: Set by user; unused for constant quantizer encoding.\n - decoding: unused"]
    pub bit_rate_tolerance: libc::c_int,
    #[doc = " Global quality for codecs which cannot change it per frame.\n This should be proportional to MPEG-1/2/4 qscale.\n - encoding: Set by user.\n - decoding: unused"]
    pub global_quality: libc::c_int,
    #[doc = " - encoding: Set by user.\n - decoding: unused"]
    pub compression_level: libc::c_int,
    #[doc = " AV_CODEC_FLAG_*.\n - encoding: Set by user.\n - decoding: Set by user."]
    pub flags: libc::c_int,
    #[doc = " AV_CODEC_FLAG2_*\n - encoding: Set by user.\n - decoding: Set by user."]
    pub flags2: libc::c_int,
    #[doc = " some codecs need / can use extradata like Huffman tables.\n MJPEG: Huffman tables\n rv10: additional flags\n MPEG-4: global headers (they can be in the bitstream or here)\n The allocated memory should be AV_INPUT_BUFFER_PADDING_SIZE bytes larger\n than extradata_size to avoid problems if it is read with the bitstream reader.\n The bytewise contents of extradata must not depend on the architecture or CPU endianness.\n Must be allocated with the av_malloc() family of functions.\n - encoding: Set/allocated/freed by libavcodec.\n - decoding: Set/allocated/freed by user."]
    pub extradata: *mut u8,
    pub extradata_size: libc::c_int,
    #[doc = " This is the fundamental unit of time (in seconds) in terms\n of which frame timestamps are represented. For fixed-fps content,\n timebase should be 1/framerate and timestamp increments should be\n identically 1.\n This often, but not always is the inverse of the frame rate or field rate\n for video. 1/time_base is not the average frame rate if the frame rate is not\n constant.\n\n Like containers, elementary streams also can store timestamps, 1/time_base\n is the unit in which these timestamps are specified.\n As example of such codec time base see ISO/IEC 14496-2:2001(E)\n vop_time_increment_resolution and fixed_vop_rate\n (fixed_vop_rate == 0 implies that it is different from the framerate)\n\n - encoding: MUST be set by user.\n - decoding: the use of this field for decoding is deprecated.\n             Use framerate instead."]
    pub time_base: AVRational,
    #[doc = " For some codecs, the time base is closer to the field rate than the frame rate.\n Most notably, H.264 and MPEG-2 specify time_base as half of frame duration\n if no telecine is used ...\n\n Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it to 2."]
    pub ticks_per_frame: libc::c_int,
    #[doc = " Codec delay.\n\n Encoding: Number of frames delay there will be from the encoder input to\n           the decoder output. (we assume the decoder matches the spec)\n Decoding: Number of frames delay in addition to what a standard decoder\n           as specified in the spec would produce.\n\n Video:\n   Number of frames the decoded output will be delayed relative to the\n   encoded input.\n\n Audio:\n   For encoding, this field is unused (see initial_padding).\n\n   For decoding, this is the number of samples the decoder needs to\n   output before the decoder's output is valid. When seeking, you should\n   start decoding this many samples prior to your desired seek point.\n\n - encoding: Set by libavcodec.\n - decoding: Set by libavcodec."]
    pub delay: libc::c_int,
    #[doc = " picture width / height.\n\n @note Those fields may not match the values of the last\n AVFrame output by avcodec_decode_video2 due frame\n reordering.\n\n - encoding: MUST be set by user.\n - decoding: May be set by the user before opening the decoder if known e.g.\n             from the container. Some decoders will require the dimensions\n             to be set by the caller. During decoding, the decoder may\n             overwrite those values as required while parsing the data."]
    pub width: libc::c_int,
    #[doc = " picture width / height.\n\n @note Those fields may not match the values of the last\n AVFrame output by avcodec_decode_video2 due frame\n reordering.\n\n - encoding: MUST be set by user.\n - decoding: May be set by the user before opening the decoder if known e.g.\n             from the container. Some decoders will require the dimensions\n             to be set by the caller. During decoding, the decoder may\n             overwrite those values as required while parsing the data."]
    pub height: libc::c_int,
    #[doc = " Bitstream width / height, may be different from width/height e.g. when\n the decoded frame is cropped before being output or lowres is enabled.\n\n @note Those field may not match the value of the last\n AVFrame output by avcodec_receive_frame() due frame\n reordering.\n\n - encoding: unused\n - decoding: May be set by the user before opening the decoder if known\n             e.g. from the container. During decoding, the decoder may\n             overwrite those values as required while parsing the data."]
    pub coded_width: libc::c_int,
    #[doc = " Bitstream width / height, may be different from width/height e.g. when\n the decoded frame is cropped before being output or lowres is enabled.\n\n @note Those field may not match the value of the last\n AVFrame output by avcodec_receive_frame() due frame\n reordering.\n\n - encoding: unused\n - decoding: May be set by the user before opening the decoder if known\n             e.g. from the container. During decoding, the decoder may\n             overwrite those values as required while parsing the data."]
    pub coded_height: libc::c_int,
    #[doc = " the number of pictures in a group of pictures, or 0 for intra_only\n - encoding: Set by user.\n - decoding: unused"]
    pub gop_size: libc::c_int,
    #[doc = " Pixel format, see AV_PIX_FMT_xxx.\n May be set by the demuxer if known from headers.\n May be overridden by the decoder if it knows better.\n\n @note This field may not match the value of the last\n AVFrame output by avcodec_receive_frame() due frame\n reordering.\n\n - encoding: Set by user.\n - decoding: Set by user if known, overridden by libavcodec while\n             parsing the data."]
    pub pix_fmt: AVPixelFormat,
    #[doc = " If non NULL, 'draw_horiz_band' is called by the libavcodec\n decoder to draw a horizontal band. It improves cache usage. Not\n all codecs can do that. You must check the codec capabilities\n beforehand.\n When multithreading is used, it may be called from multiple threads\n at the same time; threads might draw different parts of the same AVFrame,\n or multiple AVFrames, and there is no guarantee that slices will be drawn\n in order.\n The function is also used by hardware acceleration APIs.\n It is called at least once during frame decoding to pass\n the data needed for hardware render.\n In that mode instead of pixel data, AVFrame points to\n a structure specific to the acceleration API. The application\n reads the structure and can change some fields to indicate progress\n or mark state.\n - encoding: unused\n - decoding: Set by user.\n @param height the height of the slice\n @param y the y position of the slice\n @param type 1->top field, 2->bottom field, 3->frame\n @param offset offset into the AVFrame.data from which the slice should be read"]
    pub draw_horiz_band: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            src: *const AVFrame,
            offset: *mut libc::c_int,
            y: libc::c_int,
            type_: libc::c_int,
            height: libc::c_int,
        ),
    >,
    #[doc = " callback to negotiate the pixelFormat\n @param fmt is the list of formats which are supported by the codec,\n it is terminated by -1 as 0 is a valid format, the formats are ordered by quality.\n The first is always the native one.\n @note The callback may be called again immediately if initialization for\n the selected (hardware-accelerated) pixel format failed.\n @warning Behavior is undefined if the callback returns a value not\n in the fmt list of formats.\n @return the chosen format\n - encoding: unused\n - decoding: Set by user, if not set the native format will be chosen."]
    pub get_format: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVCodecContext, fmt: *const AVPixelFormat) -> AVPixelFormat,
    >,
    #[doc = " maximum number of B-frames between non-B-frames\n Note: The output will be delayed by max_b_frames+1 relative to the input.\n - encoding: Set by user.\n - decoding: unused"]
    pub max_b_frames: libc::c_int,
    #[doc = " qscale factor between IP and B-frames\n If > 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset).\n If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).\n - encoding: Set by user.\n - decoding: unused"]
    pub b_quant_factor: f32,
    #[doc = " @deprecated use encoder private options instead"]
    pub b_frame_strategy: libc::c_int,
    #[doc = " qscale offset between IP and B-frames\n - encoding: Set by user.\n - decoding: unused"]
    pub b_quant_offset: f32,
    #[doc = " Size of the frame reordering buffer in the decoder.\n For MPEG-2 it is 1 IPB or 0 low delay IP.\n - encoding: Set by libavcodec.\n - decoding: Set by libavcodec."]
    pub has_b_frames: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub mpeg_quant: libc::c_int,
    #[doc = " qscale factor between P- and I-frames\n If > 0 then the last P-frame quantizer will be used (q = lastp_q * factor + offset).\n If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).\n - encoding: Set by user.\n - decoding: unused"]
    pub i_quant_factor: f32,
    #[doc = " qscale offset between P and I-frames\n - encoding: Set by user.\n - decoding: unused"]
    pub i_quant_offset: f32,
    #[doc = " luminance masking (0-> disabled)\n - encoding: Set by user.\n - decoding: unused"]
    pub lumi_masking: f32,
    #[doc = " temporary complexity masking (0-> disabled)\n - encoding: Set by user.\n - decoding: unused"]
    pub temporal_cplx_masking: f32,
    #[doc = " spatial complexity masking (0-> disabled)\n - encoding: Set by user.\n - decoding: unused"]
    pub spatial_cplx_masking: f32,
    #[doc = " p block masking (0-> disabled)\n - encoding: Set by user.\n - decoding: unused"]
    pub p_masking: f32,
    #[doc = " darkness masking (0-> disabled)\n - encoding: Set by user.\n - decoding: unused"]
    pub dark_masking: f32,
    #[doc = " slice count\n - encoding: Set by libavcodec.\n - decoding: Set by user (or 0)."]
    pub slice_count: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub prediction_method: libc::c_int,
    #[doc = " slice offsets in the frame in bytes\n - encoding: Set/allocated by libavcodec.\n - decoding: Set/allocated by user (or NULL)."]
    pub slice_offset: *mut libc::c_int,
    #[doc = " sample aspect ratio (0 if unknown)\n That is the width of a pixel divided by the height of the pixel.\n Numerator and denominator must be relatively prime and smaller than 256 for some video standards.\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub sample_aspect_ratio: AVRational,
    #[doc = " motion estimation comparison function\n - encoding: Set by user.\n - decoding: unused"]
    pub me_cmp: libc::c_int,
    #[doc = " subpixel motion estimation comparison function\n - encoding: Set by user.\n - decoding: unused"]
    pub me_sub_cmp: libc::c_int,
    #[doc = " macroblock comparison function (not supported yet)\n - encoding: Set by user.\n - decoding: unused"]
    pub mb_cmp: libc::c_int,
    #[doc = " interlaced DCT comparison function\n - encoding: Set by user.\n - decoding: unused"]
    pub ildct_cmp: libc::c_int,
    #[doc = " ME diamond size & shape\n - encoding: Set by user.\n - decoding: unused"]
    pub dia_size: libc::c_int,
    #[doc = " amount of previous MV predictors (2a+1 x 2a+1 square)\n - encoding: Set by user.\n - decoding: unused"]
    pub last_predictor_count: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub pre_me: libc::c_int,
    #[doc = " motion estimation prepass comparison function\n - encoding: Set by user.\n - decoding: unused"]
    pub me_pre_cmp: libc::c_int,
    #[doc = " ME prepass diamond size & shape\n - encoding: Set by user.\n - decoding: unused"]
    pub pre_dia_size: libc::c_int,
    #[doc = " subpel ME quality\n - encoding: Set by user.\n - decoding: unused"]
    pub me_subpel_quality: libc::c_int,
    #[doc = " maximum motion estimation search range in subpel units\n If 0 then no limit.\n\n - encoding: Set by user.\n - decoding: unused"]
    pub me_range: libc::c_int,
    #[doc = " slice flags\n - encoding: unused\n - decoding: Set by user."]
    pub slice_flags: libc::c_int,
    #[doc = " macroblock decision mode\n - encoding: Set by user.\n - decoding: unused"]
    pub mb_decision: libc::c_int,
    #[doc = " custom intra quantization matrix\n Must be allocated with the av_malloc() family of functions, and will be freed in\n avcodec_free_context().\n - encoding: Set/allocated by user, freed by libavcodec. Can be NULL.\n - decoding: Set/allocated/freed by libavcodec."]
    pub intra_matrix: *mut u16,
    #[doc = " custom inter quantization matrix\n Must be allocated with the av_malloc() family of functions, and will be freed in\n avcodec_free_context().\n - encoding: Set/allocated by user, freed by libavcodec. Can be NULL.\n - decoding: Set/allocated/freed by libavcodec."]
    pub inter_matrix: *mut u16,
    #[doc = " @deprecated use encoder private options instead"]
    pub scenechange_threshold: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub noise_reduction: libc::c_int,
    #[doc = " precision of the intra DC coefficient - 8\n - encoding: Set by user.\n - decoding: Set by libavcodec"]
    pub intra_dc_precision: libc::c_int,
    #[doc = " Number of macroblock rows at the top which are skipped.\n - encoding: unused\n - decoding: Set by user."]
    pub skip_top: libc::c_int,
    #[doc = " Number of macroblock rows at the bottom which are skipped.\n - encoding: unused\n - decoding: Set by user."]
    pub skip_bottom: libc::c_int,
    #[doc = " minimum MB Lagrange multiplier\n - encoding: Set by user.\n - decoding: unused"]
    pub mb_lmin: libc::c_int,
    #[doc = " maximum MB Lagrange multiplier\n - encoding: Set by user.\n - decoding: unused"]
    pub mb_lmax: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub me_penalty_compensation: libc::c_int,
    #[doc = " - encoding: Set by user.\n - decoding: unused"]
    pub bidir_refine: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub brd_scale: libc::c_int,
    #[doc = " minimum GOP size\n - encoding: Set by user.\n - decoding: unused"]
    pub keyint_min: libc::c_int,
    #[doc = " number of reference frames\n - encoding: Set by user.\n - decoding: Set by lavc."]
    pub refs: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub chromaoffset: libc::c_int,
    #[doc = " Note: Value depends upon the compare function used for fullpel ME.\n - encoding: Set by user.\n - decoding: unused"]
    pub mv0_threshold: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub b_sensitivity: libc::c_int,
    #[doc = " Chromaticity coordinates of the source primaries.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub color_primaries: AVColorPrimaries,
    #[doc = " Color Transfer Characteristic.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub color_trc: AVColorTransferCharacteristic,
    #[doc = " YUV colorspace type.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub colorspace: AVColorSpace,
    #[doc = " MPEG vs JPEG YUV range.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub color_range: AVColorRange,
    #[doc = " This defines the location of chroma samples.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub chroma_sample_location: AVChromaLocation,
    #[doc = " Number of slices.\n Indicates number of picture subdivisions. Used for parallelized\n decoding.\n - encoding: Set by user\n - decoding: unused"]
    pub slices: libc::c_int,
    #[doc = " Field order\n - encoding: set by libavcodec\n - decoding: Set by user."]
    pub field_order: AVFieldOrder,
    #[doc = "< samples per second"]
    pub sample_rate: libc::c_int,
    #[doc = "< number of audio channels"]
    pub channels: libc::c_int,
    #[doc = "< sample format"]
    pub sample_fmt: AVSampleFormat,
    #[doc = " Number of samples per channel in an audio frame.\n\n - encoding: set by libavcodec in avcodec_open2(). Each submitted frame\n   except the last must contain exactly frame_size samples per channel.\n   May be 0 when the codec has AV_CODEC_CAP_VARIABLE_FRAME_SIZE set, then the\n   frame size is not restricted.\n - decoding: may be set by some decoders to indicate constant frame size"]
    pub frame_size: libc::c_int,
    #[doc = " Frame counter, set by libavcodec.\n\n - decoding: total number of frames returned from the decoder so far.\n - encoding: total number of frames passed to the encoder so far.\n\n   @note the counter is not incremented if encoding/decoding resulted in\n   an error."]
    pub frame_number: libc::c_int,
    #[doc = " number of bytes per packet if constant and known or 0\n Used by some WAV based audio codecs."]
    pub block_align: libc::c_int,
    #[doc = " Audio cutoff bandwidth (0 means \"automatic\")\n - encoding: Set by user.\n - decoding: unused"]
    pub cutoff: libc::c_int,
    #[doc = " Audio channel layout.\n - encoding: set by user.\n - decoding: set by user, may be overwritten by libavcodec."]
    pub channel_layout: u64,
    #[doc = " Request decoder to use this channel layout if it can (0 for default)\n - encoding: unused\n - decoding: Set by user."]
    pub request_channel_layout: u64,
    #[doc = " Type of service that the audio stream conveys.\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub audio_service_type: AVAudioServiceType,
    #[doc = " desired sample format\n - encoding: Not used.\n - decoding: Set by user.\n Decoder will decode to this format if it can."]
    pub request_sample_fmt: AVSampleFormat,
    #[doc = " This callback is called at the beginning of each frame to get data\n buffer(s) for it. There may be one contiguous buffer for all the data or\n there may be a buffer per each data plane or anything in between. What\n this means is, you may set however many entries in buf[] you feel necessary.\n Each buffer must be reference-counted using the AVBuffer API (see description\n of buf[] below).\n\n The following fields will be set in the frame before this callback is\n called:\n - format\n - width, height (video only)\n - sample_rate, channel_layout, nb_samples (audio only)\n Their values may differ from the corresponding values in\n AVCodecContext. This callback must use the frame values, not the codec\n context values, to calculate the required buffer size.\n\n This callback must fill the following fields in the frame:\n - data[]\n - linesize[]\n - extended_data:\n   * if the data is planar audio with more than 8 channels, then this\n     callback must allocate and fill extended_data to contain all pointers\n     to all data planes. data[] must hold as many pointers as it can.\n     extended_data must be allocated with av_malloc() and will be freed in\n     av_frame_unref().\n   * otherwise extended_data must point to data\n - buf[] must contain one or more pointers to AVBufferRef structures. Each of\n   the frame's data and extended_data pointers must be contained in these. That\n   is, one AVBufferRef for each allocated chunk of memory, not necessarily one\n   AVBufferRef per data[] entry. See: av_buffer_create(), av_buffer_alloc(),\n   and av_buffer_ref().\n - extended_buf and nb_extended_buf must be allocated with av_malloc() by\n   this callback and filled with the extra buffers if there are more\n   buffers than buf[] can hold. extended_buf will be freed in\n   av_frame_unref().\n   Decoders will generally initialize the whole buffer before it is output\n   but it can in rare error conditions happen that uninitialized data is passed\n   through. \\important The buffers returned by get_buffer* should thus not contain sensitive\n   data.\n\n If AV_CODEC_CAP_DR1 is not set then get_buffer2() must call\n avcodec_default_get_buffer2() instead of providing buffers allocated by\n some other means.\n\n Each data plane must be aligned to the maximum required by the target\n CPU.\n\n @see avcodec_default_get_buffer2()\n\n Video:\n\n If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused\n (read and/or written to if it is writable) later by libavcodec.\n\n avcodec_align_dimensions2() should be used to find the required width and\n height, as they normally need to be rounded up to the next multiple of 16.\n\n Some decoders do not support linesizes changing between frames.\n\n If frame multithreading is used, this callback may be called from a\n different thread, but not from more than one at once. Does not need to be\n reentrant.\n\n @see avcodec_align_dimensions2()\n\n Audio:\n\n Decoders request a buffer of a particular size by setting\n AVFrame.nb_samples prior to calling get_buffer2(). The decoder may,\n however, utilize only part of the buffer by setting AVFrame.nb_samples\n to a smaller value in the output frame.\n\n As a convenience, av_samples_get_buffer_size() and\n av_samples_fill_arrays() in libavutil may be used by custom get_buffer2()\n functions to find the required data size and to fill data pointers and\n linesize. In AVFrame.linesize, only linesize[0] may be set for audio\n since all planes must be the same size.\n\n @see av_samples_get_buffer_size(), av_samples_fill_arrays()\n\n - encoding: unused\n - decoding: Set by libavcodec, user can override."]
    pub get_buffer2: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            frame: *mut AVFrame,
            flags: libc::c_int,
        ) -> libc::c_int,
    >,
    #[doc = " If non-zero, the decoded audio and video frames returned from\n avcodec_decode_video2() and avcodec_decode_audio4() are reference-counted\n and are valid indefinitely. The caller must free them with\n av_frame_unref() when they are not needed anymore.\n Otherwise, the decoded frames must not be freed by the caller and are\n only valid until the next decode call.\n\n This is always automatically enabled if avcodec_receive_frame() is used.\n\n - encoding: unused\n - decoding: set by the caller before avcodec_open2()."]
    pub refcounted_frames: libc::c_int,
    #[doc = "< amount of qscale change between easy & hard scenes (0.0-1.0)"]
    pub qcompress: f32,
    #[doc = "< amount of qscale smoothing over time (0.0-1.0)"]
    pub qblur: f32,
    #[doc = " minimum quantizer\n - encoding: Set by user.\n - decoding: unused"]
    pub qmin: libc::c_int,
    #[doc = " maximum quantizer\n - encoding: Set by user.\n - decoding: unused"]
    pub qmax: libc::c_int,
    #[doc = " maximum quantizer difference between frames\n - encoding: Set by user.\n - decoding: unused"]
    pub max_qdiff: libc::c_int,
    #[doc = " decoder bitstream buffer size\n - encoding: Set by user.\n - decoding: unused"]
    pub rc_buffer_size: libc::c_int,
    #[doc = " ratecontrol override, see RcOverride\n - encoding: Allocated/set/freed by user.\n - decoding: unused"]
    pub rc_override_count: libc::c_int,
    pub rc_override: *mut RcOverride,
    #[doc = " maximum bitrate\n - encoding: Set by user.\n - decoding: Set by user, may be overwritten by libavcodec."]
    pub rc_max_rate: i64,
    #[doc = " minimum bitrate\n - encoding: Set by user.\n - decoding: unused"]
    pub rc_min_rate: i64,
    #[doc = " Ratecontrol attempt to use, at maximum, <value> of what can be used without an underflow.\n - encoding: Set by user.\n - decoding: unused."]
    pub rc_max_available_vbv_use: f32,
    #[doc = " Ratecontrol attempt to use, at least, <value> times the amount needed to prevent a vbv overflow.\n - encoding: Set by user.\n - decoding: unused."]
    pub rc_min_vbv_overflow_use: f32,
    #[doc = " Number of bits which should be loaded into the rc buffer before decoding starts.\n - encoding: Set by user.\n - decoding: unused"]
    pub rc_initial_buffer_occupancy: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub coder_type: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub context_model: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub frame_skip_threshold: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub frame_skip_factor: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub frame_skip_exp: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub frame_skip_cmp: libc::c_int,
    #[doc = " trellis RD quantization\n - encoding: Set by user.\n - decoding: unused"]
    pub trellis: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub min_prediction_order: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub max_prediction_order: libc::c_int,
    #[doc = " @deprecated use encoder private options instead"]
    pub timecode_frame_start: i64,
    #[doc = " @deprecated unused"]
    pub rtp_callback: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            data: *mut libc::c_void,
            size: libc::c_int,
            mb_nb: libc::c_int,
        ),
    >,
    #[doc = " @deprecated use encoder private options instead"]
    pub rtp_payload_size: libc::c_int,
    pub mv_bits: libc::c_int,
    pub header_bits: libc::c_int,
    pub i_tex_bits: libc::c_int,
    pub p_tex_bits: libc::c_int,
    pub i_count: libc::c_int,
    pub p_count: libc::c_int,
    pub skip_count: libc::c_int,
    pub misc_bits: libc::c_int,
    #[doc = " @deprecated this field is unused"]
    pub frame_bits: libc::c_int,
    #[doc = " pass1 encoding statistics output buffer\n - encoding: Set by libavcodec.\n - decoding: unused"]
    pub stats_out: *mut libc::c_char,
    #[doc = " pass2 encoding statistics input buffer\n Concatenated stuff from stats_out of pass1 should be placed here.\n - encoding: Allocated/set/freed by user.\n - decoding: unused"]
    pub stats_in: *mut libc::c_char,
    #[doc = " Work around bugs in encoders which sometimes cannot be detected automatically.\n - encoding: Set by user\n - decoding: Set by user"]
    pub workaround_bugs: libc::c_int,
    #[doc = " strictly follow the standard (MPEG-4, ...).\n - encoding: Set by user.\n - decoding: Set by user.\n Setting this to STRICT or higher means the encoder and decoder will\n generally do stupid things, whereas setting it to unofficial or lower\n will mean the encoder might produce output that is not supported by all\n spec-compliant decoders. Decoders don't differentiate between normal,\n unofficial and experimental (that is, they always try to decode things\n when they can) unless they are explicitly asked to behave stupidly\n (=strictly conform to the specs)"]
    pub strict_std_compliance: libc::c_int,
    #[doc = " error concealment flags\n - encoding: unused\n - decoding: Set by user."]
    pub error_concealment: libc::c_int,
    #[doc = " debug\n - encoding: Set by user.\n - decoding: Set by user."]
    pub debug: libc::c_int,
    #[doc = " Error recognition; may misdetect some more or less valid parts as errors.\n - encoding: Set by user.\n - decoding: Set by user."]
    pub err_recognition: libc::c_int,
    #[doc = " opaque 64-bit number (generally a PTS) that will be reordered and\n output in AVFrame.reordered_opaque\n - encoding: Set by libavcodec to the reordered_opaque of the input\n             frame corresponding to the last returned packet. Only\n             supported by encoders with the\n             AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE capability.\n - decoding: Set by user."]
    pub reordered_opaque: i64,
    #[doc = " Hardware accelerator in use\n - encoding: unused.\n - decoding: Set by libavcodec"]
    pub hwaccel: *const AVHWAccel,
    #[doc = " Hardware accelerator context.\n For some hardware accelerators, a global context needs to be\n provided by the user. In that case, this holds display-dependent\n data FFmpeg cannot instantiate itself. Please refer to the\n FFmpeg HW accelerator documentation to know how to fill this\n is. e.g. for VA API, this is a struct vaapi_context.\n - encoding: unused\n - decoding: Set by user"]
    pub hwaccel_context: *mut libc::c_void,
    #[doc = " error\n - encoding: Set by libavcodec if flags & AV_CODEC_FLAG_PSNR.\n - decoding: unused"]
    pub error: [u64; 8usize],
    #[doc = " DCT algorithm, see FF_DCT_* below\n - encoding: Set by user.\n - decoding: unused"]
    pub dct_algo: libc::c_int,
    #[doc = " IDCT algorithm, see FF_IDCT_* below.\n - encoding: Set by user.\n - decoding: Set by user."]
    pub idct_algo: libc::c_int,
    #[doc = " bits per sample/pixel from the demuxer (needed for huffyuv).\n - encoding: Set by libavcodec.\n - decoding: Set by user."]
    pub bits_per_coded_sample: libc::c_int,
    #[doc = " Bits per sample/pixel of internal libavcodec pixel/sample format.\n - encoding: set by user.\n - decoding: set by libavcodec."]
    pub bits_per_raw_sample: libc::c_int,
    #[doc = " low resolution decoding, 1-> 1/2 size, 2->1/4 size\n - encoding: unused\n - decoding: Set by user."]
    pub lowres: libc::c_int,
    #[doc = " the picture in the bitstream\n - encoding: Set by libavcodec.\n - decoding: unused\n\n @deprecated use the quality factor packet side data instead"]
    pub coded_frame: *mut AVFrame,
    #[doc = " thread count\n is used to decide how many independent tasks should be passed to execute()\n - encoding: Set by user.\n - decoding: Set by user."]
    pub thread_count: libc::c_int,
    #[doc = " Which multithreading methods to use.\n Use of FF_THREAD_FRAME will increase decoding delay by one frame per thread,\n so clients which cannot provide future frames should not use it.\n\n - encoding: Set by user, otherwise the default is used.\n - decoding: Set by user, otherwise the default is used."]
    pub thread_type: libc::c_int,
    #[doc = " Which multithreading methods are in use by the codec.\n - encoding: Set by libavcodec.\n - decoding: Set by libavcodec."]
    pub active_thread_type: libc::c_int,
    #[doc = " Set by the client if its custom get_buffer() callback can be called\n synchronously from another thread, which allows faster multithreaded decoding.\n draw_horiz_band() will be called from other threads regardless of this setting.\n Ignored if the default get_buffer() is used.\n - encoding: Set by user.\n - decoding: Set by user.\n\n @deprecated the custom get_buffer2() callback should always be\n   thread-safe. Thread-unsafe get_buffer2() implementations will be\n   invalid starting with LIBAVCODEC_VERSION_MAJOR=60; in other words,\n   libavcodec will behave as if this field was always set to 1.\n   Callers that want to be forward compatible with future libavcodec\n   versions should wrap access to this field in\n     #if LIBAVCODEC_VERSION_MAJOR < 60"]
    pub thread_safe_callbacks: libc::c_int,
    #[doc = " The codec may call this to execute several independent things.\n It will return only after finishing all tasks.\n The user may replace this with some multithreaded implementation,\n the default implementation will execute the parts serially.\n @param count the number of things to execute\n - encoding: Set by libavcodec, user can override.\n - decoding: Set by libavcodec, user can override."]
    pub execute: ::std::option::Option<
        unsafe extern "C" fn(
            c: *mut AVCodecContext,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    c2: *mut AVCodecContext,
                    arg: *mut libc::c_void,
                ) -> libc::c_int,
            >,
            arg2: *mut libc::c_void,
            ret: *mut libc::c_int,
            count: libc::c_int,
            size: libc::c_int,
        ) -> libc::c_int,
    >,
    #[doc = " The codec may call this to execute several independent things.\n It will return only after finishing all tasks.\n The user may replace this with some multithreaded implementation,\n the default implementation will execute the parts serially.\n Also see avcodec_thread_init and e.g. the --enable-pthread configure option.\n @param c context passed also to func\n @param count the number of things to execute\n @param arg2 argument passed unchanged to func\n @param ret return values of executed functions, must have space for \"count\" values. May be NULL.\n @param func function that will be called count times, with jobnr from 0 to count-1.\n             threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS and so that no\n             two instances of func executing at the same time will have the same threadnr.\n @return always 0 currently, but code should handle a future improvement where when any call to func\n         returns < 0 no further calls to func may be done and < 0 is returned.\n - encoding: Set by libavcodec, user can override.\n - decoding: Set by libavcodec, user can override."]
    pub execute2: ::std::option::Option<
        unsafe extern "C" fn(
            c: *mut AVCodecContext,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    c2: *mut AVCodecContext,
                    arg: *mut libc::c_void,
                    jobnr: libc::c_int,
                    threadnr: libc::c_int,
                ) -> libc::c_int,
            >,
            arg2: *mut libc::c_void,
            ret: *mut libc::c_int,
            count: libc::c_int,
        ) -> libc::c_int,
    >,
    #[doc = " noise vs. sse weight for the nsse comparison function\n - encoding: Set by user.\n - decoding: unused"]
    pub nsse_weight: libc::c_int,
    #[doc = " profile\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub profile: libc::c_int,
    #[doc = " level\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub level: libc::c_int,
    #[doc = " Skip loop filtering for selected frames.\n - encoding: unused\n - decoding: Set by user."]
    pub skip_loop_filter: AVDiscard,
    #[doc = " Skip IDCT/dequantization for selected frames.\n - encoding: unused\n - decoding: Set by user."]
    pub skip_idct: AVDiscard,
    #[doc = " Skip decoding for selected frames.\n - encoding: unused\n - decoding: Set by user."]
    pub skip_frame: AVDiscard,
    #[doc = " Header containing style information for text subtitles.\n For SUBTITLE_ASS subtitle type, it should contain the whole ASS\n [Script Info] and [V4+ Styles] section, plus the [Events] line and\n the Format line following. It shouldn't include any Dialogue line.\n - encoding: Set/allocated/freed by user (before avcodec_open2())\n - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())"]
    pub subtitle_header: *mut u8,
    pub subtitle_header_size: libc::c_int,
    #[doc = " VBV delay coded in the last frame (in periods of a 27 MHz clock).\n Used for compliant TS muxing.\n - encoding: Set by libavcodec.\n - decoding: unused.\n @deprecated this value is now exported as a part of\n AV_PKT_DATA_CPB_PROPERTIES packet side data"]
    pub vbv_delay: u64,
    #[doc = " Encoding only and set by default. Allow encoders to output packets\n that do not contain any encoded data, only side data.\n\n Some encoders need to output such packets, e.g. to update some stream\n parameters at the end of encoding.\n\n @deprecated this field disables the default behaviour and\n             it is kept only for compatibility."]
    pub side_data_only_packets: libc::c_int,
    #[doc = " Audio only. The number of \"priming\" samples (padding) inserted by the\n encoder at the beginning of the audio. I.e. this number of leading\n decoded samples must be discarded by the caller to get the original audio\n without leading padding.\n\n - decoding: unused\n - encoding: Set by libavcodec. The timestamps on the output packets are\n             adjusted by the encoder so that they always refer to the\n             first sample of the data actually contained in the packet,\n             including any added padding.  E.g. if the timebase is\n             1/samplerate and the timestamp of the first input sample is\n             0, the timestamp of the first output packet will be\n             -initial_padding."]
    pub initial_padding: libc::c_int,
    #[doc = " - decoding: For codecs that store a framerate value in the compressed\n             bitstream, the decoder may export it here. { 0, 1} when\n             unknown.\n - encoding: May be used to signal the framerate of CFR content to an\n             encoder."]
    pub framerate: AVRational,
    #[doc = " Nominal unaccelerated pixel format, see AV_PIX_FMT_xxx.\n - encoding: unused.\n - decoding: Set by libavcodec before calling get_format()"]
    pub sw_pix_fmt: AVPixelFormat,
    #[doc = " Timebase in which pkt_dts/pts and AVPacket.dts/pts are.\n - encoding unused.\n - decoding set by user."]
    pub pkt_timebase: AVRational,
    #[doc = " AVCodecDescriptor\n - encoding: unused.\n - decoding: set by libavcodec."]
    pub codec_descriptor: *const AVCodecDescriptor,
    #[doc = " Current statistics for PTS correction.\n - decoding: maintained and used by libavcodec, not intended to be used by user apps\n - encoding: unused"]
    pub pts_correction_num_faulty_pts: i64,
    #[doc = " Number of incorrect PTS values so far"]
    pub pts_correction_num_faulty_dts: i64,
    #[doc = " Number of incorrect DTS values so far"]
    pub pts_correction_last_pts: i64,
    #[doc = " PTS of the last frame"]
    pub pts_correction_last_dts: i64,
    #[doc = " Character encoding of the input subtitles file.\n - decoding: set by user\n - encoding: unused"]
    pub sub_charenc: *mut libc::c_char,
    #[doc = " Subtitles character encoding mode. Formats or codecs might be adjusting\n this setting (if they are doing the conversion themselves for instance).\n - decoding: set by libavcodec\n - encoding: unused"]
    pub sub_charenc_mode: libc::c_int,
    #[doc = " Skip processing alpha if supported by codec.\n Note that if the format uses pre-multiplied alpha (common with VP6,\n and recommended due to better video quality/compression)\n the image will look as if alpha-blended onto a black background.\n However for formats that do not use pre-multiplied alpha\n there might be serious artefacts (though e.g. libswscale currently\n assumes pre-multiplied alpha anyway).\n\n - decoding: set by user\n - encoding: unused"]
    pub skip_alpha: libc::c_int,
    #[doc = " Number of samples to skip after a discontinuity\n - decoding: unused\n - encoding: set by libavcodec"]
    pub seek_preroll: libc::c_int,
    #[doc = " @deprecated unused"]
    pub debug_mv: libc::c_int,
    #[doc = " custom intra quantization matrix\n - encoding: Set by user, can be NULL.\n - decoding: unused."]
    pub chroma_intra_matrix: *mut u16,
    #[doc = " dump format separator.\n can be \", \" or \"\\n      \" or anything else\n - encoding: Set by user.\n - decoding: Set by user."]
    pub dump_separator: *mut u8,
    #[doc = " ',' separated list of allowed decoders.\n If NULL then all are allowed\n - encoding: unused\n - decoding: set by user"]
    pub codec_whitelist: *mut libc::c_char,
    #[doc = " Properties of the stream that gets decoded\n - encoding: unused\n - decoding: set by libavcodec"]
    pub properties: libc::c_uint,
    #[doc = " Additional data associated with the entire coded stream.\n\n - decoding: unused\n - encoding: may be set by libavcodec after avcodec_open2()."]
    pub coded_side_data: *mut AVPacketSideData,
    pub nb_coded_side_data: libc::c_int,
    #[doc = " A reference to the AVHWFramesContext describing the input (for encoding)\n or output (decoding) frames. The reference is set by the caller and\n afterwards owned (and freed) by libavcodec - it should never be read by\n the caller after being set.\n\n - decoding: This field should be set by the caller from the get_format()\n             callback. The previous reference (if any) will always be\n             unreffed by libavcodec before the get_format() call.\n\n             If the default get_buffer2() is used with a hwaccel pixel\n             format, then this AVHWFramesContext will be used for\n             allocating the frame buffers.\n\n - encoding: For hardware encoders configured to use a hwaccel pixel\n             format, this field should be set by the caller to a reference\n             to the AVHWFramesContext describing input frames.\n             AVHWFramesContext.format must be equal to\n             AVCodecContext.pix_fmt.\n\n             This field should be set before avcodec_open2() is called."]
    pub hw_frames_ctx: *mut AVBufferRef,
    #[doc = " Control the form of AVSubtitle.rects[N]->ass\n - decoding: set by user\n - encoding: unused"]
    pub sub_text_format: libc::c_int,
    #[doc = " Audio only. The amount of padding (in samples) appended by the encoder to\n the end of the audio. I.e. this number of decoded samples must be\n discarded by the caller from the end of the stream to get the original\n audio without any trailing padding.\n\n - decoding: unused\n - encoding: unused"]
    pub trailing_padding: libc::c_int,
    #[doc = " The number of pixels per image to maximally accept.\n\n - decoding: set by user\n - encoding: set by user"]
    pub max_pixels: i64,
    #[doc = " A reference to the AVHWDeviceContext describing the device which will\n be used by a hardware encoder/decoder.  The reference is set by the\n caller and afterwards owned (and freed) by libavcodec.\n\n This should be used if either the codec device does not require\n hardware frames or any that are used are to be allocated internally by\n libavcodec.  If the user wishes to supply any of the frames used as\n encoder input or decoder output then hw_frames_ctx should be used\n instead.  When hw_frames_ctx is set in get_format() for a decoder, this\n field will be ignored while decoding the associated stream segment, but\n may again be used on a following one after another get_format() call.\n\n For both encoders and decoders this field should be set before\n avcodec_open2() is called and must not be written to thereafter.\n\n Note that some decoders may require this field to be set initially in\n order to support hw_frames_ctx at all - in that case, all frames\n contexts used must be created on the same device."]
    pub hw_device_ctx: *mut AVBufferRef,
    #[doc = " Bit set of AV_HWACCEL_FLAG_* flags, which affect hardware accelerated\n decoding (if active).\n - encoding: unused\n - decoding: Set by user (either before avcodec_open2(), or in the\n             AVCodecContext.get_format callback)"]
    pub hwaccel_flags: libc::c_int,
    #[doc = " Video decoding only. Certain video codecs support cropping, meaning that\n only a sub-rectangle of the decoded frame is intended for display.  This\n option controls how cropping is handled by libavcodec.\n\n When set to 1 (the default), libavcodec will apply cropping internally.\n I.e. it will modify the output frame width/height fields and offset the\n data pointers (only by as much as possible while preserving alignment, or\n by the full amount if the AV_CODEC_FLAG_UNALIGNED flag is set) so that\n the frames output by the decoder refer only to the cropped area. The\n crop_* fields of the output frames will be zero.\n\n When set to 0, the width/height fields of the output frames will be set\n to the coded dimensions and the crop_* fields will describe the cropping\n rectangle. Applying the cropping is left to the caller.\n\n @warning When hardware acceleration with opaque output frames is used,\n libavcodec is unable to apply cropping from the top/left border.\n\n @note when this option is set to zero, the width/height fields of the\n AVCodecContext and output AVFrames have different meanings. The codec\n context fields store display dimensions (with the coded dimensions in\n coded_width/height), while the frame fields store the coded dimensions\n (with the display dimensions being determined by the crop_* fields)."]
    pub apply_cropping: libc::c_int,
    pub extra_hw_frames: libc::c_int,
    #[doc = " The percentage of damaged samples to discard a frame.\n\n - decoding: set by user\n - encoding: unused"]
    pub discard_damaged_percentage: libc::c_int,
    #[doc = " The number of samples per frame to maximally accept.\n\n - decoding: set by user\n - encoding: set by user"]
    pub max_samples: i64,
    #[doc = " Bit set of AV_CODEC_EXPORT_DATA_* flags, which affects the kind of\n metadata exported in frame, packet, or coded stream side data by\n decoders and encoders.\n\n - decoding: set by user\n - encoding: set by user"]
    pub export_side_data: libc::c_int,
    #[doc = " This callback is called at the beginning of each packet to get a data\n buffer for it.\n\n The following field will be set in the packet before this callback is\n called:\n - size\n This callback must use the above value to calculate the required buffer size,\n which must padded by at least AV_INPUT_BUFFER_PADDING_SIZE bytes.\n\n This callback must fill the following fields in the packet:\n - data: alignment requirements for AVPacket apply, if any. Some architectures and\n   encoders may benefit from having aligned data.\n - buf: must contain a pointer to an AVBufferRef structure. The packet's\n   data pointer must be contained in it. See: av_buffer_create(), av_buffer_alloc(),\n   and av_buffer_ref().\n\n If AV_CODEC_CAP_DR1 is not set then get_encode_buffer() must call\n avcodec_default_get_encode_buffer() instead of providing a buffer allocated by\n some other means.\n\n The flags field may contain a combination of AV_GET_ENCODE_BUFFER_FLAG_ flags.\n They may be used for example to hint what use the buffer may get after being\n created.\n Implementations of this callback may ignore flags they don't understand.\n If AV_GET_ENCODE_BUFFER_FLAG_REF is set in flags then the packet may be reused\n (read and/or written to if it is writable) later by libavcodec.\n\n This callback must be thread-safe, as when frame threading is used, it may\n be called from multiple threads simultaneously.\n\n @see avcodec_default_get_encode_buffer()\n\n - encoding: Set by libavcodec, user can override.\n - decoding: unused"]
    pub get_encode_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            pkt: *mut AVPacket,
            flags: libc::c_int,
        ) -> libc::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVCodecContext"][::std::mem::size_of::<AVCodecContext>() - 1080usize];
    ["Alignment of AVCodecContext"][::std::mem::align_of::<AVCodecContext>() - 8usize];
    ["Offset of field: AVCodecContext::av_class"]
        [::std::mem::offset_of!(AVCodecContext, av_class) - 0usize];
    ["Offset of field: AVCodecContext::log_level_offset"]
        [::std::mem::offset_of!(AVCodecContext, log_level_offset) - 8usize];
    ["Offset of field: AVCodecContext::codec_type"]
        [::std::mem::offset_of!(AVCodecContext, codec_type) - 12usize];
    ["Offset of field: AVCodecContext::codec"]
        [::std::mem::offset_of!(AVCodecContext, codec) - 16usize];
    ["Offset of field: AVCodecContext::codec_id"]
        [::std::mem::offset_of!(AVCodecContext, codec_id) - 24usize];
    ["Offset of field: AVCodecContext::codec_tag"]
        [::std::mem::offset_of!(AVCodecContext, codec_tag) - 28usize];
    ["Offset of field: AVCodecContext::priv_data"]
        [::std::mem::offset_of!(AVCodecContext, priv_data) - 32usize];
    ["Offset of field: AVCodecContext::internal"]
        [::std::mem::offset_of!(AVCodecContext, internal) - 40usize];
    ["Offset of field: AVCodecContext::opaque"]
        [::std::mem::offset_of!(AVCodecContext, opaque) - 48usize];
    ["Offset of field: AVCodecContext::bit_rate"]
        [::std::mem::offset_of!(AVCodecContext, bit_rate) - 56usize];
    ["Offset of field: AVCodecContext::bit_rate_tolerance"]
        [::std::mem::offset_of!(AVCodecContext, bit_rate_tolerance) - 64usize];
    ["Offset of field: AVCodecContext::global_quality"]
        [::std::mem::offset_of!(AVCodecContext, global_quality) - 68usize];
    ["Offset of field: AVCodecContext::compression_level"]
        [::std::mem::offset_of!(AVCodecContext, compression_level) - 72usize];
    ["Offset of field: AVCodecContext::flags"]
        [::std::mem::offset_of!(AVCodecContext, flags) - 76usize];
    ["Offset of field: AVCodecContext::flags2"]
        [::std::mem::offset_of!(AVCodecContext, flags2) - 80usize];
    ["Offset of field: AVCodecContext::extradata"]
        [::std::mem::offset_of!(AVCodecContext, extradata) - 88usize];
    ["Offset of field: AVCodecContext::extradata_size"]
        [::std::mem::offset_of!(AVCodecContext, extradata_size) - 96usize];
    ["Offset of field: AVCodecContext::time_base"]
        [::std::mem::offset_of!(AVCodecContext, time_base) - 100usize];
    ["Offset of field: AVCodecContext::ticks_per_frame"]
        [::std::mem::offset_of!(AVCodecContext, ticks_per_frame) - 108usize];
    ["Offset of field: AVCodecContext::delay"]
        [::std::mem::offset_of!(AVCodecContext, delay) - 112usize];
    ["Offset of field: AVCodecContext::width"]
        [::std::mem::offset_of!(AVCodecContext, width) - 116usize];
    ["Offset of field: AVCodecContext::height"]
        [::std::mem::offset_of!(AVCodecContext, height) - 120usize];
    ["Offset of field: AVCodecContext::coded_width"]
        [::std::mem::offset_of!(AVCodecContext, coded_width) - 124usize];
    ["Offset of field: AVCodecContext::coded_height"]
        [::std::mem::offset_of!(AVCodecContext, coded_height) - 128usize];
    ["Offset of field: AVCodecContext::gop_size"]
        [::std::mem::offset_of!(AVCodecContext, gop_size) - 132usize];
    ["Offset of field: AVCodecContext::pix_fmt"]
        [::std::mem::offset_of!(AVCodecContext, pix_fmt) - 136usize];
    ["Offset of field: AVCodecContext::draw_horiz_band"]
        [::std::mem::offset_of!(AVCodecContext, draw_horiz_band) - 144usize];
    ["Offset of field: AVCodecContext::get_format"]
        [::std::mem::offset_of!(AVCodecContext, get_format) - 152usize];
    ["Offset of field: AVCodecContext::max_b_frames"]
        [::std::mem::offset_of!(AVCodecContext, max_b_frames) - 160usize];
    ["Offset of field: AVCodecContext::b_quant_factor"]
        [::std::mem::offset_of!(AVCodecContext, b_quant_factor) - 164usize];
    ["Offset of field: AVCodecContext::b_frame_strategy"]
        [::std::mem::offset_of!(AVCodecContext, b_frame_strategy) - 168usize];
    ["Offset of field: AVCodecContext::b_quant_offset"]
        [::std::mem::offset_of!(AVCodecContext, b_quant_offset) - 172usize];
    ["Offset of field: AVCodecContext::has_b_frames"]
        [::std::mem::offset_of!(AVCodecContext, has_b_frames) - 176usize];
    ["Offset of field: AVCodecContext::mpeg_quant"]
        [::std::mem::offset_of!(AVCodecContext, mpeg_quant) - 180usize];
    ["Offset of field: AVCodecContext::i_quant_factor"]
        [::std::mem::offset_of!(AVCodecContext, i_quant_factor) - 184usize];
    ["Offset of field: AVCodecContext::i_quant_offset"]
        [::std::mem::offset_of!(AVCodecContext, i_quant_offset) - 188usize];
    ["Offset of field: AVCodecContext::lumi_masking"]
        [::std::mem::offset_of!(AVCodecContext, lumi_masking) - 192usize];
    ["Offset of field: AVCodecContext::temporal_cplx_masking"]
        [::std::mem::offset_of!(AVCodecContext, temporal_cplx_masking) - 196usize];
    ["Offset of field: AVCodecContext::spatial_cplx_masking"]
        [::std::mem::offset_of!(AVCodecContext, spatial_cplx_masking) - 200usize];
    ["Offset of field: AVCodecContext::p_masking"]
        [::std::mem::offset_of!(AVCodecContext, p_masking) - 204usize];
    ["Offset of field: AVCodecContext::dark_masking"]
        [::std::mem::offset_of!(AVCodecContext, dark_masking) - 208usize];
    ["Offset of field: AVCodecContext::slice_count"]
        [::std::mem::offset_of!(AVCodecContext, slice_count) - 212usize];
    ["Offset of field: AVCodecContext::prediction_method"]
        [::std::mem::offset_of!(AVCodecContext, prediction_method) - 216usize];
    ["Offset of field: AVCodecContext::slice_offset"]
        [::std::mem::offset_of!(AVCodecContext, slice_offset) - 224usize];
    ["Offset of field: AVCodecContext::sample_aspect_ratio"]
        [::std::mem::offset_of!(AVCodecContext, sample_aspect_ratio) - 232usize];
    ["Offset of field: AVCodecContext::me_cmp"]
        [::std::mem::offset_of!(AVCodecContext, me_cmp) - 240usize];
    ["Offset of field: AVCodecContext::me_sub_cmp"]
        [::std::mem::offset_of!(AVCodecContext, me_sub_cmp) - 244usize];
    ["Offset of field: AVCodecContext::mb_cmp"]
        [::std::mem::offset_of!(AVCodecContext, mb_cmp) - 248usize];
    ["Offset of field: AVCodecContext::ildct_cmp"]
        [::std::mem::offset_of!(AVCodecContext, ildct_cmp) - 252usize];
    ["Offset of field: AVCodecContext::dia_size"]
        [::std::mem::offset_of!(AVCodecContext, dia_size) - 256usize];
    ["Offset of field: AVCodecContext::last_predictor_count"]
        [::std::mem::offset_of!(AVCodecContext, last_predictor_count) - 260usize];
    ["Offset of field: AVCodecContext::pre_me"]
        [::std::mem::offset_of!(AVCodecContext, pre_me) - 264usize];
    ["Offset of field: AVCodecContext::me_pre_cmp"]
        [::std::mem::offset_of!(AVCodecContext, me_pre_cmp) - 268usize];
    ["Offset of field: AVCodecContext::pre_dia_size"]
        [::std::mem::offset_of!(AVCodecContext, pre_dia_size) - 272usize];
    ["Offset of field: AVCodecContext::me_subpel_quality"]
        [::std::mem::offset_of!(AVCodecContext, me_subpel_quality) - 276usize];
    ["Offset of field: AVCodecContext::me_range"]
        [::std::mem::offset_of!(AVCodecContext, me_range) - 280usize];
    ["Offset of field: AVCodecContext::slice_flags"]
        [::std::mem::offset_of!(AVCodecContext, slice_flags) - 284usize];
    ["Offset of field: AVCodecContext::mb_decision"]
        [::std::mem::offset_of!(AVCodecContext, mb_decision) - 288usize];
    ["Offset of field: AVCodecContext::intra_matrix"]
        [::std::mem::offset_of!(AVCodecContext, intra_matrix) - 296usize];
    ["Offset of field: AVCodecContext::inter_matrix"]
        [::std::mem::offset_of!(AVCodecContext, inter_matrix) - 304usize];
    ["Offset of field: AVCodecContext::scenechange_threshold"]
        [::std::mem::offset_of!(AVCodecContext, scenechange_threshold) - 312usize];
    ["Offset of field: AVCodecContext::noise_reduction"]
        [::std::mem::offset_of!(AVCodecContext, noise_reduction) - 316usize];
    ["Offset of field: AVCodecContext::intra_dc_precision"]
        [::std::mem::offset_of!(AVCodecContext, intra_dc_precision) - 320usize];
    ["Offset of field: AVCodecContext::skip_top"]
        [::std::mem::offset_of!(AVCodecContext, skip_top) - 324usize];
    ["Offset of field: AVCodecContext::skip_bottom"]
        [::std::mem::offset_of!(AVCodecContext, skip_bottom) - 328usize];
    ["Offset of field: AVCodecContext::mb_lmin"]
        [::std::mem::offset_of!(AVCodecContext, mb_lmin) - 332usize];
    ["Offset of field: AVCodecContext::mb_lmax"]
        [::std::mem::offset_of!(AVCodecContext, mb_lmax) - 336usize];
    ["Offset of field: AVCodecContext::me_penalty_compensation"]
        [::std::mem::offset_of!(AVCodecContext, me_penalty_compensation) - 340usize];
    ["Offset of field: AVCodecContext::bidir_refine"]
        [::std::mem::offset_of!(AVCodecContext, bidir_refine) - 344usize];
    ["Offset of field: AVCodecContext::brd_scale"]
        [::std::mem::offset_of!(AVCodecContext, brd_scale) - 348usize];
    ["Offset of field: AVCodecContext::keyint_min"]
        [::std::mem::offset_of!(AVCodecContext, keyint_min) - 352usize];
    ["Offset of field: AVCodecContext::refs"]
        [::std::mem::offset_of!(AVCodecContext, refs) - 356usize];
    ["Offset of field: AVCodecContext::chromaoffset"]
        [::std::mem::offset_of!(AVCodecContext, chromaoffset) - 360usize];
    ["Offset of field: AVCodecContext::mv0_threshold"]
        [::std::mem::offset_of!(AVCodecContext, mv0_threshold) - 364usize];
    ["Offset of field: AVCodecContext::b_sensitivity"]
        [::std::mem::offset_of!(AVCodecContext, b_sensitivity) - 368usize];
    ["Offset of field: AVCodecContext::color_primaries"]
        [::std::mem::offset_of!(AVCodecContext, color_primaries) - 372usize];
    ["Offset of field: AVCodecContext::color_trc"]
        [::std::mem::offset_of!(AVCodecContext, color_trc) - 376usize];
    ["Offset of field: AVCodecContext::colorspace"]
        [::std::mem::offset_of!(AVCodecContext, colorspace) - 380usize];
    ["Offset of field: AVCodecContext::color_range"]
        [::std::mem::offset_of!(AVCodecContext, color_range) - 384usize];
    ["Offset of field: AVCodecContext::chroma_sample_location"]
        [::std::mem::offset_of!(AVCodecContext, chroma_sample_location) - 388usize];
    ["Offset of field: AVCodecContext::slices"]
        [::std::mem::offset_of!(AVCodecContext, slices) - 392usize];
    ["Offset of field: AVCodecContext::field_order"]
        [::std::mem::offset_of!(AVCodecContext, field_order) - 396usize];
    ["Offset of field: AVCodecContext::sample_rate"]
        [::std::mem::offset_of!(AVCodecContext, sample_rate) - 400usize];
    ["Offset of field: AVCodecContext::channels"]
        [::std::mem::offset_of!(AVCodecContext, channels) - 404usize];
    ["Offset of field: AVCodecContext::sample_fmt"]
        [::std::mem::offset_of!(AVCodecContext, sample_fmt) - 408usize];
    ["Offset of field: AVCodecContext::frame_size"]
        [::std::mem::offset_of!(AVCodecContext, frame_size) - 412usize];
    ["Offset of field: AVCodecContext::frame_number"]
        [::std::mem::offset_of!(AVCodecContext, frame_number) - 416usize];
    ["Offset of field: AVCodecContext::block_align"]
        [::std::mem::offset_of!(AVCodecContext, block_align) - 420usize];
    ["Offset of field: AVCodecContext::cutoff"]
        [::std::mem::offset_of!(AVCodecContext, cutoff) - 424usize];
    ["Offset of field: AVCodecContext::channel_layout"]
        [::std::mem::offset_of!(AVCodecContext, channel_layout) - 432usize];
    ["Offset of field: AVCodecContext::request_channel_layout"]
        [::std::mem::offset_of!(AVCodecContext, request_channel_layout) - 440usize];
    ["Offset of field: AVCodecContext::audio_service_type"]
        [::std::mem::offset_of!(AVCodecContext, audio_service_type) - 448usize];
    ["Offset of field: AVCodecContext::request_sample_fmt"]
        [::std::mem::offset_of!(AVCodecContext, request_sample_fmt) - 452usize];
    ["Offset of field: AVCodecContext::get_buffer2"]
        [::std::mem::offset_of!(AVCodecContext, get_buffer2) - 456usize];
    ["Offset of field: AVCodecContext::refcounted_frames"]
        [::std::mem::offset_of!(AVCodecContext, refcounted_frames) - 464usize];
    ["Offset of field: AVCodecContext::qcompress"]
        [::std::mem::offset_of!(AVCodecContext, qcompress) - 468usize];
    ["Offset of field: AVCodecContext::qblur"]
        [::std::mem::offset_of!(AVCodecContext, qblur) - 472usize];
    ["Offset of field: AVCodecContext::qmin"]
        [::std::mem::offset_of!(AVCodecContext, qmin) - 476usize];
    ["Offset of field: AVCodecContext::qmax"]
        [::std::mem::offset_of!(AVCodecContext, qmax) - 480usize];
    ["Offset of field: AVCodecContext::max_qdiff"]
        [::std::mem::offset_of!(AVCodecContext, max_qdiff) - 484usize];
    ["Offset of field: AVCodecContext::rc_buffer_size"]
        [::std::mem::offset_of!(AVCodecContext, rc_buffer_size) - 488usize];
    ["Offset of field: AVCodecContext::rc_override_count"]
        [::std::mem::offset_of!(AVCodecContext, rc_override_count) - 492usize];
    ["Offset of field: AVCodecContext::rc_override"]
        [::std::mem::offset_of!(AVCodecContext, rc_override) - 496usize];
    ["Offset of field: AVCodecContext::rc_max_rate"]
        [::std::mem::offset_of!(AVCodecContext, rc_max_rate) - 504usize];
    ["Offset of field: AVCodecContext::rc_min_rate"]
        [::std::mem::offset_of!(AVCodecContext, rc_min_rate) - 512usize];
    ["Offset of field: AVCodecContext::rc_max_available_vbv_use"]
        [::std::mem::offset_of!(AVCodecContext, rc_max_available_vbv_use) - 520usize];
    ["Offset of field: AVCodecContext::rc_min_vbv_overflow_use"]
        [::std::mem::offset_of!(AVCodecContext, rc_min_vbv_overflow_use) - 524usize];
    ["Offset of field: AVCodecContext::rc_initial_buffer_occupancy"]
        [::std::mem::offset_of!(AVCodecContext, rc_initial_buffer_occupancy) - 528usize];
    ["Offset of field: AVCodecContext::coder_type"]
        [::std::mem::offset_of!(AVCodecContext, coder_type) - 532usize];
    ["Offset of field: AVCodecContext::context_model"]
        [::std::mem::offset_of!(AVCodecContext, context_model) - 536usize];
    ["Offset of field: AVCodecContext::frame_skip_threshold"]
        [::std::mem::offset_of!(AVCodecContext, frame_skip_threshold) - 540usize];
    ["Offset of field: AVCodecContext::frame_skip_factor"]
        [::std::mem::offset_of!(AVCodecContext, frame_skip_factor) - 544usize];
    ["Offset of field: AVCodecContext::frame_skip_exp"]
        [::std::mem::offset_of!(AVCodecContext, frame_skip_exp) - 548usize];
    ["Offset of field: AVCodecContext::frame_skip_cmp"]
        [::std::mem::offset_of!(AVCodecContext, frame_skip_cmp) - 552usize];
    ["Offset of field: AVCodecContext::trellis"]
        [::std::mem::offset_of!(AVCodecContext, trellis) - 556usize];
    ["Offset of field: AVCodecContext::min_prediction_order"]
        [::std::mem::offset_of!(AVCodecContext, min_prediction_order) - 560usize];
    ["Offset of field: AVCodecContext::max_prediction_order"]
        [::std::mem::offset_of!(AVCodecContext, max_prediction_order) - 564usize];
    ["Offset of field: AVCodecContext::timecode_frame_start"]
        [::std::mem::offset_of!(AVCodecContext, timecode_frame_start) - 568usize];
    ["Offset of field: AVCodecContext::rtp_callback"]
        [::std::mem::offset_of!(AVCodecContext, rtp_callback) - 576usize];
    ["Offset of field: AVCodecContext::rtp_payload_size"]
        [::std::mem::offset_of!(AVCodecContext, rtp_payload_size) - 584usize];
    ["Offset of field: AVCodecContext::mv_bits"]
        [::std::mem::offset_of!(AVCodecContext, mv_bits) - 588usize];
    ["Offset of field: AVCodecContext::header_bits"]
        [::std::mem::offset_of!(AVCodecContext, header_bits) - 592usize];
    ["Offset of field: AVCodecContext::i_tex_bits"]
        [::std::mem::offset_of!(AVCodecContext, i_tex_bits) - 596usize];
    ["Offset of field: AVCodecContext::p_tex_bits"]
        [::std::mem::offset_of!(AVCodecContext, p_tex_bits) - 600usize];
    ["Offset of field: AVCodecContext::i_count"]
        [::std::mem::offset_of!(AVCodecContext, i_count) - 604usize];
    ["Offset of field: AVCodecContext::p_count"]
        [::std::mem::offset_of!(AVCodecContext, p_count) - 608usize];
    ["Offset of field: AVCodecContext::skip_count"]
        [::std::mem::offset_of!(AVCodecContext, skip_count) - 612usize];
    ["Offset of field: AVCodecContext::misc_bits"]
        [::std::mem::offset_of!(AVCodecContext, misc_bits) - 616usize];
    ["Offset of field: AVCodecContext::frame_bits"]
        [::std::mem::offset_of!(AVCodecContext, frame_bits) - 620usize];
    ["Offset of field: AVCodecContext::stats_out"]
        [::std::mem::offset_of!(AVCodecContext, stats_out) - 624usize];
    ["Offset of field: AVCodecContext::stats_in"]
        [::std::mem::offset_of!(AVCodecContext, stats_in) - 632usize];
    ["Offset of field: AVCodecContext::workaround_bugs"]
        [::std::mem::offset_of!(AVCodecContext, workaround_bugs) - 640usize];
    ["Offset of field: AVCodecContext::strict_std_compliance"]
        [::std::mem::offset_of!(AVCodecContext, strict_std_compliance) - 644usize];
    ["Offset of field: AVCodecContext::error_concealment"]
        [::std::mem::offset_of!(AVCodecContext, error_concealment) - 648usize];
    ["Offset of field: AVCodecContext::debug"]
        [::std::mem::offset_of!(AVCodecContext, debug) - 652usize];
    ["Offset of field: AVCodecContext::err_recognition"]
        [::std::mem::offset_of!(AVCodecContext, err_recognition) - 656usize];
    ["Offset of field: AVCodecContext::reordered_opaque"]
        [::std::mem::offset_of!(AVCodecContext, reordered_opaque) - 664usize];
    ["Offset of field: AVCodecContext::hwaccel"]
        [::std::mem::offset_of!(AVCodecContext, hwaccel) - 672usize];
    ["Offset of field: AVCodecContext::hwaccel_context"]
        [::std::mem::offset_of!(AVCodecContext, hwaccel_context) - 680usize];
    ["Offset of field: AVCodecContext::error"]
        [::std::mem::offset_of!(AVCodecContext, error) - 688usize];
    ["Offset of field: AVCodecContext::dct_algo"]
        [::std::mem::offset_of!(AVCodecContext, dct_algo) - 752usize];
    ["Offset of field: AVCodecContext::idct_algo"]
        [::std::mem::offset_of!(AVCodecContext, idct_algo) - 756usize];
    ["Offset of field: AVCodecContext::bits_per_coded_sample"]
        [::std::mem::offset_of!(AVCodecContext, bits_per_coded_sample) - 760usize];
    ["Offset of field: AVCodecContext::bits_per_raw_sample"]
        [::std::mem::offset_of!(AVCodecContext, bits_per_raw_sample) - 764usize];
    ["Offset of field: AVCodecContext::lowres"]
        [::std::mem::offset_of!(AVCodecContext, lowres) - 768usize];
    ["Offset of field: AVCodecContext::coded_frame"]
        [::std::mem::offset_of!(AVCodecContext, coded_frame) - 776usize];
    ["Offset of field: AVCodecContext::thread_count"]
        [::std::mem::offset_of!(AVCodecContext, thread_count) - 784usize];
    ["Offset of field: AVCodecContext::thread_type"]
        [::std::mem::offset_of!(AVCodecContext, thread_type) - 788usize];
    ["Offset of field: AVCodecContext::active_thread_type"]
        [::std::mem::offset_of!(AVCodecContext, active_thread_type) - 792usize];
    ["Offset of field: AVCodecContext::thread_safe_callbacks"]
        [::std::mem::offset_of!(AVCodecContext, thread_safe_callbacks) - 796usize];
    ["Offset of field: AVCodecContext::execute"]
        [::std::mem::offset_of!(AVCodecContext, execute) - 800usize];
    ["Offset of field: AVCodecContext::execute2"]
        [::std::mem::offset_of!(AVCodecContext, execute2) - 808usize];
    ["Offset of field: AVCodecContext::nsse_weight"]
        [::std::mem::offset_of!(AVCodecContext, nsse_weight) - 816usize];
    ["Offset of field: AVCodecContext::profile"]
        [::std::mem::offset_of!(AVCodecContext, profile) - 820usize];
    ["Offset of field: AVCodecContext::level"]
        [::std::mem::offset_of!(AVCodecContext, level) - 824usize];
    ["Offset of field: AVCodecContext::skip_loop_filter"]
        [::std::mem::offset_of!(AVCodecContext, skip_loop_filter) - 828usize];
    ["Offset of field: AVCodecContext::skip_idct"]
        [::std::mem::offset_of!(AVCodecContext, skip_idct) - 832usize];
    ["Offset of field: AVCodecContext::skip_frame"]
        [::std::mem::offset_of!(AVCodecContext, skip_frame) - 836usize];
    ["Offset of field: AVCodecContext::subtitle_header"]
        [::std::mem::offset_of!(AVCodecContext, subtitle_header) - 840usize];
    ["Offset of field: AVCodecContext::subtitle_header_size"]
        [::std::mem::offset_of!(AVCodecContext, subtitle_header_size) - 848usize];
    ["Offset of field: AVCodecContext::vbv_delay"]
        [::std::mem::offset_of!(AVCodecContext, vbv_delay) - 856usize];
    ["Offset of field: AVCodecContext::side_data_only_packets"]
        [::std::mem::offset_of!(AVCodecContext, side_data_only_packets) - 864usize];
    ["Offset of field: AVCodecContext::initial_padding"]
        [::std::mem::offset_of!(AVCodecContext, initial_padding) - 868usize];
    ["Offset of field: AVCodecContext::framerate"]
        [::std::mem::offset_of!(AVCodecContext, framerate) - 872usize];
    ["Offset of field: AVCodecContext::sw_pix_fmt"]
        [::std::mem::offset_of!(AVCodecContext, sw_pix_fmt) - 880usize];
    ["Offset of field: AVCodecContext::pkt_timebase"]
        [::std::mem::offset_of!(AVCodecContext, pkt_timebase) - 884usize];
    ["Offset of field: AVCodecContext::codec_descriptor"]
        [::std::mem::offset_of!(AVCodecContext, codec_descriptor) - 896usize];
    ["Offset of field: AVCodecContext::pts_correction_num_faulty_pts"]
        [::std::mem::offset_of!(AVCodecContext, pts_correction_num_faulty_pts) - 904usize];
    ["Offset of field: AVCodecContext::pts_correction_num_faulty_dts"]
        [::std::mem::offset_of!(AVCodecContext, pts_correction_num_faulty_dts) - 912usize];
    ["Offset of field: AVCodecContext::pts_correction_last_pts"]
        [::std::mem::offset_of!(AVCodecContext, pts_correction_last_pts) - 920usize];
    ["Offset of field: AVCodecContext::pts_correction_last_dts"]
        [::std::mem::offset_of!(AVCodecContext, pts_correction_last_dts) - 928usize];
    ["Offset of field: AVCodecContext::sub_charenc"]
        [::std::mem::offset_of!(AVCodecContext, sub_charenc) - 936usize];
    ["Offset of field: AVCodecContext::sub_charenc_mode"]
        [::std::mem::offset_of!(AVCodecContext, sub_charenc_mode) - 944usize];
    ["Offset of field: AVCodecContext::skip_alpha"]
        [::std::mem::offset_of!(AVCodecContext, skip_alpha) - 948usize];
    ["Offset of field: AVCodecContext::seek_preroll"]
        [::std::mem::offset_of!(AVCodecContext, seek_preroll) - 952usize];
    ["Offset of field: AVCodecContext::debug_mv"]
        [::std::mem::offset_of!(AVCodecContext, debug_mv) - 956usize];
    ["Offset of field: AVCodecContext::chroma_intra_matrix"]
        [::std::mem::offset_of!(AVCodecContext, chroma_intra_matrix) - 960usize];
    ["Offset of field: AVCodecContext::dump_separator"]
        [::std::mem::offset_of!(AVCodecContext, dump_separator) - 968usize];
    ["Offset of field: AVCodecContext::codec_whitelist"]
        [::std::mem::offset_of!(AVCodecContext, codec_whitelist) - 976usize];
    ["Offset of field: AVCodecContext::properties"]
        [::std::mem::offset_of!(AVCodecContext, properties) - 984usize];
    ["Offset of field: AVCodecContext::coded_side_data"]
        [::std::mem::offset_of!(AVCodecContext, coded_side_data) - 992usize];
    ["Offset of field: AVCodecContext::nb_coded_side_data"]
        [::std::mem::offset_of!(AVCodecContext, nb_coded_side_data) - 1000usize];
    ["Offset of field: AVCodecContext::hw_frames_ctx"]
        [::std::mem::offset_of!(AVCodecContext, hw_frames_ctx) - 1008usize];
    ["Offset of field: AVCodecContext::sub_text_format"]
        [::std::mem::offset_of!(AVCodecContext, sub_text_format) - 1016usize];
    ["Offset of field: AVCodecContext::trailing_padding"]
        [::std::mem::offset_of!(AVCodecContext, trailing_padding) - 1020usize];
    ["Offset of field: AVCodecContext::max_pixels"]
        [::std::mem::offset_of!(AVCodecContext, max_pixels) - 1024usize];
    ["Offset of field: AVCodecContext::hw_device_ctx"]
        [::std::mem::offset_of!(AVCodecContext, hw_device_ctx) - 1032usize];
    ["Offset of field: AVCodecContext::hwaccel_flags"]
        [::std::mem::offset_of!(AVCodecContext, hwaccel_flags) - 1040usize];
    ["Offset of field: AVCodecContext::apply_cropping"]
        [::std::mem::offset_of!(AVCodecContext, apply_cropping) - 1044usize];
    ["Offset of field: AVCodecContext::extra_hw_frames"]
        [::std::mem::offset_of!(AVCodecContext, extra_hw_frames) - 1048usize];
    ["Offset of field: AVCodecContext::discard_damaged_percentage"]
        [::std::mem::offset_of!(AVCodecContext, discard_damaged_percentage) - 1052usize];
    ["Offset of field: AVCodecContext::max_samples"]
        [::std::mem::offset_of!(AVCodecContext, max_samples) - 1056usize];
    ["Offset of field: AVCodecContext::export_side_data"]
        [::std::mem::offset_of!(AVCodecContext, export_side_data) - 1064usize];
    ["Offset of field: AVCodecContext::get_encode_buffer"]
        [::std::mem::offset_of!(AVCodecContext, get_encode_buffer) - 1072usize];
};
extern "C" {
    #[doc = " Accessors for some AVCodecContext fields. These used to be provided for ABI\n compatibility, and do not need to be used anymore."]
    pub fn av_codec_get_pkt_timebase(avctx: *const AVCodecContext) -> AVRational;
}
extern "C" {
    pub fn av_codec_set_pkt_timebase(avctx: *mut AVCodecContext, val: AVRational);
}
extern "C" {
    pub fn av_codec_get_codec_descriptor(avctx: *const AVCodecContext) -> *const AVCodecDescriptor;
}
extern "C" {
    pub fn av_codec_set_codec_descriptor(
        avctx: *mut AVCodecContext,
        desc: *const AVCodecDescriptor,
    );
}
extern "C" {
    pub fn av_codec_get_codec_properties(avctx: *const AVCodecContext) -> libc::c_uint;
}
extern "C" {
    pub fn av_codec_get_lowres(avctx: *const AVCodecContext) -> libc::c_int;
}
extern "C" {
    pub fn av_codec_set_lowres(avctx: *mut AVCodecContext, val: libc::c_int);
}
extern "C" {
    pub fn av_codec_get_seek_preroll(avctx: *const AVCodecContext) -> libc::c_int;
}
extern "C" {
    pub fn av_codec_set_seek_preroll(avctx: *mut AVCodecContext, val: libc::c_int);
}
extern "C" {
    pub fn av_codec_get_chroma_intra_matrix(avctx: *const AVCodecContext) -> *mut u16;
}
extern "C" {
    pub fn av_codec_set_chroma_intra_matrix(avctx: *mut AVCodecContext, val: *mut u16);
}
extern "C" {
    pub fn av_codec_get_max_lowres(codec: *const AVCodec) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MpegEncContext {
    _unused: [u8; 0],
}
#[doc = " @defgroup lavc_hwaccel AVHWAccel\n\n @note  Nothing in this structure should be accessed by the user.  At some\n        point in future it will not be externally visible at all.\n\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVHWAccel {
    #[doc = " Name of the hardware accelerated codec.\n The name is globally unique among encoders and among decoders (but an\n encoder and a decoder can share the same name)."]
    pub name: *const libc::c_char,
    #[doc = " Type of codec implemented by the hardware accelerator.\n\n See AVMEDIA_TYPE_xxx"]
    pub type_: AVMediaType,
    #[doc = " Codec implemented by the hardware accelerator.\n\n See AV_CODEC_ID_xxx"]
    pub id: AVCodecID,
    #[doc = " Supported pixel format.\n\n Only hardware accelerated formats are supported here."]
    pub pix_fmt: AVPixelFormat,
    #[doc = " Hardware accelerated codec capabilities.\n see AV_HWACCEL_CODEC_CAP_*"]
    pub capabilities: libc::c_int,
    #[doc = " Allocate a custom buffer"]
    pub alloc_frame: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, frame: *mut AVFrame) -> libc::c_int,
    >,
    #[doc = " Called at the beginning of each frame or field picture.\n\n Meaningful frame information (codec specific) is guaranteed to\n be parsed at this point. This function is mandatory.\n\n Note that buf can be NULL along with buf_size set to 0.\n Otherwise, this means the whole frame is available at this point.\n\n @param avctx the codec context\n @param buf the frame data buffer base\n @param buf_size the size of the frame in bytes\n @return zero if successful, a negative value otherwise"]
    pub start_frame: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            buf: *const u8,
            buf_size: u32,
        ) -> libc::c_int,
    >,
    #[doc = " Callback for parameter data (SPS/PPS/VPS etc).\n\n Useful for hardware decoders which keep persistent state about the\n video parameters, and need to receive any changes to update that state.\n\n @param avctx the codec context\n @param type the nal unit type\n @param buf the nal unit data buffer\n @param buf_size the size of the nal unit in bytes\n @return zero if successful, a negative value otherwise"]
    pub decode_params: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            type_: libc::c_int,
            buf: *const u8,
            buf_size: u32,
        ) -> libc::c_int,
    >,
    #[doc = " Callback for each slice.\n\n Meaningful slice information (codec specific) is guaranteed to\n be parsed at this point. This function is mandatory.\n The only exception is XvMC, that works on MB level.\n\n @param avctx the codec context\n @param buf the slice data buffer base\n @param buf_size the size of the slice in bytes\n @return zero if successful, a negative value otherwise"]
    pub decode_slice: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            buf: *const u8,
            buf_size: u32,
        ) -> libc::c_int,
    >,
    #[doc = " Called at the end of each frame or field picture.\n\n The whole picture is parsed at this point and can now be sent\n to the hardware accelerator. This function is mandatory.\n\n @param avctx the codec context\n @return zero if successful, a negative value otherwise"]
    pub end_frame:
        ::std::option::Option<unsafe extern "C" fn(avctx: *mut AVCodecContext) -> libc::c_int>,
    #[doc = " Size of per-frame hardware accelerator private data.\n\n Private data is allocated with av_mallocz() before\n AVCodecContext.get_buffer() and deallocated after\n AVCodecContext.release_buffer()."]
    pub frame_priv_data_size: libc::c_int,
    #[doc = " Called for every Macroblock in a slice.\n\n XvMC uses it to replace the ff_mpv_reconstruct_mb().\n Instead of decoding to raw picture, MB parameters are\n stored in an array provided by the video driver.\n\n @param s the mpeg context"]
    pub decode_mb: ::std::option::Option<unsafe extern "C" fn(s: *mut MpegEncContext)>,
    #[doc = " Initialize the hwaccel private data.\n\n This will be called from ff_get_format(), after hwaccel and\n hwaccel_context are set and the hwaccel private data in AVCodecInternal\n is allocated."]
    pub init:
        ::std::option::Option<unsafe extern "C" fn(avctx: *mut AVCodecContext) -> libc::c_int>,
    #[doc = " Uninitialize the hwaccel private data.\n\n This will be called from get_format() or avcodec_close(), after hwaccel\n and hwaccel_context are already uninitialized."]
    pub uninit:
        ::std::option::Option<unsafe extern "C" fn(avctx: *mut AVCodecContext) -> libc::c_int>,
    #[doc = " Size of the private data to allocate in\n AVCodecInternal.hwaccel_priv_data."]
    pub priv_data_size: libc::c_int,
    #[doc = " Internal hwaccel capabilities."]
    pub caps_internal: libc::c_int,
    #[doc = " Fill the given hw_frames context with current codec parameters. Called\n from get_format. Refer to avcodec_get_hw_frames_parameters() for\n details.\n\n This CAN be called before AVHWAccel.init is called, and you must assume\n that avctx->hwaccel_priv_data is invalid."]
    pub frame_params: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            hw_frames_ctx: *mut AVBufferRef,
        ) -> libc::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVHWAccel"][::std::mem::size_of::<AVHWAccel>() - 112usize];
    ["Alignment of AVHWAccel"][::std::mem::align_of::<AVHWAccel>() - 8usize];
    ["Offset of field: AVHWAccel::name"][::std::mem::offset_of!(AVHWAccel, name) - 0usize];
    ["Offset of field: AVHWAccel::type_"][::std::mem::offset_of!(AVHWAccel, type_) - 8usize];
    ["Offset of field: AVHWAccel::id"][::std::mem::offset_of!(AVHWAccel, id) - 12usize];
    ["Offset of field: AVHWAccel::pix_fmt"][::std::mem::offset_of!(AVHWAccel, pix_fmt) - 16usize];
    ["Offset of field: AVHWAccel::capabilities"]
        [::std::mem::offset_of!(AVHWAccel, capabilities) - 20usize];
    ["Offset of field: AVHWAccel::alloc_frame"]
        [::std::mem::offset_of!(AVHWAccel, alloc_frame) - 24usize];
    ["Offset of field: AVHWAccel::start_frame"]
        [::std::mem::offset_of!(AVHWAccel, start_frame) - 32usize];
    ["Offset of field: AVHWAccel::decode_params"]
        [::std::mem::offset_of!(AVHWAccel, decode_params) - 40usize];
    ["Offset of field: AVHWAccel::decode_slice"]
        [::std::mem::offset_of!(AVHWAccel, decode_slice) - 48usize];
    ["Offset of field: AVHWAccel::end_frame"]
        [::std::mem::offset_of!(AVHWAccel, end_frame) - 56usize];
    ["Offset of field: AVHWAccel::frame_priv_data_size"]
        [::std::mem::offset_of!(AVHWAccel, frame_priv_data_size) - 64usize];
    ["Offset of field: AVHWAccel::decode_mb"]
        [::std::mem::offset_of!(AVHWAccel, decode_mb) - 72usize];
    ["Offset of field: AVHWAccel::init"][::std::mem::offset_of!(AVHWAccel, init) - 80usize];
    ["Offset of field: AVHWAccel::uninit"][::std::mem::offset_of!(AVHWAccel, uninit) - 88usize];
    ["Offset of field: AVHWAccel::priv_data_size"]
        [::std::mem::offset_of!(AVHWAccel, priv_data_size) - 96usize];
    ["Offset of field: AVHWAccel::caps_internal"]
        [::std::mem::offset_of!(AVHWAccel, caps_internal) - 100usize];
    ["Offset of field: AVHWAccel::frame_params"]
        [::std::mem::offset_of!(AVHWAccel, frame_params) - 104usize];
};
#[doc = " Picture data structure.\n\n Up to four components can be stored into it, the last component is\n alpha.\n @deprecated use AVFrame or imgutils functions instead"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPicture {
    #[doc = "< pointers to the image data planes"]
    pub data: [*mut u8; 8usize],
    #[doc = "< number of bytes per line"]
    pub linesize: [libc::c_int; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVPicture"][::std::mem::size_of::<AVPicture>() - 96usize];
    ["Alignment of AVPicture"][::std::mem::align_of::<AVPicture>() - 8usize];
    ["Offset of field: AVPicture::data"][::std::mem::offset_of!(AVPicture, data) - 0usize];
    ["Offset of field: AVPicture::linesize"][::std::mem::offset_of!(AVPicture, linesize) - 64usize];
};
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVSubtitleType {
    SUBTITLE_NONE = 0,
    #[doc = "< A bitmap, pict will be set"]
    SUBTITLE_BITMAP = 1,
    #[doc = " Plain text, the text field must be set by the decoder and is\n authoritative. ass and pict fields may contain approximations."]
    SUBTITLE_TEXT = 2,
    #[doc = " Formatted text, the ass field must be set by the decoder and is\n authoritative. pict and text fields may contain approximations."]
    SUBTITLE_ASS = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVSubtitleRect {
    #[doc = "< top left corner  of pict, undefined when pict is not set"]
    pub x: libc::c_int,
    #[doc = "< top left corner  of pict, undefined when pict is not set"]
    pub y: libc::c_int,
    #[doc = "< width            of pict, undefined when pict is not set"]
    pub w: libc::c_int,
    #[doc = "< height           of pict, undefined when pict is not set"]
    pub h: libc::c_int,
    #[doc = "< number of colors in pict, undefined when pict is not set"]
    pub nb_colors: libc::c_int,
    #[doc = " @deprecated unused"]
    pub pict: AVPicture,
    #[doc = " data+linesize for the bitmap of this subtitle.\n Can be set for text/ass as well once they are rendered."]
    pub data: [*mut u8; 4usize],
    pub linesize: [libc::c_int; 4usize],
    pub type_: AVSubtitleType,
    #[doc = "< 0 terminated plain UTF-8 text"]
    pub text: *mut libc::c_char,
    #[doc = " 0 terminated ASS/SSA compatible event line.\n The presentation of this is unaffected by the other values in this\n struct."]
    pub ass: *mut libc::c_char,
    pub flags: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVSubtitleRect"][::std::mem::size_of::<AVSubtitleRect>() - 200usize];
    ["Alignment of AVSubtitleRect"][::std::mem::align_of::<AVSubtitleRect>() - 8usize];
    ["Offset of field: AVSubtitleRect::x"][::std::mem::offset_of!(AVSubtitleRect, x) - 0usize];
    ["Offset of field: AVSubtitleRect::y"][::std::mem::offset_of!(AVSubtitleRect, y) - 4usize];
    ["Offset of field: AVSubtitleRect::w"][::std::mem::offset_of!(AVSubtitleRect, w) - 8usize];
    ["Offset of field: AVSubtitleRect::h"][::std::mem::offset_of!(AVSubtitleRect, h) - 12usize];
    ["Offset of field: AVSubtitleRect::nb_colors"]
        [::std::mem::offset_of!(AVSubtitleRect, nb_colors) - 16usize];
    ["Offset of field: AVSubtitleRect::pict"]
        [::std::mem::offset_of!(AVSubtitleRect, pict) - 24usize];
    ["Offset of field: AVSubtitleRect::data"]
        [::std::mem::offset_of!(AVSubtitleRect, data) - 120usize];
    ["Offset of field: AVSubtitleRect::linesize"]
        [::std::mem::offset_of!(AVSubtitleRect, linesize) - 152usize];
    ["Offset of field: AVSubtitleRect::type_"]
        [::std::mem::offset_of!(AVSubtitleRect, type_) - 168usize];
    ["Offset of field: AVSubtitleRect::text"]
        [::std::mem::offset_of!(AVSubtitleRect, text) - 176usize];
    ["Offset of field: AVSubtitleRect::ass"]
        [::std::mem::offset_of!(AVSubtitleRect, ass) - 184usize];
    ["Offset of field: AVSubtitleRect::flags"]
        [::std::mem::offset_of!(AVSubtitleRect, flags) - 192usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVSubtitle {
    pub format: u16,
    pub start_display_time: u32,
    pub end_display_time: u32,
    pub num_rects: libc::c_uint,
    pub rects: *mut *mut AVSubtitleRect,
    #[doc = "< Same as packet pts, in AV_TIME_BASE"]
    pub pts: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVSubtitle"][::std::mem::size_of::<AVSubtitle>() - 32usize];
    ["Alignment of AVSubtitle"][::std::mem::align_of::<AVSubtitle>() - 8usize];
    ["Offset of field: AVSubtitle::format"][::std::mem::offset_of!(AVSubtitle, format) - 0usize];
    ["Offset of field: AVSubtitle::start_display_time"]
        [::std::mem::offset_of!(AVSubtitle, start_display_time) - 4usize];
    ["Offset of field: AVSubtitle::end_display_time"]
        [::std::mem::offset_of!(AVSubtitle, end_display_time) - 8usize];
    ["Offset of field: AVSubtitle::num_rects"]
        [::std::mem::offset_of!(AVSubtitle, num_rects) - 12usize];
    ["Offset of field: AVSubtitle::rects"][::std::mem::offset_of!(AVSubtitle, rects) - 16usize];
    ["Offset of field: AVSubtitle::pts"][::std::mem::offset_of!(AVSubtitle, pts) - 24usize];
};
extern "C" {
    #[doc = " If c is NULL, returns the first registered codec,\n if c is non-NULL, returns the next registered codec after c,\n or NULL if c is the last one."]
    pub fn av_codec_next(c: *const AVCodec) -> *mut AVCodec;
}
extern "C" {
    #[doc = " Return the LIBAVCODEC_VERSION_INT constant."]
    pub fn avcodec_version() -> libc::c_uint;
}
extern "C" {
    #[doc = " Return the libavcodec build-time configuration."]
    pub fn avcodec_configuration() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return the libavcodec license."]
    pub fn avcodec_license() -> *const libc::c_char;
}
extern "C" {
    #[doc = " @deprecated Calling this function is unnecessary."]
    pub fn avcodec_register(codec: *mut AVCodec);
}
extern "C" {
    #[doc = " @deprecated Calling this function is unnecessary."]
    pub fn avcodec_register_all();
}
extern "C" {
    #[doc = " Allocate an AVCodecContext and set its fields to default values. The\n resulting struct should be freed with avcodec_free_context().\n\n @param codec if non-NULL, allocate private data and initialize defaults\n              for the given codec. It is illegal to then call avcodec_open2()\n              with a different codec.\n              If NULL, then the codec-specific defaults won't be initialized,\n              which may result in suboptimal default settings (this is\n              important mainly for encoders, e.g. libx264).\n\n @return An AVCodecContext filled with default values or NULL on failure."]
    pub fn avcodec_alloc_context3(codec: *const AVCodec) -> *mut AVCodecContext;
}
extern "C" {
    #[doc = " Free the codec context and everything associated with it and write NULL to\n the provided pointer."]
    pub fn avcodec_free_context(avctx: *mut *mut AVCodecContext);
}
extern "C" {
    #[doc = " @deprecated This function should not be used, as closing and opening a codec\n context multiple time is not supported. A new codec context should be\n allocated for each new use."]
    pub fn avcodec_get_context_defaults3(
        s: *mut AVCodecContext,
        codec: *const AVCodec,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the AVClass for AVCodecContext. It can be used in combination with\n AV_OPT_SEARCH_FAKE_OBJ for examining options.\n\n @see av_opt_find()."]
    pub fn avcodec_get_class() -> *const AVClass;
}
extern "C" {
    #[doc = " @deprecated This function should not be used."]
    pub fn avcodec_get_frame_class() -> *const AVClass;
}
extern "C" {
    #[doc = " Get the AVClass for AVSubtitleRect. It can be used in combination with\n AV_OPT_SEARCH_FAKE_OBJ for examining options.\n\n @see av_opt_find()."]
    pub fn avcodec_get_subtitle_rect_class() -> *const AVClass;
}
extern "C" {
    #[doc = " Copy the settings of the source AVCodecContext into the destination\n AVCodecContext. The resulting destination codec context will be\n unopened, i.e. you are required to call avcodec_open2() before you\n can use this AVCodecContext to decode/encode video/audio data.\n\n @param dest target codec context, should be initialized with\n             avcodec_alloc_context3(NULL), but otherwise uninitialized\n @param src source codec context\n @return AVERROR() on error (e.g. memory allocation error), 0 on success\n\n @deprecated The semantics of this function are ill-defined and it should not\n be used. If you need to transfer the stream parameters from one codec context\n to another, use an intermediate AVCodecParameters instance and the\n avcodec_parameters_from_context() / avcodec_parameters_to_context()\n functions."]
    pub fn avcodec_copy_context(
        dest: *mut AVCodecContext,
        src: *const AVCodecContext,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill the parameters struct based on the values from the supplied codec\n context. Any allocated fields in par are freed and replaced with duplicates\n of the corresponding fields in codec.\n\n @return >= 0 on success, a negative AVERROR code on failure"]
    pub fn avcodec_parameters_from_context(
        par: *mut AVCodecParameters,
        codec: *const AVCodecContext,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill the codec context based on the values from the supplied codec\n parameters. Any allocated fields in codec that have a corresponding field in\n par are freed and replaced with duplicates of the corresponding field in par.\n Fields in codec that do not have a counterpart in par are not touched.\n\n @return >= 0 on success, a negative AVERROR code on failure."]
    pub fn avcodec_parameters_to_context(
        codec: *mut AVCodecContext,
        par: *const AVCodecParameters,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Initialize the AVCodecContext to use the given AVCodec. Prior to using this\n function the context has to be allocated with avcodec_alloc_context3().\n\n The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),\n avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for\n retrieving a codec.\n\n @warning This function is not thread safe!\n\n @note Always call this function before using decoding routines (such as\n @ref avcodec_receive_frame()).\n\n @code\n av_dict_set(&opts, \"b\", \"2.5M\", 0);\n codec = avcodec_find_decoder(AV_CODEC_ID_H264);\n if (!codec)\n     exit(1);\n\n context = avcodec_alloc_context3(codec);\n\n if (avcodec_open2(context, codec, opts) < 0)\n     exit(1);\n @endcode\n\n @param avctx The context to initialize.\n @param codec The codec to open this context for. If a non-NULL codec has been\n              previously passed to avcodec_alloc_context3() or\n              for this context, then this parameter MUST be either NULL or\n              equal to the previously passed codec.\n @param options A dictionary filled with AVCodecContext and codec-private options.\n                On return this object will be filled with options that were not found.\n\n @return zero on success, a negative value on error\n @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),\n      av_dict_set(), av_opt_find()."]
    pub fn avcodec_open2(
        avctx: *mut AVCodecContext,
        codec: *const AVCodec,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Close a given AVCodecContext and free all the data associated with it\n (but not the AVCodecContext itself).\n\n Calling this function on an AVCodecContext that hasn't been opened will free\n the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL\n codec. Subsequent calls will do nothing.\n\n @note Do not use this function. Use avcodec_free_context() to destroy a\n codec context (either open or closed). Opening and closing a codec context\n multiple times is not supported anymore -- use multiple codec contexts\n instead."]
    pub fn avcodec_close(avctx: *mut AVCodecContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Free all allocated data in the given subtitle struct.\n\n @param sub AVSubtitle to free."]
    pub fn avsubtitle_free(sub: *mut AVSubtitle);
}
extern "C" {
    #[doc = " The default callback for AVCodecContext.get_buffer2(). It is made public so\n it can be called by custom get_buffer2() implementations for decoders without\n AV_CODEC_CAP_DR1 set."]
    pub fn avcodec_default_get_buffer2(
        s: *mut AVCodecContext,
        frame: *mut AVFrame,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " The default callback for AVCodecContext.get_encode_buffer(). It is made public so\n it can be called by custom get_encode_buffer() implementations for encoders without\n AV_CODEC_CAP_DR1 set."]
    pub fn avcodec_default_get_encode_buffer(
        s: *mut AVCodecContext,
        pkt: *mut AVPacket,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Modify width and height values so that they will result in a memory\n buffer that is acceptable for the codec if you do not use any horizontal\n padding.\n\n May only be used if a codec with AV_CODEC_CAP_DR1 has been opened."]
    pub fn avcodec_align_dimensions(
        s: *mut AVCodecContext,
        width: *mut libc::c_int,
        height: *mut libc::c_int,
    );
}
extern "C" {
    #[doc = " Modify width and height values so that they will result in a memory\n buffer that is acceptable for the codec if you also ensure that all\n line sizes are a multiple of the respective linesize_align[i].\n\n May only be used if a codec with AV_CODEC_CAP_DR1 has been opened."]
    pub fn avcodec_align_dimensions2(
        s: *mut AVCodecContext,
        width: *mut libc::c_int,
        height: *mut libc::c_int,
        linesize_align: *mut libc::c_int,
    );
}
extern "C" {
    #[doc = " Converts AVChromaLocation to swscale x/y chroma position.\n\n The positions represent the chroma (0,0) position in a coordinates system\n with luma (0,0) representing the origin and luma(1,1) representing 256,256\n\n @param xpos  horizontal chroma sample position\n @param ypos  vertical   chroma sample position"]
    pub fn avcodec_enum_to_chroma_pos(
        xpos: *mut libc::c_int,
        ypos: *mut libc::c_int,
        pos: AVChromaLocation,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Converts swscale x/y chroma position to AVChromaLocation.\n\n The positions represent the chroma (0,0) position in a coordinates system\n with luma (0,0) representing the origin and luma(1,1) representing 256,256\n\n @param xpos  horizontal chroma sample position\n @param ypos  vertical   chroma sample position"]
    pub fn avcodec_chroma_pos_to_enum(xpos: libc::c_int, ypos: libc::c_int) -> AVChromaLocation;
}
extern "C" {
    #[doc = " Decode the audio frame of size avpkt->size from avpkt->data into frame.\n\n Some decoders may support multiple frames in a single AVPacket. Such\n decoders would then just decode the first frame and the return value would be\n less than the packet size. In this case, avcodec_decode_audio4 has to be\n called again with an AVPacket containing the remaining data in order to\n decode the second frame, etc...  Even if no frames are returned, the packet\n needs to be fed to the decoder with remaining data until it is completely\n consumed or an error occurs.\n\n Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input\n and output. This means that for some packets they will not immediately\n produce decoded output and need to be flushed at the end of decoding to get\n all the decoded data. Flushing is done by calling this function with packets\n with avpkt->data set to NULL and avpkt->size set to 0 until it stops\n returning samples. It is safe to flush even those decoders that are not\n marked with AV_CODEC_CAP_DELAY, then no samples will be returned.\n\n @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE\n          larger than the actual read bytes because some optimized bitstream\n          readers read 32 or 64 bits at once and could read over the end.\n\n @note The AVCodecContext MUST have been opened with @ref avcodec_open2()\n before packets may be fed to the decoder.\n\n @param      avctx the codec context\n @param[out] frame The AVFrame in which to store decoded audio samples.\n                   The decoder will allocate a buffer for the decoded frame by\n                   calling the AVCodecContext.get_buffer2() callback.\n                   When AVCodecContext.refcounted_frames is set to 1, the frame is\n                   reference counted and the returned reference belongs to the\n                   caller. The caller must release the frame using av_frame_unref()\n                   when the frame is no longer needed. The caller may safely write\n                   to the frame if av_frame_is_writable() returns 1.\n                   When AVCodecContext.refcounted_frames is set to 0, the returned\n                   reference belongs to the decoder and is valid only until the\n                   next call to this function or until closing or flushing the\n                   decoder. The caller may not write to it.\n @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is\n                           non-zero. Note that this field being set to zero\n                           does not mean that an error has occurred. For\n                           decoders with AV_CODEC_CAP_DELAY set, no given decode\n                           call is guaranteed to produce a frame.\n @param[in]  avpkt The input AVPacket containing the input buffer.\n                   At least avpkt->data and avpkt->size should be set. Some\n                   decoders might also require additional fields to be set.\n @return A negative error code is returned if an error occurred during\n         decoding, otherwise the number of bytes consumed from the input\n         AVPacket is returned.\n\n @deprecated Use avcodec_send_packet() and avcodec_receive_frame()."]
    pub fn avcodec_decode_audio4(
        avctx: *mut AVCodecContext,
        frame: *mut AVFrame,
        got_frame_ptr: *mut libc::c_int,
        avpkt: *const AVPacket,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Decode the video frame of size avpkt->size from avpkt->data into picture.\n Some decoders may support multiple frames in a single AVPacket, such\n decoders would then just decode the first frame.\n\n @warning The input buffer must be AV_INPUT_BUFFER_PADDING_SIZE larger than\n the actual read bytes because some optimized bitstream readers read 32 or 64\n bits at once and could read over the end.\n\n @warning The end of the input buffer buf should be set to 0 to ensure that\n no overreading happens for damaged MPEG streams.\n\n @note Codecs which have the AV_CODEC_CAP_DELAY capability set have a delay\n between input and output, these need to be fed with avpkt->data=NULL,\n avpkt->size=0 at the end to return the remaining frames.\n\n @note The AVCodecContext MUST have been opened with @ref avcodec_open2()\n before packets may be fed to the decoder.\n\n @param avctx the codec context\n @param[out] picture The AVFrame in which the decoded video frame will be stored.\n             Use av_frame_alloc() to get an AVFrame. The codec will\n             allocate memory for the actual bitmap by calling the\n             AVCodecContext.get_buffer2() callback.\n             When AVCodecContext.refcounted_frames is set to 1, the frame is\n             reference counted and the returned reference belongs to the\n             caller. The caller must release the frame using av_frame_unref()\n             when the frame is no longer needed. The caller may safely write\n             to the frame if av_frame_is_writable() returns 1.\n             When AVCodecContext.refcounted_frames is set to 0, the returned\n             reference belongs to the decoder and is valid only until the\n             next call to this function or until closing or flushing the\n             decoder. The caller may not write to it.\n\n @param[in] avpkt The input AVPacket containing the input buffer.\n            You can create such packet with av_init_packet() and by then setting\n            data and size, some decoders might in addition need other fields like\n            flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least\n            fields possible.\n @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.\n @return On error a negative value is returned, otherwise the number of bytes\n used or zero if no frame could be decompressed.\n\n @deprecated Use avcodec_send_packet() and avcodec_receive_frame()."]
    pub fn avcodec_decode_video2(
        avctx: *mut AVCodecContext,
        picture: *mut AVFrame,
        got_picture_ptr: *mut libc::c_int,
        avpkt: *const AVPacket,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Decode a subtitle message.\n Return a negative value on error, otherwise return the number of bytes used.\n If no subtitle could be decompressed, got_sub_ptr is zero.\n Otherwise, the subtitle is stored in *sub.\n Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for\n simplicity, because the performance difference is expected to be negligible\n and reusing a get_buffer written for video codecs would probably perform badly\n due to a potentially very different allocation pattern.\n\n Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input\n and output. This means that for some packets they will not immediately\n produce decoded output and need to be flushed at the end of decoding to get\n all the decoded data. Flushing is done by calling this function with packets\n with avpkt->data set to NULL and avpkt->size set to 0 until it stops\n returning subtitles. It is safe to flush even those decoders that are not\n marked with AV_CODEC_CAP_DELAY, then no subtitles will be returned.\n\n @note The AVCodecContext MUST have been opened with @ref avcodec_open2()\n before packets may be fed to the decoder.\n\n @param avctx the codec context\n @param[out] sub The preallocated AVSubtitle in which the decoded subtitle will be stored,\n                 must be freed with avsubtitle_free if *got_sub_ptr is set.\n @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.\n @param[in] avpkt The input AVPacket containing the input buffer."]
    pub fn avcodec_decode_subtitle2(
        avctx: *mut AVCodecContext,
        sub: *mut AVSubtitle,
        got_sub_ptr: *mut libc::c_int,
        avpkt: *mut AVPacket,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Supply raw packet data as input to a decoder.\n\n Internally, this call will copy relevant AVCodecContext fields, which can\n influence decoding per-packet, and apply them when the packet is actually\n decoded. (For example AVCodecContext.skip_frame, which might direct the\n decoder to drop the frame contained by the packet sent with this function.)\n\n @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE\n          larger than the actual read bytes because some optimized bitstream\n          readers read 32 or 64 bits at once and could read over the end.\n\n @warning Do not mix this API with the legacy API (like avcodec_decode_video2())\n          on the same AVCodecContext. It will return unexpected results now\n          or in future libavcodec versions.\n\n @note The AVCodecContext MUST have been opened with @ref avcodec_open2()\n       before packets may be fed to the decoder.\n\n @param avctx codec context\n @param[in] avpkt The input AVPacket. Usually, this will be a single video\n                  frame, or several complete audio frames.\n                  Ownership of the packet remains with the caller, and the\n                  decoder will not write to the packet. The decoder may create\n                  a reference to the packet data (or copy it if the packet is\n                  not reference-counted).\n                  Unlike with older APIs, the packet is always fully consumed,\n                  and if it contains multiple frames (e.g. some audio codecs),\n                  will require you to call avcodec_receive_frame() multiple\n                  times afterwards before you can send a new packet.\n                  It can be NULL (or an AVPacket with data set to NULL and\n                  size set to 0); in this case, it is considered a flush\n                  packet, which signals the end of the stream. Sending the\n                  first flush packet will return success. Subsequent ones are\n                  unnecessary and will return AVERROR_EOF. If the decoder\n                  still has frames buffered, it will return them after sending\n                  a flush packet.\n\n @return 0 on success, otherwise negative error code:\n      AVERROR(EAGAIN):   input is not accepted in the current state - user\n                         must read output with avcodec_receive_frame() (once\n                         all output is read, the packet should be resent, and\n                         the call will not fail with EAGAIN).\n      AVERROR_EOF:       the decoder has been flushed, and no new packets can\n                         be sent to it (also returned if more than 1 flush\n                         packet is sent)\n      AVERROR(EINVAL):   codec not opened, it is an encoder, or requires flush\n      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar\n      other errors: legitimate decoding errors"]
    pub fn avcodec_send_packet(avctx: *mut AVCodecContext, avpkt: *const AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Return decoded output data from a decoder.\n\n @param avctx codec context\n @param frame This will be set to a reference-counted video or audio\n              frame (depending on the decoder type) allocated by the\n              decoder. Note that the function will always call\n              av_frame_unref(frame) before doing anything else.\n\n @return\n      0:                 success, a frame was returned\n      AVERROR(EAGAIN):   output is not available in this state - user must try\n                         to send new input\n      AVERROR_EOF:       the decoder has been fully flushed, and there will be\n                         no more output frames\n      AVERROR(EINVAL):   codec not opened, or it is an encoder\n      AVERROR_INPUT_CHANGED:   current decoded frame has changed parameters\n                               with respect to first decoded frame. Applicable\n                               when flag AV_CODEC_FLAG_DROPCHANGED is set.\n      other negative values: legitimate decoding errors"]
    pub fn avcodec_receive_frame(avctx: *mut AVCodecContext, frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    #[doc = " Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()\n to retrieve buffered output packets.\n\n @param avctx     codec context\n @param[in] frame AVFrame containing the raw audio or video frame to be encoded.\n                  Ownership of the frame remains with the caller, and the\n                  encoder will not write to the frame. The encoder may create\n                  a reference to the frame data (or copy it if the frame is\n                  not reference-counted).\n                  It can be NULL, in which case it is considered a flush\n                  packet.  This signals the end of the stream. If the encoder\n                  still has packets buffered, it will return them after this\n                  call. Once flushing mode has been entered, additional flush\n                  packets are ignored, and sending frames will return\n                  AVERROR_EOF.\n\n                  For audio:\n                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame\n                  can have any number of samples.\n                  If it is not set, frame->nb_samples must be equal to\n                  avctx->frame_size for all frames except the last.\n                  The final frame may be smaller than avctx->frame_size.\n @return 0 on success, otherwise negative error code:\n      AVERROR(EAGAIN):   input is not accepted in the current state - user\n                         must read output with avcodec_receive_packet() (once\n                         all output is read, the packet should be resent, and\n                         the call will not fail with EAGAIN).\n      AVERROR_EOF:       the encoder has been flushed, and no new frames can\n                         be sent to it\n      AVERROR(EINVAL):   codec not opened, refcounted_frames not set, it is a\n                         decoder, or requires flush\n      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar\n      other errors: legitimate encoding errors"]
    pub fn avcodec_send_frame(avctx: *mut AVCodecContext, frame: *const AVFrame) -> libc::c_int;
}
extern "C" {
    #[doc = " Read encoded data from the encoder.\n\n @param avctx codec context\n @param avpkt This will be set to a reference-counted packet allocated by the\n              encoder. Note that the function will always call\n              av_packet_unref(avpkt) before doing anything else.\n @return 0 on success, otherwise negative error code:\n      AVERROR(EAGAIN):   output is not available in the current state - user\n                         must try to send input\n      AVERROR_EOF:       the encoder has been fully flushed, and there will be\n                         no more output packets\n      AVERROR(EINVAL):   codec not opened, or it is a decoder\n      other errors: legitimate encoding errors"]
    pub fn avcodec_receive_packet(avctx: *mut AVCodecContext, avpkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Create and return a AVHWFramesContext with values adequate for hardware\n decoding. This is meant to get called from the get_format callback, and is\n a helper for preparing a AVHWFramesContext for AVCodecContext.hw_frames_ctx.\n This API is for decoding with certain hardware acceleration modes/APIs only.\n\n The returned AVHWFramesContext is not initialized. The caller must do this\n with av_hwframe_ctx_init().\n\n Calling this function is not a requirement, but makes it simpler to avoid\n codec or hardware API specific details when manually allocating frames.\n\n Alternatively to this, an API user can set AVCodecContext.hw_device_ctx,\n which sets up AVCodecContext.hw_frames_ctx fully automatically, and makes\n it unnecessary to call this function or having to care about\n AVHWFramesContext initialization at all.\n\n There are a number of requirements for calling this function:\n\n - It must be called from get_format with the same avctx parameter that was\n   passed to get_format. Calling it outside of get_format is not allowed, and\n   can trigger undefined behavior.\n - The function is not always supported (see description of return values).\n   Even if this function returns successfully, hwaccel initialization could\n   fail later. (The degree to which implementations check whether the stream\n   is actually supported varies. Some do this check only after the user's\n   get_format callback returns.)\n - The hw_pix_fmt must be one of the choices suggested by get_format. If the\n   user decides to use a AVHWFramesContext prepared with this API function,\n   the user must return the same hw_pix_fmt from get_format.\n - The device_ref passed to this function must support the given hw_pix_fmt.\n - After calling this API function, it is the user's responsibility to\n   initialize the AVHWFramesContext (returned by the out_frames_ref parameter),\n   and to set AVCodecContext.hw_frames_ctx to it. If done, this must be done\n   before returning from get_format (this is implied by the normal\n   AVCodecContext.hw_frames_ctx API rules).\n - The AVHWFramesContext parameters may change every time time get_format is\n   called. Also, AVCodecContext.hw_frames_ctx is reset before get_format. So\n   you are inherently required to go through this process again on every\n   get_format call.\n - It is perfectly possible to call this function without actually using\n   the resulting AVHWFramesContext. One use-case might be trying to reuse a\n   previously initialized AVHWFramesContext, and calling this API function\n   only to test whether the required frame parameters have changed.\n - Fields that use dynamically allocated values of any kind must not be set\n   by the user unless setting them is explicitly allowed by the documentation.\n   If the user sets AVHWFramesContext.free and AVHWFramesContext.user_opaque,\n   the new free callback must call the potentially set previous free callback.\n   This API call may set any dynamically allocated fields, including the free\n   callback.\n\n The function will set at least the following fields on AVHWFramesContext\n (potentially more, depending on hwaccel API):\n\n - All fields set by av_hwframe_ctx_alloc().\n - Set the format field to hw_pix_fmt.\n - Set the sw_format field to the most suited and most versatile format. (An\n   implication is that this will prefer generic formats over opaque formats\n   with arbitrary restrictions, if possible.)\n - Set the width/height fields to the coded frame size, rounded up to the\n   API-specific minimum alignment.\n - Only _if_ the hwaccel requires a pre-allocated pool: set the initial_pool_size\n   field to the number of maximum reference surfaces possible with the codec,\n   plus 1 surface for the user to work (meaning the user can safely reference\n   at most 1 decoded surface at a time), plus additional buffering introduced\n   by frame threading. If the hwaccel does not require pre-allocation, the\n   field is left to 0, and the decoder will allocate new surfaces on demand\n   during decoding.\n - Possibly AVHWFramesContext.hwctx fields, depending on the underlying\n   hardware API.\n\n Essentially, out_frames_ref returns the same as av_hwframe_ctx_alloc(), but\n with basic frame parameters set.\n\n The function is stateless, and does not change the AVCodecContext or the\n device_ref AVHWDeviceContext.\n\n @param avctx The context which is currently calling get_format, and which\n              implicitly contains all state needed for filling the returned\n              AVHWFramesContext properly.\n @param device_ref A reference to the AVHWDeviceContext describing the device\n                   which will be used by the hardware decoder.\n @param hw_pix_fmt The hwaccel format you are going to return from get_format.\n @param out_frames_ref On success, set to a reference to an _uninitialized_\n                       AVHWFramesContext, created from the given device_ref.\n                       Fields will be set to values required for decoding.\n                       Not changed if an error is returned.\n @return zero on success, a negative value on error. The following error codes\n         have special semantics:\n      AVERROR(ENOENT): the decoder does not support this functionality. Setup\n                       is always manual, or it is a decoder which does not\n                       support setting AVCodecContext.hw_frames_ctx at all,\n                       or it is a software format.\n      AVERROR(EINVAL): it is known that hardware decoding is not supported for\n                       this configuration, or the device_ref is not supported\n                       for the hwaccel referenced by hw_pix_fmt."]
    pub fn avcodec_get_hw_frames_parameters(
        avctx: *mut AVCodecContext,
        device_ref: *mut AVBufferRef,
        hw_pix_fmt: AVPixelFormat,
        out_frames_ref: *mut *mut AVBufferRef,
    ) -> libc::c_int;
}
#[repr(u32)]
#[doc = " @defgroup lavc_parsing Frame parsing\n @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVPictureStructure {
    AV_PICTURE_STRUCTURE_UNKNOWN = 0,
    AV_PICTURE_STRUCTURE_TOP_FIELD = 1,
    AV_PICTURE_STRUCTURE_BOTTOM_FIELD = 2,
    AV_PICTURE_STRUCTURE_FRAME = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodecParserContext {
    pub priv_data: *mut libc::c_void,
    pub parser: *mut AVCodecParser,
    pub frame_offset: i64,
    pub cur_offset: i64,
    pub next_frame_offset: i64,
    pub pict_type: libc::c_int,
    #[doc = " This field is used for proper frame duration computation in lavf.\n It signals, how much longer the frame duration of the current frame\n is compared to normal frame duration.\n\n frame_duration = (1 + repeat_pict) * time_base\n\n It is used by codecs like H.264 to display telecined material."]
    pub repeat_pict: libc::c_int,
    pub pts: i64,
    pub dts: i64,
    pub last_pts: i64,
    pub last_dts: i64,
    pub fetch_timestamp: libc::c_int,
    pub cur_frame_start_index: libc::c_int,
    pub cur_frame_offset: [i64; 4usize],
    pub cur_frame_pts: [i64; 4usize],
    pub cur_frame_dts: [i64; 4usize],
    pub flags: libc::c_int,
    #[doc = "< byte offset from starting packet start"]
    pub offset: i64,
    pub cur_frame_end: [i64; 4usize],
    #[doc = " Set by parser to 1 for key frames and 0 for non-key frames.\n It is initialized to -1, so if the parser doesn't set this flag,\n old-style fallback using AV_PICTURE_TYPE_I picture type as key frames\n will be used."]
    pub key_frame: libc::c_int,
    #[doc = " @deprecated unused"]
    pub convergence_duration: i64,
    #[doc = " Synchronization point for start of timestamp generation.\n\n Set to >0 for sync point, 0 for no sync point and <0 for undefined\n (default).\n\n For example, this corresponds to presence of H.264 buffering period\n SEI message."]
    pub dts_sync_point: libc::c_int,
    #[doc = " Offset of the current timestamp against last timestamp sync point in\n units of AVCodecContext.time_base.\n\n Set to INT_MIN when dts_sync_point unused. Otherwise, it must\n contain a valid timestamp offset.\n\n Note that the timestamp of sync point has usually a nonzero\n dts_ref_dts_delta, which refers to the previous sync point. Offset of\n the next frame after timestamp sync point will be usually 1.\n\n For example, this corresponds to H.264 cpb_removal_delay."]
    pub dts_ref_dts_delta: libc::c_int,
    #[doc = " Presentation delay of current frame in units of AVCodecContext.time_base.\n\n Set to INT_MIN when dts_sync_point unused. Otherwise, it must\n contain valid non-negative timestamp delta (presentation time of a frame\n must not lie in the past).\n\n This delay represents the difference between decoding and presentation\n time of the frame.\n\n For example, this corresponds to H.264 dpb_output_delay."]
    pub pts_dts_delta: libc::c_int,
    #[doc = " Position of the packet in file.\n\n Analogous to cur_frame_pts/dts"]
    pub cur_frame_pos: [i64; 4usize],
    #[doc = " Byte position of currently parsed frame in stream."]
    pub pos: i64,
    #[doc = " Previous frame byte position."]
    pub last_pos: i64,
    #[doc = " Duration of the current frame.\n For audio, this is in units of 1 / AVCodecContext.sample_rate.\n For all other types, this is in units of AVCodecContext.time_base."]
    pub duration: libc::c_int,
    pub field_order: AVFieldOrder,
    #[doc = " Indicate whether a picture is coded as a frame, top field or bottom field.\n\n For example, H.264 field_pic_flag equal to 0 corresponds to\n AV_PICTURE_STRUCTURE_FRAME. An H.264 picture with field_pic_flag\n equal to 1 and bottom_field_flag equal to 0 corresponds to\n AV_PICTURE_STRUCTURE_TOP_FIELD."]
    pub picture_structure: AVPictureStructure,
    #[doc = " Picture number incremented in presentation or output order.\n This field may be reinitialized at the first picture of a new sequence.\n\n For example, this corresponds to H.264 PicOrderCnt."]
    pub output_picture_number: libc::c_int,
    #[doc = " Dimensions of the decoded video intended for presentation."]
    pub width: libc::c_int,
    pub height: libc::c_int,
    #[doc = " Dimensions of the coded video."]
    pub coded_width: libc::c_int,
    pub coded_height: libc::c_int,
    #[doc = " The format of the coded data, corresponds to enum AVPixelFormat for video\n and for enum AVSampleFormat for audio.\n\n Note that a decoder can have considerable freedom in how exactly it\n decodes the data, so the format reported here might be different from the\n one returned by a decoder."]
    pub format: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVCodecParserContext"][::std::mem::size_of::<AVCodecParserContext>() - 352usize];
    ["Alignment of AVCodecParserContext"][::std::mem::align_of::<AVCodecParserContext>() - 8usize];
    ["Offset of field: AVCodecParserContext::priv_data"]
        [::std::mem::offset_of!(AVCodecParserContext, priv_data) - 0usize];
    ["Offset of field: AVCodecParserContext::parser"]
        [::std::mem::offset_of!(AVCodecParserContext, parser) - 8usize];
    ["Offset of field: AVCodecParserContext::frame_offset"]
        [::std::mem::offset_of!(AVCodecParserContext, frame_offset) - 16usize];
    ["Offset of field: AVCodecParserContext::cur_offset"]
        [::std::mem::offset_of!(AVCodecParserContext, cur_offset) - 24usize];
    ["Offset of field: AVCodecParserContext::next_frame_offset"]
        [::std::mem::offset_of!(AVCodecParserContext, next_frame_offset) - 32usize];
    ["Offset of field: AVCodecParserContext::pict_type"]
        [::std::mem::offset_of!(AVCodecParserContext, pict_type) - 40usize];
    ["Offset of field: AVCodecParserContext::repeat_pict"]
        [::std::mem::offset_of!(AVCodecParserContext, repeat_pict) - 44usize];
    ["Offset of field: AVCodecParserContext::pts"]
        [::std::mem::offset_of!(AVCodecParserContext, pts) - 48usize];
    ["Offset of field: AVCodecParserContext::dts"]
        [::std::mem::offset_of!(AVCodecParserContext, dts) - 56usize];
    ["Offset of field: AVCodecParserContext::last_pts"]
        [::std::mem::offset_of!(AVCodecParserContext, last_pts) - 64usize];
    ["Offset of field: AVCodecParserContext::last_dts"]
        [::std::mem::offset_of!(AVCodecParserContext, last_dts) - 72usize];
    ["Offset of field: AVCodecParserContext::fetch_timestamp"]
        [::std::mem::offset_of!(AVCodecParserContext, fetch_timestamp) - 80usize];
    ["Offset of field: AVCodecParserContext::cur_frame_start_index"]
        [::std::mem::offset_of!(AVCodecParserContext, cur_frame_start_index) - 84usize];
    ["Offset of field: AVCodecParserContext::cur_frame_offset"]
        [::std::mem::offset_of!(AVCodecParserContext, cur_frame_offset) - 88usize];
    ["Offset of field: AVCodecParserContext::cur_frame_pts"]
        [::std::mem::offset_of!(AVCodecParserContext, cur_frame_pts) - 120usize];
    ["Offset of field: AVCodecParserContext::cur_frame_dts"]
        [::std::mem::offset_of!(AVCodecParserContext, cur_frame_dts) - 152usize];
    ["Offset of field: AVCodecParserContext::flags"]
        [::std::mem::offset_of!(AVCodecParserContext, flags) - 184usize];
    ["Offset of field: AVCodecParserContext::offset"]
        [::std::mem::offset_of!(AVCodecParserContext, offset) - 192usize];
    ["Offset of field: AVCodecParserContext::cur_frame_end"]
        [::std::mem::offset_of!(AVCodecParserContext, cur_frame_end) - 200usize];
    ["Offset of field: AVCodecParserContext::key_frame"]
        [::std::mem::offset_of!(AVCodecParserContext, key_frame) - 232usize];
    ["Offset of field: AVCodecParserContext::convergence_duration"]
        [::std::mem::offset_of!(AVCodecParserContext, convergence_duration) - 240usize];
    ["Offset of field: AVCodecParserContext::dts_sync_point"]
        [::std::mem::offset_of!(AVCodecParserContext, dts_sync_point) - 248usize];
    ["Offset of field: AVCodecParserContext::dts_ref_dts_delta"]
        [::std::mem::offset_of!(AVCodecParserContext, dts_ref_dts_delta) - 252usize];
    ["Offset of field: AVCodecParserContext::pts_dts_delta"]
        [::std::mem::offset_of!(AVCodecParserContext, pts_dts_delta) - 256usize];
    ["Offset of field: AVCodecParserContext::cur_frame_pos"]
        [::std::mem::offset_of!(AVCodecParserContext, cur_frame_pos) - 264usize];
    ["Offset of field: AVCodecParserContext::pos"]
        [::std::mem::offset_of!(AVCodecParserContext, pos) - 296usize];
    ["Offset of field: AVCodecParserContext::last_pos"]
        [::std::mem::offset_of!(AVCodecParserContext, last_pos) - 304usize];
    ["Offset of field: AVCodecParserContext::duration"]
        [::std::mem::offset_of!(AVCodecParserContext, duration) - 312usize];
    ["Offset of field: AVCodecParserContext::field_order"]
        [::std::mem::offset_of!(AVCodecParserContext, field_order) - 316usize];
    ["Offset of field: AVCodecParserContext::picture_structure"]
        [::std::mem::offset_of!(AVCodecParserContext, picture_structure) - 320usize];
    ["Offset of field: AVCodecParserContext::output_picture_number"]
        [::std::mem::offset_of!(AVCodecParserContext, output_picture_number) - 324usize];
    ["Offset of field: AVCodecParserContext::width"]
        [::std::mem::offset_of!(AVCodecParserContext, width) - 328usize];
    ["Offset of field: AVCodecParserContext::height"]
        [::std::mem::offset_of!(AVCodecParserContext, height) - 332usize];
    ["Offset of field: AVCodecParserContext::coded_width"]
        [::std::mem::offset_of!(AVCodecParserContext, coded_width) - 336usize];
    ["Offset of field: AVCodecParserContext::coded_height"]
        [::std::mem::offset_of!(AVCodecParserContext, coded_height) - 340usize];
    ["Offset of field: AVCodecParserContext::format"]
        [::std::mem::offset_of!(AVCodecParserContext, format) - 344usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodecParser {
    pub codec_ids: [libc::c_int; 5usize],
    pub priv_data_size: libc::c_int,
    pub parser_init:
        ::std::option::Option<unsafe extern "C" fn(s: *mut AVCodecParserContext) -> libc::c_int>,
    pub parser_parse: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecParserContext,
            avctx: *mut AVCodecContext,
            poutbuf: *mut *const u8,
            poutbuf_size: *mut libc::c_int,
            buf: *const u8,
            buf_size: libc::c_int,
        ) -> libc::c_int,
    >,
    pub parser_close: ::std::option::Option<unsafe extern "C" fn(s: *mut AVCodecParserContext)>,
    pub split: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            buf: *const u8,
            buf_size: libc::c_int,
        ) -> libc::c_int,
    >,
    pub next: *mut AVCodecParser,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVCodecParser"][::std::mem::size_of::<AVCodecParser>() - 64usize];
    ["Alignment of AVCodecParser"][::std::mem::align_of::<AVCodecParser>() - 8usize];
    ["Offset of field: AVCodecParser::codec_ids"]
        [::std::mem::offset_of!(AVCodecParser, codec_ids) - 0usize];
    ["Offset of field: AVCodecParser::priv_data_size"]
        [::std::mem::offset_of!(AVCodecParser, priv_data_size) - 20usize];
    ["Offset of field: AVCodecParser::parser_init"]
        [::std::mem::offset_of!(AVCodecParser, parser_init) - 24usize];
    ["Offset of field: AVCodecParser::parser_parse"]
        [::std::mem::offset_of!(AVCodecParser, parser_parse) - 32usize];
    ["Offset of field: AVCodecParser::parser_close"]
        [::std::mem::offset_of!(AVCodecParser, parser_close) - 40usize];
    ["Offset of field: AVCodecParser::split"]
        [::std::mem::offset_of!(AVCodecParser, split) - 48usize];
    ["Offset of field: AVCodecParser::next"][::std::mem::offset_of!(AVCodecParser, next) - 56usize];
};
extern "C" {
    #[doc = " Iterate over all registered codec parsers.\n\n @param opaque a pointer where libavcodec will store the iteration state. Must\n               point to NULL to start the iteration.\n\n @return the next registered codec parser or NULL when the iteration is\n         finished"]
    pub fn av_parser_iterate(opaque: *mut *mut libc::c_void) -> *const AVCodecParser;
}
extern "C" {
    pub fn av_parser_next(c: *const AVCodecParser) -> *mut AVCodecParser;
}
extern "C" {
    pub fn av_register_codec_parser(parser: *mut AVCodecParser);
}
extern "C" {
    pub fn av_parser_init(codec_id: libc::c_int) -> *mut AVCodecParserContext;
}
extern "C" {
    #[doc = " Parse a packet.\n\n @param s             parser context.\n @param avctx         codec context.\n @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.\n @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.\n @param buf           input buffer.\n @param buf_size      buffer size in bytes without the padding. I.e. the full buffer\nsize is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.\nTo signal EOF, this should be 0 (so that the last frame\ncan be output).\n @param pts           input presentation timestamp.\n @param dts           input decoding timestamp.\n @param pos           input byte position in stream.\n @return the number of bytes of the input bitstream used.\n\n Example:\n @code\n   while(in_len){\n       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,\n                                        in_data, in_len,\n                                        pts, dts, pos);\n       in_data += len;\n       in_len  -= len;\n\n       if(size)\n          decode_frame(data, size);\n   }\n @endcode"]
    pub fn av_parser_parse2(
        s: *mut AVCodecParserContext,
        avctx: *mut AVCodecContext,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut libc::c_int,
        buf: *const u8,
        buf_size: libc::c_int,
        pts: i64,
        dts: i64,
        pos: i64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @return 0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed\n @deprecated Use dump_extradata, remove_extra or extract_extradata\n             bitstream filters instead."]
    pub fn av_parser_change(
        s: *mut AVCodecParserContext,
        avctx: *mut AVCodecContext,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut libc::c_int,
        buf: *const u8,
        buf_size: libc::c_int,
        keyframe: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_parser_close(s: *mut AVCodecParserContext);
}
extern "C" {
    #[doc = " Encode a frame of audio.\n\n Takes input samples from frame and writes the next output packet, if\n available, to avpkt. The output packet does not necessarily contain data for\n the most recent frame, as encoders can delay, split, and combine input frames\n internally as needed.\n\n @param avctx     codec context\n @param avpkt     output AVPacket.\n                  The user can supply an output buffer by setting\n                  avpkt->data and avpkt->size prior to calling the\n                  function, but if the size of the user-provided data is not\n                  large enough, encoding will fail. If avpkt->data and\n                  avpkt->size are set, avpkt->destruct must also be set. All\n                  other AVPacket fields will be reset by the encoder using\n                  av_init_packet(). If avpkt->data is NULL, the encoder will\n                  allocate it. The encoder will set avpkt->size to the size\n                  of the output packet.\n\n                  If this function fails or produces no output, avpkt will be\n                  freed using av_packet_unref().\n @param[in] frame AVFrame containing the raw audio data to be encoded.\n                  May be NULL when flushing an encoder that has the\n                  AV_CODEC_CAP_DELAY capability set.\n                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame\n                  can have any number of samples.\n                  If it is not set, frame->nb_samples must be equal to\n                  avctx->frame_size for all frames except the last.\n                  The final frame may be smaller than avctx->frame_size.\n @param[out] got_packet_ptr This field is set to 1 by libavcodec if the\n                            output packet is non-empty, and to 0 if it is\n                            empty. If the function returns an error, the\n                            packet can be assumed to be invalid, and the\n                            value of got_packet_ptr is undefined and should\n                            not be used.\n @return          0 on success, negative error code on failure\n\n @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead.\n             If allowed and required, set AVCodecContext.get_encode_buffer to\n             a custom function to pass user supplied output buffers."]
    pub fn avcodec_encode_audio2(
        avctx: *mut AVCodecContext,
        avpkt: *mut AVPacket,
        frame: *const AVFrame,
        got_packet_ptr: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Encode a frame of video.\n\n Takes input raw video data from frame and writes the next output packet, if\n available, to avpkt. The output packet does not necessarily contain data for\n the most recent frame, as encoders can delay and reorder input frames\n internally as needed.\n\n @param avctx     codec context\n @param avpkt     output AVPacket.\n                  The user can supply an output buffer by setting\n                  avpkt->data and avpkt->size prior to calling the\n                  function, but if the size of the user-provided data is not\n                  large enough, encoding will fail. All other AVPacket fields\n                  will be reset by the encoder using av_init_packet(). If\n                  avpkt->data is NULL, the encoder will allocate it.\n                  The encoder will set avpkt->size to the size of the\n                  output packet. The returned data (if any) belongs to the\n                  caller, he is responsible for freeing it.\n\n                  If this function fails or produces no output, avpkt will be\n                  freed using av_packet_unref().\n @param[in] frame AVFrame containing the raw video data to be encoded.\n                  May be NULL when flushing an encoder that has the\n                  AV_CODEC_CAP_DELAY capability set.\n @param[out] got_packet_ptr This field is set to 1 by libavcodec if the\n                            output packet is non-empty, and to 0 if it is\n                            empty. If the function returns an error, the\n                            packet can be assumed to be invalid, and the\n                            value of got_packet_ptr is undefined and should\n                            not be used.\n @return          0 on success, negative error code on failure\n\n @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead.\n             If allowed and required, set AVCodecContext.get_encode_buffer to\n             a custom function to pass user supplied output buffers."]
    pub fn avcodec_encode_video2(
        avctx: *mut AVCodecContext,
        avpkt: *mut AVPacket,
        frame: *const AVFrame,
        got_packet_ptr: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avcodec_encode_subtitle(
        avctx: *mut AVCodecContext,
        buf: *mut u8,
        buf_size: libc::c_int,
        sub: *const AVSubtitle,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @deprecated unused"]
    pub fn avpicture_alloc(
        picture: *mut AVPicture,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @deprecated unused"]
    pub fn avpicture_free(picture: *mut AVPicture);
}
extern "C" {
    #[doc = " @deprecated use av_image_fill_arrays() instead."]
    pub fn avpicture_fill(
        picture: *mut AVPicture,
        ptr: *const u8,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @deprecated use av_image_copy_to_buffer() instead."]
    pub fn avpicture_layout(
        src: *const AVPicture,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
        dest: *mut libc::c_uchar,
        dest_size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @deprecated use av_image_get_buffer_size() instead."]
    pub fn avpicture_get_size(
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @deprecated av_image_copy() instead."]
    pub fn av_picture_copy(
        dst: *mut AVPicture,
        src: *const AVPicture,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
    );
}
extern "C" {
    #[doc = " @deprecated unused"]
    pub fn av_picture_crop(
        dst: *mut AVPicture,
        src: *const AVPicture,
        pix_fmt: AVPixelFormat,
        top_band: libc::c_int,
        left_band: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @deprecated unused"]
    pub fn av_picture_pad(
        dst: *mut AVPicture,
        src: *const AVPicture,
        height: libc::c_int,
        width: libc::c_int,
        pix_fmt: AVPixelFormat,
        padtop: libc::c_int,
        padbottom: libc::c_int,
        padleft: libc::c_int,
        padright: libc::c_int,
        color: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @deprecated Use av_pix_fmt_get_chroma_sub_sample"]
    pub fn avcodec_get_chroma_sub_sample(
        pix_fmt: AVPixelFormat,
        h_shift: *mut libc::c_int,
        v_shift: *mut libc::c_int,
    );
}
extern "C" {
    #[doc = " Return a value representing the fourCC code associated to the\n pixel format pix_fmt, or 0 if no associated fourCC code can be\n found."]
    pub fn avcodec_pix_fmt_to_codec_tag(pix_fmt: AVPixelFormat) -> libc::c_uint;
}
extern "C" {
    #[doc = " Find the best pixel format to convert to given a certain source pixel\n format.  When converting from one pixel format to another, information loss\n may occur.  For example, when converting from RGB24 to GRAY, the color\n information will be lost. Similarly, other losses occur when converting from\n some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of\n the given pixel formats should be used to suffer the least amount of loss.\n The pixel formats from which it chooses one, are determined by the\n pix_fmt_list parameter.\n\n\n @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from\n @param[in] src_pix_fmt source pixel format\n @param[in] has_alpha Whether the source pixel format alpha channel is used.\n @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.\n @return The best pixel format to convert to or -1 if none was found."]
    pub fn avcodec_find_best_pix_fmt_of_list(
        pix_fmt_list: *const AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: libc::c_int,
        loss_ptr: *mut libc::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    #[doc = " @deprecated see av_get_pix_fmt_loss()"]
    pub fn avcodec_get_pix_fmt_loss(
        dst_pix_fmt: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @deprecated see av_find_best_pix_fmt_of_2()"]
    pub fn avcodec_find_best_pix_fmt_of_2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: libc::c_int,
        loss_ptr: *mut libc::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_find_best_pix_fmt2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: libc::c_int,
        loss_ptr: *mut libc::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_default_get_format(
        s: *mut AVCodecContext,
        fmt: *const AVPixelFormat,
    ) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Put a string representing the codec tag codec_tag in buf.\n\n @param buf       buffer to place codec tag in\n @param buf_size size in bytes of buf\n @param codec_tag codec tag to assign\n @return the length of the string that would have been generated if\n enough space had been available, excluding the trailing null\n\n @deprecated see av_fourcc_make_string() and av_fourcc2str()."]
    pub fn av_get_codec_tag_string(
        buf: *mut libc::c_char,
        buf_size: usize,
        codec_tag: libc::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn avcodec_string(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        enc: *mut AVCodecContext,
        encode: libc::c_int,
    );
}
extern "C" {
    #[doc = " Return a name for the specified profile, if available.\n\n @param codec the codec that is searched for the given profile\n @param profile the profile value for which a name is requested\n @return A name for the profile if found, NULL otherwise."]
    pub fn av_get_profile_name(codec: *const AVCodec, profile: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return a name for the specified profile, if available.\n\n @param codec_id the ID of the codec to which the requested profile belongs\n @param profile the profile value for which a name is requested\n @return A name for the profile if found, NULL otherwise.\n\n @note unlike av_get_profile_name(), which searches a list of profiles\n       supported by a specific decoder or encoder implementation, this\n       function searches the list of profiles from the AVCodecDescriptor"]
    pub fn avcodec_profile_name(codec_id: AVCodecID, profile: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    pub fn avcodec_default_execute(
        c: *mut AVCodecContext,
        func: ::std::option::Option<
            unsafe extern "C" fn(c2: *mut AVCodecContext, arg2: *mut libc::c_void) -> libc::c_int,
        >,
        arg: *mut libc::c_void,
        ret: *mut libc::c_int,
        count: libc::c_int,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avcodec_default_execute2(
        c: *mut AVCodecContext,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                c2: *mut AVCodecContext,
                arg2: *mut libc::c_void,
                arg1: libc::c_int,
                arg2: libc::c_int,
            ) -> libc::c_int,
        >,
        arg: *mut libc::c_void,
        ret: *mut libc::c_int,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill AVFrame audio data and linesize pointers.\n\n The buffer buf must be a preallocated buffer with a size big enough\n to contain the specified samples amount. The filled AVFrame data\n pointers will point to this buffer.\n\n AVFrame extended_data channel pointers are allocated if necessary for\n planar audio.\n\n @param frame       the AVFrame\n                    frame->nb_samples must be set prior to calling the\n                    function. This function fills in frame->data,\n                    frame->extended_data, frame->linesize[0].\n @param nb_channels channel count\n @param sample_fmt  sample format\n @param buf         buffer to use for frame data\n @param buf_size    size of buffer\n @param align       plane size sample alignment (0 = default)\n @return            >=0 on success, negative error code on failure\n @todo return the size in bytes required to store the samples in\n case of success, at the next libavutil bump"]
    pub fn avcodec_fill_audio_frame(
        frame: *mut AVFrame,
        nb_channels: libc::c_int,
        sample_fmt: AVSampleFormat,
        buf: *const u8,
        buf_size: libc::c_int,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Reset the internal codec state / flush internal buffers. Should be called\n e.g. when seeking or when switching to a different stream.\n\n @note for decoders, when refcounted frames are not used\n (i.e. avctx->refcounted_frames is 0), this invalidates the frames previously\n returned from the decoder. When refcounted frames are used, the decoder just\n releases any references it might keep internally, but the caller's reference\n remains valid.\n\n @note for encoders, this function will only do something if the encoder\n declares support for AV_CODEC_CAP_ENCODER_FLUSH. When called, the encoder\n will drain any remaining packets, and can then be re-used for a different\n stream (as opposed to sending a null frame which will leave the encoder\n in a permanent EOF state after draining). This can be desirable if the\n cost of tearing down and replacing the encoder instance is high."]
    pub fn avcodec_flush_buffers(avctx: *mut AVCodecContext);
}
extern "C" {
    #[doc = " Return codec bits per sample.\n\n @param[in] codec_id the codec\n @return Number of bits per sample or zero if unknown for the given codec."]
    pub fn av_get_bits_per_sample(codec_id: AVCodecID) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the PCM codec associated with a sample format.\n @param be  endianness, 0 for little, 1 for big,\n            -1 (or anything else) for native\n @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE"]
    pub fn av_get_pcm_codec(fmt: AVSampleFormat, be: libc::c_int) -> AVCodecID;
}
extern "C" {
    #[doc = " Return codec bits per sample.\n Only return non-zero if the bits per sample is exactly correct, not an\n approximation.\n\n @param[in] codec_id the codec\n @return Number of bits per sample or zero if unknown for the given codec."]
    pub fn av_get_exact_bits_per_sample(codec_id: AVCodecID) -> libc::c_int;
}
extern "C" {
    #[doc = " Return audio frame duration.\n\n @param avctx        codec context\n @param frame_bytes  size of the frame, or 0 if unknown\n @return             frame duration, in samples, if known. 0 if not able to\n                     determine."]
    pub fn av_get_audio_frame_duration(
        avctx: *mut AVCodecContext,
        frame_bytes: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " This function is the same as av_get_audio_frame_duration(), except it works\n with AVCodecParameters instead of an AVCodecContext."]
    pub fn av_get_audio_frame_duration2(
        par: *mut AVCodecParameters,
        frame_bytes: libc::c_int,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVBitStreamFilterContext {
    pub priv_data: *mut libc::c_void,
    pub filter: *const AVBitStreamFilter,
    pub parser: *mut AVCodecParserContext,
    pub next: *mut AVBitStreamFilterContext,
    #[doc = " Internal default arguments, used if NULL is passed to av_bitstream_filter_filter().\n Not for access by library users."]
    pub args: *mut libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVBitStreamFilterContext"]
        [::std::mem::size_of::<AVBitStreamFilterContext>() - 40usize];
    ["Alignment of AVBitStreamFilterContext"]
        [::std::mem::align_of::<AVBitStreamFilterContext>() - 8usize];
    ["Offset of field: AVBitStreamFilterContext::priv_data"]
        [::std::mem::offset_of!(AVBitStreamFilterContext, priv_data) - 0usize];
    ["Offset of field: AVBitStreamFilterContext::filter"]
        [::std::mem::offset_of!(AVBitStreamFilterContext, filter) - 8usize];
    ["Offset of field: AVBitStreamFilterContext::parser"]
        [::std::mem::offset_of!(AVBitStreamFilterContext, parser) - 16usize];
    ["Offset of field: AVBitStreamFilterContext::next"]
        [::std::mem::offset_of!(AVBitStreamFilterContext, next) - 24usize];
    ["Offset of field: AVBitStreamFilterContext::args"]
        [::std::mem::offset_of!(AVBitStreamFilterContext, args) - 32usize];
};
extern "C" {
    #[doc = " @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)\n is deprecated. Use the new bitstream filtering API (using AVBSFContext)."]
    pub fn av_register_bitstream_filter(bsf: *mut AVBitStreamFilter);
}
extern "C" {
    #[doc = " @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)\n is deprecated. Use av_bsf_get_by_name(), av_bsf_alloc(), and av_bsf_init()\n from the new bitstream filtering API (using AVBSFContext)."]
    pub fn av_bitstream_filter_init(name: *const libc::c_char) -> *mut AVBitStreamFilterContext;
}
extern "C" {
    #[doc = " @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)\n is deprecated. Use av_bsf_send_packet() and av_bsf_receive_packet() from the\n new bitstream filtering API (using AVBSFContext)."]
    pub fn av_bitstream_filter_filter(
        bsfc: *mut AVBitStreamFilterContext,
        avctx: *mut AVCodecContext,
        args: *const libc::c_char,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut libc::c_int,
        buf: *const u8,
        buf_size: libc::c_int,
        keyframe: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)\n is deprecated. Use av_bsf_free() from the new bitstream filtering API (using\n AVBSFContext)."]
    pub fn av_bitstream_filter_close(bsf: *mut AVBitStreamFilterContext);
}
extern "C" {
    #[doc = " @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)\n is deprecated. Use av_bsf_iterate() from the new bitstream filtering API (using\n AVBSFContext)."]
    pub fn av_bitstream_filter_next(f: *const AVBitStreamFilter) -> *const AVBitStreamFilter;
}
extern "C" {
    pub fn av_bsf_next(opaque: *mut *mut libc::c_void) -> *const AVBitStreamFilter;
}
extern "C" {
    #[doc = " Same behaviour av_fast_malloc but the buffer has additional\n AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.\n\n In addition the whole buffer will initially and after resizes\n be 0-initialized so that no uninitialized data will ever appear."]
    pub fn av_fast_padded_malloc(ptr: *mut libc::c_void, size: *mut libc::c_uint, min_size: usize);
}
extern "C" {
    #[doc = " Same behaviour av_fast_padded_malloc except that buffer will always\n be 0-initialized after call."]
    pub fn av_fast_padded_mallocz(ptr: *mut libc::c_void, size: *mut libc::c_uint, min_size: usize);
}
extern "C" {
    #[doc = " Encode extradata length to a buffer. Used by xiph codecs.\n\n @param s buffer to write to; must be at least (v/255+1) bytes long\n @param v size of extradata in bytes\n @return number of bytes written to the buffer."]
    pub fn av_xiphlacing(s: *mut libc::c_uchar, v: libc::c_uint) -> libc::c_uint;
}
extern "C" {
    #[doc = " Register the hardware accelerator hwaccel.\n\n @deprecated  This function doesn't do anything."]
    pub fn av_register_hwaccel(hwaccel: *mut AVHWAccel);
}
extern "C" {
    #[doc = " If hwaccel is NULL, returns the first registered hardware accelerator,\n if hwaccel is non-NULL, returns the next registered hardware accelerator\n after hwaccel, or NULL if hwaccel is the last one.\n\n @deprecated  AVHWaccel structures contain no user-serviceable parts, so\n              this function should not be used."]
    pub fn av_hwaccel_next(hwaccel: *const AVHWAccel) -> *mut AVHWAccel;
}
#[repr(u32)]
#[doc = " Lock operation used by lockmgr\n\n @deprecated Deprecated together with av_lockmgr_register()."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVLockOp {
    #[doc = "< Create a mutex"]
    AV_LOCK_CREATE = 0,
    #[doc = "< Lock the mutex"]
    AV_LOCK_OBTAIN = 1,
    #[doc = "< Unlock the mutex"]
    AV_LOCK_RELEASE = 2,
    #[doc = "< Free mutex resources"]
    AV_LOCK_DESTROY = 3,
}
extern "C" {
    #[doc = " Register a user provided lock manager supporting the operations\n specified by AVLockOp. The \"mutex\" argument to the function points\n to a (void *) where the lockmgr should store/get a pointer to a user\n allocated mutex. It is NULL upon AV_LOCK_CREATE and equal to the\n value left by the last call for all other ops. If the lock manager is\n unable to perform the op then it should leave the mutex in the same\n state as when it was called and return a non-zero value. However,\n when called with AV_LOCK_DESTROY the mutex will always be assumed to\n have been successfully destroyed. If av_lockmgr_register succeeds\n it will return a non-negative value, if it fails it will return a\n negative value and destroy all mutex and unregister all callbacks.\n av_lockmgr_register is not thread-safe, it must be called from a\n single thread before any calls which make use of locking are used.\n\n @param cb User defined callback. av_lockmgr_register invokes calls\n           to this callback and the previously registered callback.\n           The callback will be used to create more than one mutex\n           each of which must be backed by its own underlying locking\n           mechanism (i.e. do not use a single static object to\n           implement your lock manager). If cb is set to NULL the\n           lockmgr will be unregistered.\n\n @deprecated This function does nothing, and always returns 0. Be sure to\n             build with thread support to get basic thread safety."]
    pub fn av_lockmgr_register(
        cb: ::std::option::Option<
            unsafe extern "C" fn(mutex: *mut *mut libc::c_void, op: AVLockOp) -> libc::c_int,
        >,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @return a positive value if s is open (i.e. avcodec_open2() was called on it\n with no corresponding avcodec_close()), 0 otherwise."]
    pub fn avcodec_is_open(s: *mut AVCodecContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate a CPB properties structure and initialize its fields to default\n values.\n\n @param size if non-NULL, the size of the allocated struct will be written\n             here. This is useful for embedding it in side data.\n\n @return the newly allocated struct or NULL on failure"]
    pub fn av_cpb_properties_alloc(size: *mut usize) -> *mut AVCPBProperties;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDVProfile {
    pub dsf: libc::c_int,
    pub video_stype: libc::c_int,
    pub frame_size: libc::c_int,
    pub difseg_size: libc::c_int,
    pub n_difchan: libc::c_int,
    pub time_base: AVRational,
    pub ltc_divisor: libc::c_int,
    pub height: libc::c_int,
    pub width: libc::c_int,
    pub sar: [AVRational; 2usize],
    pub pix_fmt: AVPixelFormat,
    pub bpm: libc::c_int,
    pub block_sizes: *const u8,
    pub audio_stride: libc::c_int,
    pub audio_min_samples: [libc::c_int; 3usize],
    pub audio_samples_dist: [libc::c_int; 5usize],
    pub audio_shuffle: *const [libc::c_uchar; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVDVProfile"][::std::mem::size_of::<AVDVProfile>() - 120usize];
    ["Alignment of AVDVProfile"][::std::mem::align_of::<AVDVProfile>() - 8usize];
    ["Offset of field: AVDVProfile::dsf"][::std::mem::offset_of!(AVDVProfile, dsf) - 0usize];
    ["Offset of field: AVDVProfile::video_stype"]
        [::std::mem::offset_of!(AVDVProfile, video_stype) - 4usize];
    ["Offset of field: AVDVProfile::frame_size"]
        [::std::mem::offset_of!(AVDVProfile, frame_size) - 8usize];
    ["Offset of field: AVDVProfile::difseg_size"]
        [::std::mem::offset_of!(AVDVProfile, difseg_size) - 12usize];
    ["Offset of field: AVDVProfile::n_difchan"]
        [::std::mem::offset_of!(AVDVProfile, n_difchan) - 16usize];
    ["Offset of field: AVDVProfile::time_base"]
        [::std::mem::offset_of!(AVDVProfile, time_base) - 20usize];
    ["Offset of field: AVDVProfile::ltc_divisor"]
        [::std::mem::offset_of!(AVDVProfile, ltc_divisor) - 28usize];
    ["Offset of field: AVDVProfile::height"][::std::mem::offset_of!(AVDVProfile, height) - 32usize];
    ["Offset of field: AVDVProfile::width"][::std::mem::offset_of!(AVDVProfile, width) - 36usize];
    ["Offset of field: AVDVProfile::sar"][::std::mem::offset_of!(AVDVProfile, sar) - 40usize];
    ["Offset of field: AVDVProfile::pix_fmt"]
        [::std::mem::offset_of!(AVDVProfile, pix_fmt) - 56usize];
    ["Offset of field: AVDVProfile::bpm"][::std::mem::offset_of!(AVDVProfile, bpm) - 60usize];
    ["Offset of field: AVDVProfile::block_sizes"]
        [::std::mem::offset_of!(AVDVProfile, block_sizes) - 64usize];
    ["Offset of field: AVDVProfile::audio_stride"]
        [::std::mem::offset_of!(AVDVProfile, audio_stride) - 72usize];
    ["Offset of field: AVDVProfile::audio_min_samples"]
        [::std::mem::offset_of!(AVDVProfile, audio_min_samples) - 76usize];
    ["Offset of field: AVDVProfile::audio_samples_dist"]
        [::std::mem::offset_of!(AVDVProfile, audio_samples_dist) - 88usize];
    ["Offset of field: AVDVProfile::audio_shuffle"]
        [::std::mem::offset_of!(AVDVProfile, audio_shuffle) - 112usize];
};
extern "C" {
    #[doc = " Get a DV profile for the provided compressed frame.\n\n @param sys the profile used for the previous frame, may be NULL\n @param frame the compressed data buffer\n @param buf_size size of the buffer in bytes\n @return the DV profile for the supplied data or NULL on failure"]
    pub fn av_dv_frame_profile(
        sys: *const AVDVProfile,
        frame: *const u8,
        buf_size: libc::c_uint,
    ) -> *const AVDVProfile;
}
extern "C" {
    #[doc = " Get a DV profile for the provided stream parameters."]
    pub fn av_dv_codec_profile(
        width: libc::c_int,
        height: libc::c_int,
        pix_fmt: AVPixelFormat,
    ) -> *const AVDVProfile;
}
extern "C" {
    #[doc = " Get a DV profile for the provided stream parameters.\n The frame rate is used as a best-effort parameter."]
    pub fn av_dv_codec_profile2(
        width: libc::c_int,
        height: libc::c_int,
        pix_fmt: AVPixelFormat,
        frame_rate: AVRational,
    ) -> *const AVDVProfile;
}
#[doc = " @defgroup lavc_fft FFT functions\n @ingroup lavc_misc\n\n @{"]
pub type FFTSample = f32;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct FFTComplex {
    pub re: FFTSample,
    pub im: FFTSample,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FFTComplex"][::std::mem::size_of::<FFTComplex>() - 8usize];
    ["Alignment of FFTComplex"][::std::mem::align_of::<FFTComplex>() - 4usize];
    ["Offset of field: FFTComplex::re"][::std::mem::offset_of!(FFTComplex, re) - 0usize];
    ["Offset of field: FFTComplex::im"][::std::mem::offset_of!(FFTComplex, im) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FFTContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Set up a complex FFT.\n @param nbits           log2 of the length of the input array\n @param inverse         if 0 perform the forward transform, if 1 perform the inverse"]
    pub fn av_fft_init(nbits: libc::c_int, inverse: libc::c_int) -> *mut FFTContext;
}
extern "C" {
    #[doc = " Do the permutation needed BEFORE calling ff_fft_calc()."]
    pub fn av_fft_permute(s: *mut FFTContext, z: *mut FFTComplex);
}
extern "C" {
    #[doc = " Do a complex FFT with the parameters defined in av_fft_init(). The\n input data must be permuted before. No 1.0/sqrt(n) normalization is done."]
    pub fn av_fft_calc(s: *mut FFTContext, z: *mut FFTComplex);
}
extern "C" {
    pub fn av_fft_end(s: *mut FFTContext);
}
extern "C" {
    pub fn av_mdct_init(nbits: libc::c_int, inverse: libc::c_int, scale: f64) -> *mut FFTContext;
}
extern "C" {
    pub fn av_imdct_calc(s: *mut FFTContext, output: *mut FFTSample, input: *const FFTSample);
}
extern "C" {
    pub fn av_imdct_half(s: *mut FFTContext, output: *mut FFTSample, input: *const FFTSample);
}
extern "C" {
    pub fn av_mdct_calc(s: *mut FFTContext, output: *mut FFTSample, input: *const FFTSample);
}
extern "C" {
    pub fn av_mdct_end(s: *mut FFTContext);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RDFTransformType {
    DFT_R2C = 0,
    IDFT_C2R = 1,
    IDFT_R2C = 2,
    DFT_C2R = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RDFTContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Set up a real FFT.\n @param nbits           log2 of the length of the input array\n @param trans           the type of transform"]
    pub fn av_rdft_init(nbits: libc::c_int, trans: RDFTransformType) -> *mut RDFTContext;
}
extern "C" {
    pub fn av_rdft_calc(s: *mut RDFTContext, data: *mut FFTSample);
}
extern "C" {
    pub fn av_rdft_end(s: *mut RDFTContext);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DCTContext {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DCTTransformType {
    DCT_II = 0,
    DCT_III = 1,
    DCT_I = 2,
    DST_I = 3,
}
extern "C" {
    #[doc = " Set up DCT.\n\n @param nbits           size of the input array:\n                        (1 << nbits)     for DCT-II, DCT-III and DST-I\n                        (1 << nbits) + 1 for DCT-I\n @param type            the type of transform\n\n @note the first element of the input of DST-I is ignored"]
    pub fn av_dct_init(nbits: libc::c_int, type_: DCTTransformType) -> *mut DCTContext;
}
extern "C" {
    pub fn av_dct_calc(s: *mut DCTContext, data: *mut FFTSample);
}
extern "C" {
    pub fn av_dct_end(s: *mut DCTContext);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVVorbisParseContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and initialize the Vorbis parser using headers in the extradata."]
    pub fn av_vorbis_parse_init(
        extradata: *const u8,
        extradata_size: libc::c_int,
    ) -> *mut AVVorbisParseContext;
}
extern "C" {
    #[doc = " Free the parser and everything associated with it."]
    pub fn av_vorbis_parse_free(s: *mut *mut AVVorbisParseContext);
}
extern "C" {
    #[doc = " Get the duration for a Vorbis packet.\n\n If @p flags is @c NULL,\n special frames are considered invalid.\n\n @param s        Vorbis parser context\n @param buf      buffer containing a Vorbis frame\n @param buf_size size of the buffer\n @param flags    flags for special frames"]
    pub fn av_vorbis_parse_frame_flags(
        s: *mut AVVorbisParseContext,
        buf: *const u8,
        buf_size: libc::c_int,
        flags: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the duration for a Vorbis packet.\n\n @param s        Vorbis parser context\n @param buf      buffer containing a Vorbis frame\n @param buf_size size of the buffer"]
    pub fn av_vorbis_parse_frame(
        s: *mut AVVorbisParseContext,
        buf: *const u8,
        buf_size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_vorbis_parse_reset(s: *mut AVVorbisParseContext);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tm"][::std::mem::size_of::<tm>() - 56usize];
    ["Alignment of tm"][::std::mem::align_of::<tm>() - 8usize];
    ["Offset of field: tm::tm_sec"][::std::mem::offset_of!(tm, tm_sec) - 0usize];
    ["Offset of field: tm::tm_min"][::std::mem::offset_of!(tm, tm_min) - 4usize];
    ["Offset of field: tm::tm_hour"][::std::mem::offset_of!(tm, tm_hour) - 8usize];
    ["Offset of field: tm::tm_mday"][::std::mem::offset_of!(tm, tm_mday) - 12usize];
    ["Offset of field: tm::tm_mon"][::std::mem::offset_of!(tm, tm_mon) - 16usize];
    ["Offset of field: tm::tm_year"][::std::mem::offset_of!(tm, tm_year) - 20usize];
    ["Offset of field: tm::tm_wday"][::std::mem::offset_of!(tm, tm_wday) - 24usize];
    ["Offset of field: tm::tm_yday"][::std::mem::offset_of!(tm, tm_yday) - 28usize];
    ["Offset of field: tm::tm_isdst"][::std::mem::offset_of!(tm, tm_isdst) - 32usize];
    ["Offset of field: tm::tm_gmtoff"][::std::mem::offset_of!(tm, tm_gmtoff) - 40usize];
    ["Offset of field: tm::tm_zone"][::std::mem::offset_of!(tm, tm_zone) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerspec"][::std::mem::size_of::<itimerspec>() - 32usize];
    ["Alignment of itimerspec"][::std::mem::align_of::<itimerspec>() - 8usize];
    ["Offset of field: itimerspec::it_interval"]
        [::std::mem::offset_of!(itimerspec, it_interval) - 0usize];
    ["Offset of field: itimerspec::it_value"]
        [::std::mem::offset_of!(itimerspec, it_value) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut libc::c_char,
        __maxsize: usize,
        __format: *const libc::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut libc::c_char,
        __maxsize: usize,
        __format: *const libc::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: libc::c_int;
}
extern "C" {
    pub static mut __timezone: libc::c_long;
}
extern "C" {
    pub static mut tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: libc::c_int;
}
extern "C" {
    pub static mut timezone: libc::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec, __remaining: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: libc::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> libc::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: libc::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> libc::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: libc::c_int) -> libc::c_int;
}
#[doc = " Callback for checking whether to abort blocking functions.\n AVERROR_EXIT is returned in this case by the interrupted\n function. During blocking operations, callback is called with\n opaque as parameter. If the callback returns 1, the\n blocking operation will be aborted.\n\n No members can be added to this struct without a major bump, if\n new elements have been added after this struct in AVFormatContext\n or AVIOContext."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVIOInterruptCB {
    pub callback:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void) -> libc::c_int>,
    pub opaque: *mut libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVIOInterruptCB"][::std::mem::size_of::<AVIOInterruptCB>() - 16usize];
    ["Alignment of AVIOInterruptCB"][::std::mem::align_of::<AVIOInterruptCB>() - 8usize];
    ["Offset of field: AVIOInterruptCB::callback"]
        [::std::mem::offset_of!(AVIOInterruptCB, callback) - 0usize];
    ["Offset of field: AVIOInterruptCB::opaque"]
        [::std::mem::offset_of!(AVIOInterruptCB, opaque) - 8usize];
};
#[repr(u32)]
#[doc = " Directory entry types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVIODirEntryType {
    AVIO_ENTRY_UNKNOWN = 0,
    AVIO_ENTRY_BLOCK_DEVICE = 1,
    AVIO_ENTRY_CHARACTER_DEVICE = 2,
    AVIO_ENTRY_DIRECTORY = 3,
    AVIO_ENTRY_NAMED_PIPE = 4,
    AVIO_ENTRY_SYMBOLIC_LINK = 5,
    AVIO_ENTRY_SOCKET = 6,
    AVIO_ENTRY_FILE = 7,
    AVIO_ENTRY_SERVER = 8,
    AVIO_ENTRY_SHARE = 9,
    AVIO_ENTRY_WORKGROUP = 10,
}
#[doc = " Describes single entry of the directory.\n\n Only name and type fields are guaranteed be set.\n Rest of fields are protocol or/and platform dependent and might be unknown."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVIODirEntry {
    #[doc = "< Filename"]
    pub name: *mut libc::c_char,
    #[doc = "< Type of the entry"]
    pub type_: libc::c_int,
    #[doc = "< Set to 1 when name is encoded with UTF-8, 0 otherwise.\nName can be encoded with UTF-8 even though 0 is set."]
    pub utf8: libc::c_int,
    #[doc = "< File size in bytes, -1 if unknown."]
    pub size: i64,
    #[doc = "< Time of last modification in microseconds since unix\nepoch, -1 if unknown."]
    pub modification_timestamp: i64,
    #[doc = "< Time of last access in microseconds since unix epoch,\n-1 if unknown."]
    pub access_timestamp: i64,
    #[doc = "< Time of last status change in microseconds since unix\nepoch, -1 if unknown."]
    pub status_change_timestamp: i64,
    #[doc = "< User ID of owner, -1 if unknown."]
    pub user_id: i64,
    #[doc = "< Group ID of owner, -1 if unknown."]
    pub group_id: i64,
    #[doc = "< Unix file mode, -1 if unknown."]
    pub filemode: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVIODirEntry"][::std::mem::size_of::<AVIODirEntry>() - 72usize];
    ["Alignment of AVIODirEntry"][::std::mem::align_of::<AVIODirEntry>() - 8usize];
    ["Offset of field: AVIODirEntry::name"][::std::mem::offset_of!(AVIODirEntry, name) - 0usize];
    ["Offset of field: AVIODirEntry::type_"][::std::mem::offset_of!(AVIODirEntry, type_) - 8usize];
    ["Offset of field: AVIODirEntry::utf8"][::std::mem::offset_of!(AVIODirEntry, utf8) - 12usize];
    ["Offset of field: AVIODirEntry::size"][::std::mem::offset_of!(AVIODirEntry, size) - 16usize];
    ["Offset of field: AVIODirEntry::modification_timestamp"]
        [::std::mem::offset_of!(AVIODirEntry, modification_timestamp) - 24usize];
    ["Offset of field: AVIODirEntry::access_timestamp"]
        [::std::mem::offset_of!(AVIODirEntry, access_timestamp) - 32usize];
    ["Offset of field: AVIODirEntry::status_change_timestamp"]
        [::std::mem::offset_of!(AVIODirEntry, status_change_timestamp) - 40usize];
    ["Offset of field: AVIODirEntry::user_id"]
        [::std::mem::offset_of!(AVIODirEntry, user_id) - 48usize];
    ["Offset of field: AVIODirEntry::group_id"]
        [::std::mem::offset_of!(AVIODirEntry, group_id) - 56usize];
    ["Offset of field: AVIODirEntry::filemode"]
        [::std::mem::offset_of!(AVIODirEntry, filemode) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVIODirContext {
    pub url_context: *mut URLContext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVIODirContext"][::std::mem::size_of::<AVIODirContext>() - 8usize];
    ["Alignment of AVIODirContext"][::std::mem::align_of::<AVIODirContext>() - 8usize];
    ["Offset of field: AVIODirContext::url_context"]
        [::std::mem::offset_of!(AVIODirContext, url_context) - 0usize];
};
#[repr(u32)]
#[doc = " Different data types that can be returned via the AVIO\n write_data_type callback."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVIODataMarkerType {
    #[doc = " Header data; this needs to be present for the stream to be decodeable."]
    AVIO_DATA_MARKER_HEADER = 0,
    #[doc = " A point in the output bytestream where a decoder can start decoding\n (i.e. a keyframe). A demuxer/decoder given the data flagged with\n AVIO_DATA_MARKER_HEADER, followed by any AVIO_DATA_MARKER_SYNC_POINT,\n should give decodeable results."]
    AVIO_DATA_MARKER_SYNC_POINT = 1,
    #[doc = " A point in the output bytestream where a demuxer can start parsing\n (for non self synchronizing bytestream formats). That is, any\n non-keyframe packet start point."]
    AVIO_DATA_MARKER_BOUNDARY_POINT = 2,
    #[doc = " This is any, unlabelled data. It can either be a muxer not marking\n any positions at all, it can be an actual boundary/sync point\n that the muxer chooses not to mark, or a later part of a packet/fragment\n that is cut into multiple write callbacks due to limited IO buffer size."]
    AVIO_DATA_MARKER_UNKNOWN = 3,
    #[doc = " Trailer data, which doesn't contain actual content, but only for\n finalizing the output file."]
    AVIO_DATA_MARKER_TRAILER = 4,
    #[doc = " A point in the output bytestream where the underlying AVIOContext might\n flush the buffer depending on latency or buffering requirements. Typically\n means the end of a packet."]
    AVIO_DATA_MARKER_FLUSH_POINT = 5,
}
#[doc = " Bytestream IO Context.\n New fields can be added to the end with minor version bumps.\n Removal, reordering and changes to existing fields require a major\n version bump.\n sizeof(AVIOContext) must not be used outside libav*.\n\n @note None of the function pointers in AVIOContext should be called\n       directly, they should only be set by the client application\n       when implementing custom I/O. Normally these are set to the\n       function pointers specified in avio_alloc_context()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVIOContext {
    #[doc = " A class for private options.\n\n If this AVIOContext is created by avio_open2(), av_class is set and\n passes the options down to protocols.\n\n If this AVIOContext is manually allocated, then av_class may be set by\n the caller.\n\n warning -- this field can be NULL, be sure to not pass this AVIOContext\n to any av_opt_* functions in that case."]
    pub av_class: *const AVClass,
    #[doc = "< Start of the buffer."]
    pub buffer: *mut libc::c_uchar,
    #[doc = "< Maximum buffer size"]
    pub buffer_size: libc::c_int,
    #[doc = "< Current position in the buffer"]
    pub buf_ptr: *mut libc::c_uchar,
    #[doc = "< End of the data, may be less than\nbuffer+buffer_size if the read function returned\nless data than requested, e.g. for streams where\nno more data has been received yet."]
    pub buf_end: *mut libc::c_uchar,
    #[doc = "< A private pointer, passed to the read/write/seek/...\nfunctions."]
    pub opaque: *mut libc::c_void,
    pub read_packet: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut libc::c_void,
            buf: *mut u8,
            buf_size: libc::c_int,
        ) -> libc::c_int,
    >,
    pub write_packet: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut libc::c_void,
            buf: *mut u8,
            buf_size: libc::c_int,
        ) -> libc::c_int,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(opaque: *mut libc::c_void, offset: i64, whence: libc::c_int) -> i64,
    >,
    #[doc = "< position in the file of the current buffer"]
    pub pos: i64,
    #[doc = "< true if was unable to read due to error or eof"]
    pub eof_reached: libc::c_int,
    #[doc = "< true if open for writing"]
    pub write_flag: libc::c_int,
    pub max_packet_size: libc::c_int,
    pub checksum: libc::c_ulong,
    pub checksum_ptr: *mut libc::c_uchar,
    pub update_checksum: ::std::option::Option<
        unsafe extern "C" fn(
            checksum: libc::c_ulong,
            buf: *const u8,
            size: libc::c_uint,
        ) -> libc::c_ulong,
    >,
    #[doc = "< contains the error code or 0 if no error happened"]
    pub error: libc::c_int,
    #[doc = " Pause or resume playback for network streaming protocols - e.g. MMS."]
    pub read_pause: ::std::option::Option<
        unsafe extern "C" fn(opaque: *mut libc::c_void, pause: libc::c_int) -> libc::c_int,
    >,
    #[doc = " Seek to a given timestamp in stream with the specified stream_index.\n Needed for some network streaming protocols which don't support seeking\n to byte position."]
    pub read_seek: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut libc::c_void,
            stream_index: libc::c_int,
            timestamp: i64,
            flags: libc::c_int,
        ) -> i64,
    >,
    #[doc = " A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable."]
    pub seekable: libc::c_int,
    #[doc = " max filesize, used to limit allocations\n This field is internal to libavformat and access from outside is not allowed."]
    pub maxsize: i64,
    #[doc = " avio_read and avio_write should if possible be satisfied directly\n instead of going through a buffer, and avio_seek will always\n call the underlying seek function directly."]
    pub direct: libc::c_int,
    #[doc = " Bytes read statistic\n This field is internal to libavformat and access from outside is not allowed."]
    pub bytes_read: i64,
    #[doc = " seek statistic\n This field is internal to libavformat and access from outside is not allowed."]
    pub seek_count: libc::c_int,
    #[doc = " writeout statistic\n This field is internal to libavformat and access from outside is not allowed."]
    pub writeout_count: libc::c_int,
    #[doc = " Original buffer size\n used internally after probing and ensure seekback to reset the buffer size\n This field is internal to libavformat and access from outside is not allowed."]
    pub orig_buffer_size: libc::c_int,
    #[doc = " Threshold to favor readahead over seek.\n This is current internal only, do not use from outside."]
    pub short_seek_threshold: libc::c_int,
    #[doc = " ',' separated list of allowed protocols."]
    pub protocol_whitelist: *const libc::c_char,
    #[doc = " ',' separated list of disallowed protocols."]
    pub protocol_blacklist: *const libc::c_char,
    #[doc = " A callback that is used instead of write_packet."]
    pub write_data_type: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut libc::c_void,
            buf: *mut u8,
            buf_size: libc::c_int,
            type_: AVIODataMarkerType,
            time: i64,
        ) -> libc::c_int,
    >,
    #[doc = " If set, don't call write_data_type separately for AVIO_DATA_MARKER_BOUNDARY_POINT,\n but ignore them and treat them as AVIO_DATA_MARKER_UNKNOWN (to avoid needlessly\n small chunks of data returned from the callback)."]
    pub ignore_boundary_point: libc::c_int,
    #[doc = " Internal, not meant to be used from outside of AVIOContext."]
    pub current_type: AVIODataMarkerType,
    pub last_time: i64,
    #[doc = " A callback that is used instead of short_seek_threshold.\n This is current internal only, do not use from outside."]
    pub short_seek_get:
        ::std::option::Option<unsafe extern "C" fn(opaque: *mut libc::c_void) -> libc::c_int>,
    pub written: i64,
    #[doc = " Maximum reached position before a backward seek in the write buffer,\n used keeping track of already written data for a later flush."]
    pub buf_ptr_max: *mut libc::c_uchar,
    #[doc = " Try to buffer at least this amount of data before flushing it"]
    pub min_packet_size: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVIOContext"][::std::mem::size_of::<AVIOContext>() - 264usize];
    ["Alignment of AVIOContext"][::std::mem::align_of::<AVIOContext>() - 8usize];
    ["Offset of field: AVIOContext::av_class"]
        [::std::mem::offset_of!(AVIOContext, av_class) - 0usize];
    ["Offset of field: AVIOContext::buffer"][::std::mem::offset_of!(AVIOContext, buffer) - 8usize];
    ["Offset of field: AVIOContext::buffer_size"]
        [::std::mem::offset_of!(AVIOContext, buffer_size) - 16usize];
    ["Offset of field: AVIOContext::buf_ptr"]
        [::std::mem::offset_of!(AVIOContext, buf_ptr) - 24usize];
    ["Offset of field: AVIOContext::buf_end"]
        [::std::mem::offset_of!(AVIOContext, buf_end) - 32usize];
    ["Offset of field: AVIOContext::opaque"][::std::mem::offset_of!(AVIOContext, opaque) - 40usize];
    ["Offset of field: AVIOContext::read_packet"]
        [::std::mem::offset_of!(AVIOContext, read_packet) - 48usize];
    ["Offset of field: AVIOContext::write_packet"]
        [::std::mem::offset_of!(AVIOContext, write_packet) - 56usize];
    ["Offset of field: AVIOContext::seek"][::std::mem::offset_of!(AVIOContext, seek) - 64usize];
    ["Offset of field: AVIOContext::pos"][::std::mem::offset_of!(AVIOContext, pos) - 72usize];
    ["Offset of field: AVIOContext::eof_reached"]
        [::std::mem::offset_of!(AVIOContext, eof_reached) - 80usize];
    ["Offset of field: AVIOContext::write_flag"]
        [::std::mem::offset_of!(AVIOContext, write_flag) - 84usize];
    ["Offset of field: AVIOContext::max_packet_size"]
        [::std::mem::offset_of!(AVIOContext, max_packet_size) - 88usize];
    ["Offset of field: AVIOContext::checksum"]
        [::std::mem::offset_of!(AVIOContext, checksum) - 96usize];
    ["Offset of field: AVIOContext::checksum_ptr"]
        [::std::mem::offset_of!(AVIOContext, checksum_ptr) - 104usize];
    ["Offset of field: AVIOContext::update_checksum"]
        [::std::mem::offset_of!(AVIOContext, update_checksum) - 112usize];
    ["Offset of field: AVIOContext::error"][::std::mem::offset_of!(AVIOContext, error) - 120usize];
    ["Offset of field: AVIOContext::read_pause"]
        [::std::mem::offset_of!(AVIOContext, read_pause) - 128usize];
    ["Offset of field: AVIOContext::read_seek"]
        [::std::mem::offset_of!(AVIOContext, read_seek) - 136usize];
    ["Offset of field: AVIOContext::seekable"]
        [::std::mem::offset_of!(AVIOContext, seekable) - 144usize];
    ["Offset of field: AVIOContext::maxsize"]
        [::std::mem::offset_of!(AVIOContext, maxsize) - 152usize];
    ["Offset of field: AVIOContext::direct"]
        [::std::mem::offset_of!(AVIOContext, direct) - 160usize];
    ["Offset of field: AVIOContext::bytes_read"]
        [::std::mem::offset_of!(AVIOContext, bytes_read) - 168usize];
    ["Offset of field: AVIOContext::seek_count"]
        [::std::mem::offset_of!(AVIOContext, seek_count) - 176usize];
    ["Offset of field: AVIOContext::writeout_count"]
        [::std::mem::offset_of!(AVIOContext, writeout_count) - 180usize];
    ["Offset of field: AVIOContext::orig_buffer_size"]
        [::std::mem::offset_of!(AVIOContext, orig_buffer_size) - 184usize];
    ["Offset of field: AVIOContext::short_seek_threshold"]
        [::std::mem::offset_of!(AVIOContext, short_seek_threshold) - 188usize];
    ["Offset of field: AVIOContext::protocol_whitelist"]
        [::std::mem::offset_of!(AVIOContext, protocol_whitelist) - 192usize];
    ["Offset of field: AVIOContext::protocol_blacklist"]
        [::std::mem::offset_of!(AVIOContext, protocol_blacklist) - 200usize];
    ["Offset of field: AVIOContext::write_data_type"]
        [::std::mem::offset_of!(AVIOContext, write_data_type) - 208usize];
    ["Offset of field: AVIOContext::ignore_boundary_point"]
        [::std::mem::offset_of!(AVIOContext, ignore_boundary_point) - 216usize];
    ["Offset of field: AVIOContext::current_type"]
        [::std::mem::offset_of!(AVIOContext, current_type) - 220usize];
    ["Offset of field: AVIOContext::last_time"]
        [::std::mem::offset_of!(AVIOContext, last_time) - 224usize];
    ["Offset of field: AVIOContext::short_seek_get"]
        [::std::mem::offset_of!(AVIOContext, short_seek_get) - 232usize];
    ["Offset of field: AVIOContext::written"]
        [::std::mem::offset_of!(AVIOContext, written) - 240usize];
    ["Offset of field: AVIOContext::buf_ptr_max"]
        [::std::mem::offset_of!(AVIOContext, buf_ptr_max) - 248usize];
    ["Offset of field: AVIOContext::min_packet_size"]
        [::std::mem::offset_of!(AVIOContext, min_packet_size) - 256usize];
};
extern "C" {
    #[doc = " Return the name of the protocol that will handle the passed URL.\n\n NULL is returned if no protocol could be found for the given URL.\n\n @return Name of the protocol or NULL."]
    pub fn avio_find_protocol_name(url: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return AVIO_FLAG_* access flags corresponding to the access permissions\n of the resource in url, or a negative value corresponding to an\n AVERROR code in case of failure. The returned access flags are\n masked by the value in flags.\n\n @note This function is intrinsically unsafe, in the sense that the\n checked resource may change its existence or permission status from\n one call to another. Thus you should not trust the returned value,\n unless you are sure that no other processes are accessing the\n checked resource."]
    pub fn avio_check(url: *const libc::c_char, flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Move or rename a resource.\n\n @note url_src and url_dst should share the same protocol and authority.\n\n @param url_src url to resource to be moved\n @param url_dst new url to resource if the operation succeeded\n @return >=0 on success or negative on error."]
    pub fn avpriv_io_move(
        url_src: *const libc::c_char,
        url_dst: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Delete a resource.\n\n @param url resource to be deleted.\n @return >=0 on success or negative on error."]
    pub fn avpriv_io_delete(url: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Open directory for reading.\n\n @param s       directory read context. Pointer to a NULL pointer must be passed.\n @param url     directory to be listed.\n @param options A dictionary filled with protocol-private options. On return\n                this parameter will be destroyed and replaced with a dictionary\n                containing options that were not found. May be NULL.\n @return >=0 on success or negative on error."]
    pub fn avio_open_dir(
        s: *mut *mut AVIODirContext,
        url: *const libc::c_char,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get next directory entry.\n\n Returned entry must be freed with avio_free_directory_entry(). In particular\n it may outlive AVIODirContext.\n\n @param s         directory read context.\n @param[out] next next entry or NULL when no more entries.\n @return >=0 on success or negative on error. End of list is not considered an\n             error."]
    pub fn avio_read_dir(s: *mut AVIODirContext, next: *mut *mut AVIODirEntry) -> libc::c_int;
}
extern "C" {
    #[doc = " Close directory.\n\n @note Entries created using avio_read_dir() are not deleted and must be\n freeded with avio_free_directory_entry().\n\n @param s         directory read context.\n @return >=0 on success or negative on error."]
    pub fn avio_close_dir(s: *mut *mut AVIODirContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Free entry allocated by avio_read_dir().\n\n @param entry entry to be freed."]
    pub fn avio_free_directory_entry(entry: *mut *mut AVIODirEntry);
}
extern "C" {
    #[doc = " Allocate and initialize an AVIOContext for buffered I/O. It must be later\n freed with avio_context_free().\n\n @param buffer Memory block for input/output operations via AVIOContext.\n        The buffer must be allocated with av_malloc() and friends.\n        It may be freed and replaced with a new buffer by libavformat.\n        AVIOContext.buffer holds the buffer currently in use,\n        which must be later freed with av_free().\n @param buffer_size The buffer size is very important for performance.\n        For protocols with fixed blocksize it should be set to this blocksize.\n        For others a typical size is a cache page, e.g. 4kb.\n @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.\n @param opaque An opaque pointer to user-specific data.\n @param read_packet  A function for refilling the buffer, may be NULL.\n                     For stream protocols, must never return 0 but rather\n                     a proper AVERROR code.\n @param write_packet A function for writing the buffer contents, may be NULL.\n        The function may not change the input buffers content.\n @param seek A function for seeking to specified byte position, may be NULL.\n\n @return Allocated AVIOContext or NULL on failure."]
    pub fn avio_alloc_context(
        buffer: *mut libc::c_uchar,
        buffer_size: libc::c_int,
        write_flag: libc::c_int,
        opaque: *mut libc::c_void,
        read_packet: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut libc::c_void,
                buf: *mut u8,
                buf_size: libc::c_int,
            ) -> libc::c_int,
        >,
        write_packet: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut libc::c_void,
                buf: *mut u8,
                buf_size: libc::c_int,
            ) -> libc::c_int,
        >,
        seek: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut libc::c_void,
                offset: i64,
                whence: libc::c_int,
            ) -> i64,
        >,
    ) -> *mut AVIOContext;
}
extern "C" {
    #[doc = " Free the supplied IO context and everything associated with it.\n\n @param s Double pointer to the IO context. This function will write NULL\n into s."]
    pub fn avio_context_free(s: *mut *mut AVIOContext);
}
extern "C" {
    pub fn avio_w8(s: *mut AVIOContext, b: libc::c_int);
}
extern "C" {
    pub fn avio_write(s: *mut AVIOContext, buf: *const libc::c_uchar, size: libc::c_int);
}
extern "C" {
    pub fn avio_wl64(s: *mut AVIOContext, val: u64);
}
extern "C" {
    pub fn avio_wb64(s: *mut AVIOContext, val: u64);
}
extern "C" {
    pub fn avio_wl32(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wb32(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wl24(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wb24(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wl16(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wb16(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    #[doc = " Write a NULL-terminated string.\n @return number of bytes written."]
    pub fn avio_put_str(s: *mut AVIOContext, str_: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Convert an UTF-8 string to UTF-16LE and write it.\n @param s the AVIOContext\n @param str NULL-terminated UTF-8 string\n\n @return number of bytes written."]
    pub fn avio_put_str16le(s: *mut AVIOContext, str_: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Convert an UTF-8 string to UTF-16BE and write it.\n @param s the AVIOContext\n @param str NULL-terminated UTF-8 string\n\n @return number of bytes written."]
    pub fn avio_put_str16be(s: *mut AVIOContext, str_: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Mark the written bytestream as a specific type.\n\n Zero-length ranges are omitted from the output.\n\n @param time the stream time the current bytestream pos corresponds to\n             (in AV_TIME_BASE units), or AV_NOPTS_VALUE if unknown or not\n             applicable\n @param type the kind of data written starting at the current pos"]
    pub fn avio_write_marker(s: *mut AVIOContext, time: i64, type_: AVIODataMarkerType);
}
extern "C" {
    #[doc = " fseek() equivalent for AVIOContext.\n @return new position or AVERROR."]
    pub fn avio_seek(s: *mut AVIOContext, offset: i64, whence: libc::c_int) -> i64;
}
extern "C" {
    #[doc = " Skip given number of bytes forward\n @return new position or AVERROR."]
    pub fn avio_skip(s: *mut AVIOContext, offset: i64) -> i64;
}
extern "C" {
    #[doc = " Get the filesize.\n @return filesize or AVERROR"]
    pub fn avio_size(s: *mut AVIOContext) -> i64;
}
extern "C" {
    #[doc = " Similar to feof() but also returns nonzero on read errors.\n @return non zero if and only if at end of file or a read error happened when reading."]
    pub fn avio_feof(s: *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Writes a formatted string to the context.\n @return number of bytes written, < 0 on error."]
    pub fn avio_printf(s: *mut AVIOContext, fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[doc = " Write a NULL terminated array of strings to the context.\n Usually you don't need to use this function directly but its macro wrapper,\n avio_print."]
    pub fn avio_print_string_array(s: *mut AVIOContext, strings: *mut *const libc::c_char);
}
extern "C" {
    #[doc = " Force flushing of buffered data.\n\n For write streams, force the buffered data to be immediately written to the output,\n without to wait to fill the internal buffer.\n\n For read streams, discard all currently buffered data, and advance the\n reported file position to that of the underlying stream. This does not\n read new data, and does not perform any seeks."]
    pub fn avio_flush(s: *mut AVIOContext);
}
extern "C" {
    #[doc = " Read size bytes from AVIOContext into buf.\n @return number of bytes read or AVERROR"]
    pub fn avio_read(
        s: *mut AVIOContext,
        buf: *mut libc::c_uchar,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read size bytes from AVIOContext into buf. Unlike avio_read(), this is allowed\n to read fewer bytes than requested. The missing bytes can be read in the next\n call. This always tries to read at least 1 byte.\n Useful to reduce latency in certain cases.\n @return number of bytes read or AVERROR"]
    pub fn avio_read_partial(
        s: *mut AVIOContext,
        buf: *mut libc::c_uchar,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @name Functions for reading from AVIOContext\n @{\n\n @note return 0 if EOF, so you cannot use it if EOF handling is\n       necessary"]
    pub fn avio_r8(s: *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    pub fn avio_rl16(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rl24(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rl32(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rl64(s: *mut AVIOContext) -> u64;
}
extern "C" {
    pub fn avio_rb16(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rb24(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rb32(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rb64(s: *mut AVIOContext) -> u64;
}
extern "C" {
    #[doc = " Read a string from pb into buf. The reading will terminate when either\n a NULL character was encountered, maxlen bytes have been read, or nothing\n more can be read from pb. The result is guaranteed to be NULL-terminated, it\n will be truncated if buf is too small.\n Note that the string is not interpreted or validated in any way, it\n might get truncated in the middle of a sequence for multi-byte encodings.\n\n @return number of bytes read (is always <= maxlen).\n If reading ends on EOF or error, the return value will be one more than\n bytes actually read."]
    pub fn avio_get_str(
        pb: *mut AVIOContext,
        maxlen: libc::c_int,
        buf: *mut libc::c_char,
        buflen: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read a UTF-16 string from pb and convert it to UTF-8.\n The reading will terminate when either a null or invalid character was\n encountered or maxlen bytes have been read.\n @return number of bytes read (is always <= maxlen)"]
    pub fn avio_get_str16le(
        pb: *mut AVIOContext,
        maxlen: libc::c_int,
        buf: *mut libc::c_char,
        buflen: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avio_get_str16be(
        pb: *mut AVIOContext,
        maxlen: libc::c_int,
        buf: *mut libc::c_char,
        buflen: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Create and initialize a AVIOContext for accessing the\n resource indicated by url.\n @note When the resource indicated by url has been opened in\n read+write mode, the AVIOContext can be used only for writing.\n\n @param s Used to return the pointer to the created AVIOContext.\n In case of failure the pointed to value is set to NULL.\n @param url resource to access\n @param flags flags which control how the resource indicated by url\n is to be opened\n @return >= 0 in case of success, a negative value corresponding to an\n AVERROR code in case of failure"]
    pub fn avio_open(
        s: *mut *mut AVIOContext,
        url: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Create and initialize a AVIOContext for accessing the\n resource indicated by url.\n @note When the resource indicated by url has been opened in\n read+write mode, the AVIOContext can be used only for writing.\n\n @param s Used to return the pointer to the created AVIOContext.\n In case of failure the pointed to value is set to NULL.\n @param url resource to access\n @param flags flags which control how the resource indicated by url\n is to be opened\n @param int_cb an interrupt callback to be used at the protocols level\n @param options  A dictionary filled with protocol-private options. On return\n this parameter will be destroyed and replaced with a dict containing options\n that were not found. May be NULL.\n @return >= 0 in case of success, a negative value corresponding to an\n AVERROR code in case of failure"]
    pub fn avio_open2(
        s: *mut *mut AVIOContext,
        url: *const libc::c_char,
        flags: libc::c_int,
        int_cb: *const AVIOInterruptCB,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Close the resource accessed by the AVIOContext s and free it.\n This function can only be used if s was opened by avio_open().\n\n The internal buffer is automatically flushed before closing the\n resource.\n\n @return 0 on success, an AVERROR < 0 on error.\n @see avio_closep"]
    pub fn avio_close(s: *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Close the resource accessed by the AVIOContext *s, free it\n and set the pointer pointing to it to NULL.\n This function can only be used if s was opened by avio_open().\n\n The internal buffer is automatically flushed before closing the\n resource.\n\n @return 0 on success, an AVERROR < 0 on error.\n @see avio_close"]
    pub fn avio_closep(s: *mut *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Open a write only memory stream.\n\n @param s new IO context\n @return zero if no error."]
    pub fn avio_open_dyn_buf(s: *mut *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the written size and a pointer to the buffer.\n The AVIOContext stream is left intact.\n The buffer must NOT be freed.\n No padding is added to the buffer.\n\n @param s IO context\n @param pbuffer pointer to a byte buffer\n @return the length of the byte buffer"]
    pub fn avio_get_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut u8) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the written size and a pointer to the buffer. The buffer\n must be freed with av_free().\n Padding of AV_INPUT_BUFFER_PADDING_SIZE is added to the buffer.\n\n @param s IO context\n @param pbuffer pointer to a byte buffer\n @return the length of the byte buffer"]
    pub fn avio_close_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut u8) -> libc::c_int;
}
extern "C" {
    #[doc = " Iterate through names of available protocols.\n\n @param opaque A private pointer representing current protocol.\n        It must be a pointer to NULL on first iteration and will\n        be updated by successive calls to avio_enum_protocols.\n @param output If set to 1, iterate over output protocols,\n               otherwise over input protocols.\n\n @return A static string containing the name of current protocol or NULL"]
    pub fn avio_enum_protocols(
        opaque: *mut *mut libc::c_void,
        output: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get AVClass by names of available protocols.\n\n @return A AVClass of input protocol name or NULL"]
    pub fn avio_protocol_get_class(name: *const libc::c_char) -> *const AVClass;
}
extern "C" {
    #[doc = " Pause and resume playing - only meaningful if using a network streaming\n protocol (e.g. MMS).\n\n @param h     IO context from which to call the read_pause function pointer\n @param pause 1 for pause, 0 for resume"]
    pub fn avio_pause(h: *mut AVIOContext, pause: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Seek to a given timestamp relative to some component stream.\n Only meaningful if using a network streaming protocol (e.g. MMS.).\n\n @param h IO context from which to call the seek function pointers\n @param stream_index The stream index that the timestamp is relative to.\n        If stream_index is (-1) the timestamp should be in AV_TIME_BASE\n        units from the beginning of the presentation.\n        If a stream_index >= 0 is used and the protocol does not support\n        seeking based on component streams, the call will fail.\n @param timestamp timestamp in AVStream.time_base units\n        or if there is no stream specified then in AV_TIME_BASE units.\n @param flags Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE\n        and AVSEEK_FLAG_ANY. The protocol may silently ignore\n        AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will\n        fail if used and not supported.\n @return >= 0 on success\n @see AVInputFormat::read_seek"]
    pub fn avio_seek_time(
        h: *mut AVIOContext,
        stream_index: libc::c_int,
        timestamp: i64,
        flags: libc::c_int,
    ) -> i64;
}
extern "C" {
    #[doc = " Read contents of h into print buffer, up to max_size bytes, or up to EOF.\n\n @return 0 for success (max_size bytes read or EOF reached), negative error\n code otherwise"]
    pub fn avio_read_to_bprint(
        h: *mut AVIOContext,
        pb: *mut AVBPrint,
        max_size: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Accept and allocate a client context on a server context.\n @param  s the server context\n @param  c the client context, must be unallocated\n @return   >= 0 on success or a negative value corresponding\n           to an AVERROR on failure"]
    pub fn avio_accept(s: *mut AVIOContext, c: *mut *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Perform one step of the protocol handshake to accept a new client.\n This function must be called on a client returned by avio_accept() before\n using it as a read/write context.\n It is separate from avio_accept() because it may block.\n A step of the handshake is defined by places where the application may\n decide to change the proceedings.\n For example, on a protocol with a request header and a reply header, each\n one can constitute a step because the application may use the parameters\n from the request to change parameters in the reply; or each individual\n chunk of the request can constitute a step.\n If the handshake is already finished, avio_handshake() does nothing and\n returns 0 immediately.\n\n @param  c the client context to perform the handshake on\n @return   0   on a complete and successful handshake\n           > 0 if the handshake progressed, but is not complete\n           < 0 for an AVERROR code"]
    pub fn avio_handshake(c: *mut AVIOContext) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDeviceInfoList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDeviceCapabilitiesQuery {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and read the payload of a packet and initialize its\n fields with default values.\n\n @param s    associated IO context\n @param pkt packet\n @param size desired payload size\n @return >0 (read size) if OK, AVERROR_xxx otherwise"]
    pub fn av_get_packet(s: *mut AVIOContext, pkt: *mut AVPacket, size: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Read data and append it to the current content of the AVPacket.\n If pkt->size is 0 this is identical to av_get_packet.\n Note that this uses av_grow_packet and thus involves a realloc\n which is inefficient. Thus this function should only be used\n when there is no reasonable way to know (an upper bound of)\n the final size.\n\n @param s    associated IO context\n @param pkt packet\n @param size amount of data to read\n @return >0 (read size) if OK, AVERROR_xxx otherwise, previous data\n         will not be lost even if an error occurs."]
    pub fn av_append_packet(
        s: *mut AVIOContext,
        pkt: *mut AVPacket,
        size: libc::c_int,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecTag {
    _unused: [u8; 0],
}
#[doc = " This structure contains the data a format has to probe a file."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVProbeData {
    pub filename: *const libc::c_char,
    #[doc = "< Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled with zero."]
    pub buf: *mut libc::c_uchar,
    #[doc = "< Size of buf except extra allocated bytes"]
    pub buf_size: libc::c_int,
    #[doc = "< mime_type, when known."]
    pub mime_type: *const libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVProbeData"][::std::mem::size_of::<AVProbeData>() - 32usize];
    ["Alignment of AVProbeData"][::std::mem::align_of::<AVProbeData>() - 8usize];
    ["Offset of field: AVProbeData::filename"]
        [::std::mem::offset_of!(AVProbeData, filename) - 0usize];
    ["Offset of field: AVProbeData::buf"][::std::mem::offset_of!(AVProbeData, buf) - 8usize];
    ["Offset of field: AVProbeData::buf_size"]
        [::std::mem::offset_of!(AVProbeData, buf_size) - 16usize];
    ["Offset of field: AVProbeData::mime_type"]
        [::std::mem::offset_of!(AVProbeData, mime_type) - 24usize];
};
#[doc = " @addtogroup lavf_encoding\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVOutputFormat {
    pub name: *const libc::c_char,
    #[doc = " Descriptive name for the format, meant to be more human-readable\n than name. You should use the NULL_IF_CONFIG_SMALL() macro\n to define it."]
    pub long_name: *const libc::c_char,
    pub mime_type: *const libc::c_char,
    #[doc = "< comma-separated filename extensions"]
    pub extensions: *const libc::c_char,
    #[doc = "< default audio codec"]
    pub audio_codec: AVCodecID,
    #[doc = "< default video codec"]
    pub video_codec: AVCodecID,
    #[doc = "< default subtitle codec"]
    pub subtitle_codec: AVCodecID,
    #[doc = " can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER,\n AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS,\n AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH,\n AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE"]
    pub flags: libc::c_int,
    #[doc = " List of supported codec_id-codec_tag pairs, ordered by \"better\n choice first\". The arrays are all terminated by AV_CODEC_ID_NONE."]
    pub codec_tag: *const *const AVCodecTag,
    #[doc = "< AVClass for the private context"]
    pub priv_class: *const AVClass,
    pub next: *mut AVOutputFormat,
    #[doc = " size of private data so that it can be allocated in the wrapper"]
    pub priv_data_size: libc::c_int,
    pub write_header:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    #[doc = " Write a packet. If AVFMT_ALLOW_FLUSH is set in flags,\n pkt can be NULL in order to flush data buffered in the muxer.\n When flushing, return 0 if there still is more data to flush,\n or 1 if everything was flushed and there is no more buffered\n data."]
    pub write_packet: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext, pkt: *mut AVPacket) -> libc::c_int,
    >,
    pub write_trailer:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    #[doc = " A format-specific function for interleavement.\n If unset, packets will be interleaved by dts."]
    pub interleave_packet: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            out: *mut AVPacket,
            in_: *mut AVPacket,
            flush: libc::c_int,
        ) -> libc::c_int,
    >,
    #[doc = " Test if the given codec can be stored in this container.\n\n @return 1 if the codec is supported, 0 if it is not.\n         A negative number if unknown.\n         MKTAG('A', 'P', 'I', 'C') if the codec is only supported as AV_DISPOSITION_ATTACHED_PIC"]
    pub query_codec: ::std::option::Option<
        unsafe extern "C" fn(id: AVCodecID, std_compliance: libc::c_int) -> libc::c_int,
    >,
    pub get_output_timestamp: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream: libc::c_int,
            dts: *mut i64,
            wall: *mut i64,
        ),
    >,
    #[doc = " Allows sending messages from application to device."]
    pub control_message: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            type_: libc::c_int,
            data: *mut libc::c_void,
            data_size: usize,
        ) -> libc::c_int,
    >,
    #[doc = " Write an uncoded AVFrame.\n\n See av_write_uncoded_frame() for details.\n\n The library will free *frame afterwards, but the muxer can prevent it\n by setting the pointer to NULL."]
    pub write_uncoded_frame: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            stream_index: libc::c_int,
            frame: *mut *mut AVFrame,
            flags: libc::c_uint,
        ) -> libc::c_int,
    >,
    #[doc = " Returns device list with it properties.\n @see avdevice_list_devices() for more details."]
    pub get_device_list: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            device_list: *mut AVDeviceInfoList,
        ) -> libc::c_int,
    >,
    #[doc = " Initialize device capabilities submodule.\n @see avdevice_capabilities_create() for more details."]
    pub create_device_capabilities: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            caps: *mut AVDeviceCapabilitiesQuery,
        ) -> libc::c_int,
    >,
    #[doc = " Free device capabilities submodule.\n @see avdevice_capabilities_free() for more details."]
    pub free_device_capabilities: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            caps: *mut AVDeviceCapabilitiesQuery,
        ) -> libc::c_int,
    >,
    #[doc = "< default data codec"]
    pub data_codec: AVCodecID,
    #[doc = " Initialize format. May allocate data here, and set any AVFormatContext or\n AVStream parameters that need to be set before packets are sent.\n This method must not write output.\n\n Return 0 if streams were fully configured, 1 if not, negative AVERROR on failure\n\n Any allocations made here must be freed in deinit()."]
    pub init:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    #[doc = " Deinitialize format. If present, this is called whenever the muxer is being\n destroyed, regardless of whether or not the header has been written.\n\n If a trailer is being written, this is called after write_trailer().\n\n This is called if init() fails as well."]
    pub deinit: ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext)>,
    #[doc = " Set up any necessary bitstream filtering and extract any extra data needed\n for the global header.\n Return 0 if more packets from this stream must be checked; 1 if not."]
    pub check_bitstream: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext, pkt: *const AVPacket) -> libc::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVOutputFormat"][::std::mem::size_of::<AVOutputFormat>() - 200usize];
    ["Alignment of AVOutputFormat"][::std::mem::align_of::<AVOutputFormat>() - 8usize];
    ["Offset of field: AVOutputFormat::name"]
        [::std::mem::offset_of!(AVOutputFormat, name) - 0usize];
    ["Offset of field: AVOutputFormat::long_name"]
        [::std::mem::offset_of!(AVOutputFormat, long_name) - 8usize];
    ["Offset of field: AVOutputFormat::mime_type"]
        [::std::mem::offset_of!(AVOutputFormat, mime_type) - 16usize];
    ["Offset of field: AVOutputFormat::extensions"]
        [::std::mem::offset_of!(AVOutputFormat, extensions) - 24usize];
    ["Offset of field: AVOutputFormat::audio_codec"]
        [::std::mem::offset_of!(AVOutputFormat, audio_codec) - 32usize];
    ["Offset of field: AVOutputFormat::video_codec"]
        [::std::mem::offset_of!(AVOutputFormat, video_codec) - 36usize];
    ["Offset of field: AVOutputFormat::subtitle_codec"]
        [::std::mem::offset_of!(AVOutputFormat, subtitle_codec) - 40usize];
    ["Offset of field: AVOutputFormat::flags"]
        [::std::mem::offset_of!(AVOutputFormat, flags) - 44usize];
    ["Offset of field: AVOutputFormat::codec_tag"]
        [::std::mem::offset_of!(AVOutputFormat, codec_tag) - 48usize];
    ["Offset of field: AVOutputFormat::priv_class"]
        [::std::mem::offset_of!(AVOutputFormat, priv_class) - 56usize];
    ["Offset of field: AVOutputFormat::next"]
        [::std::mem::offset_of!(AVOutputFormat, next) - 64usize];
    ["Offset of field: AVOutputFormat::priv_data_size"]
        [::std::mem::offset_of!(AVOutputFormat, priv_data_size) - 72usize];
    ["Offset of field: AVOutputFormat::write_header"]
        [::std::mem::offset_of!(AVOutputFormat, write_header) - 80usize];
    ["Offset of field: AVOutputFormat::write_packet"]
        [::std::mem::offset_of!(AVOutputFormat, write_packet) - 88usize];
    ["Offset of field: AVOutputFormat::write_trailer"]
        [::std::mem::offset_of!(AVOutputFormat, write_trailer) - 96usize];
    ["Offset of field: AVOutputFormat::interleave_packet"]
        [::std::mem::offset_of!(AVOutputFormat, interleave_packet) - 104usize];
    ["Offset of field: AVOutputFormat::query_codec"]
        [::std::mem::offset_of!(AVOutputFormat, query_codec) - 112usize];
    ["Offset of field: AVOutputFormat::get_output_timestamp"]
        [::std::mem::offset_of!(AVOutputFormat, get_output_timestamp) - 120usize];
    ["Offset of field: AVOutputFormat::control_message"]
        [::std::mem::offset_of!(AVOutputFormat, control_message) - 128usize];
    ["Offset of field: AVOutputFormat::write_uncoded_frame"]
        [::std::mem::offset_of!(AVOutputFormat, write_uncoded_frame) - 136usize];
    ["Offset of field: AVOutputFormat::get_device_list"]
        [::std::mem::offset_of!(AVOutputFormat, get_device_list) - 144usize];
    ["Offset of field: AVOutputFormat::create_device_capabilities"]
        [::std::mem::offset_of!(AVOutputFormat, create_device_capabilities) - 152usize];
    ["Offset of field: AVOutputFormat::free_device_capabilities"]
        [::std::mem::offset_of!(AVOutputFormat, free_device_capabilities) - 160usize];
    ["Offset of field: AVOutputFormat::data_codec"]
        [::std::mem::offset_of!(AVOutputFormat, data_codec) - 168usize];
    ["Offset of field: AVOutputFormat::init"]
        [::std::mem::offset_of!(AVOutputFormat, init) - 176usize];
    ["Offset of field: AVOutputFormat::deinit"]
        [::std::mem::offset_of!(AVOutputFormat, deinit) - 184usize];
    ["Offset of field: AVOutputFormat::check_bitstream"]
        [::std::mem::offset_of!(AVOutputFormat, check_bitstream) - 192usize];
};
#[doc = " @addtogroup lavf_decoding\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVInputFormat {
    #[doc = " A comma separated list of short names for the format. New names\n may be appended with a minor bump."]
    pub name: *const libc::c_char,
    #[doc = " Descriptive name for the format, meant to be more human-readable\n than name. You should use the NULL_IF_CONFIG_SMALL() macro\n to define it."]
    pub long_name: *const libc::c_char,
    #[doc = " Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS,\n AVFMT_NOTIMESTAMPS, AVFMT_GENERIC_INDEX, AVFMT_TS_DISCONT, AVFMT_NOBINSEARCH,\n AVFMT_NOGENSEARCH, AVFMT_NO_BYTE_SEEK, AVFMT_SEEK_TO_PTS."]
    pub flags: libc::c_int,
    #[doc = " If extensions are defined, then no probe is done. You should\n usually not use extension format guessing because it is not\n reliable enough"]
    pub extensions: *const libc::c_char,
    pub codec_tag: *const *const AVCodecTag,
    #[doc = "< AVClass for the private context"]
    pub priv_class: *const AVClass,
    #[doc = " Comma-separated list of mime types.\n It is used check for matching mime types while probing.\n @see av_probe_input_format2"]
    pub mime_type: *const libc::c_char,
    pub next: *mut AVInputFormat,
    #[doc = " Raw demuxers store their codec ID here."]
    pub raw_codec_id: libc::c_int,
    #[doc = " Size of private data so that it can be allocated in the wrapper."]
    pub priv_data_size: libc::c_int,
    #[doc = " Tell if a given file has a chance of being parsed as this format.\n The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes\n big so you do not have to check for that unless you need more."]
    pub read_probe:
        ::std::option::Option<unsafe extern "C" fn(arg1: *const AVProbeData) -> libc::c_int>,
    #[doc = " Read the format header and initialize the AVFormatContext\n structure. Return 0 if OK. 'avformat_new_stream' should be\n called to create new streams."]
    pub read_header:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    #[doc = " Read one packet and put it in 'pkt'. pts and flags are also\n set. 'avformat_new_stream' can be called only if the flag\n AVFMTCTX_NOHEADER is used and only in the calling thread (not in a\n background thread).\n @return 0 on success, < 0 on error.\n         Upon returning an error, pkt must be unreferenced by the caller."]
    pub read_packet: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext, pkt: *mut AVPacket) -> libc::c_int,
    >,
    #[doc = " Close the stream. The AVFormatContext and AVStreams are not\n freed by this function"]
    pub read_close:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    #[doc = " Seek to a given timestamp relative to the frames in\n stream component stream_index.\n @param stream_index Must not be -1.\n @param flags Selects which direction should be preferred if no exact\n              match is available.\n @return >= 0 on success (but not necessarily the new offset)"]
    pub read_seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            stream_index: libc::c_int,
            timestamp: i64,
            flags: libc::c_int,
        ) -> libc::c_int,
    >,
    #[doc = " Get the next timestamp in stream[stream_index].time_base units.\n @return the timestamp or AV_NOPTS_VALUE if an error occurred"]
    pub read_timestamp: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream_index: libc::c_int,
            pos: *mut i64,
            pos_limit: i64,
        ) -> i64,
    >,
    #[doc = " Start/resume playing - only meaningful if using a network-based format\n (RTSP)."]
    pub read_play:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    #[doc = " Pause playing - only meaningful if using a network-based format\n (RTSP)."]
    pub read_pause:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    #[doc = " Seek to timestamp ts.\n Seeking will be done so that the point from which all active streams\n can be presented successfully will be closest to ts and within min/max_ts.\n Active streams are all streams that have AVStream.discard < AVDISCARD_ALL."]
    pub read_seek2: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream_index: libc::c_int,
            min_ts: i64,
            ts: i64,
            max_ts: i64,
            flags: libc::c_int,
        ) -> libc::c_int,
    >,
    #[doc = " Returns device list with it properties.\n @see avdevice_list_devices() for more details."]
    pub get_device_list: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            device_list: *mut AVDeviceInfoList,
        ) -> libc::c_int,
    >,
    #[doc = " Initialize device capabilities submodule.\n @see avdevice_capabilities_create() for more details."]
    pub create_device_capabilities: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            caps: *mut AVDeviceCapabilitiesQuery,
        ) -> libc::c_int,
    >,
    #[doc = " Free device capabilities submodule.\n @see avdevice_capabilities_free() for more details."]
    pub free_device_capabilities: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            caps: *mut AVDeviceCapabilitiesQuery,
        ) -> libc::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVInputFormat"][::std::mem::size_of::<AVInputFormat>() - 168usize];
    ["Alignment of AVInputFormat"][::std::mem::align_of::<AVInputFormat>() - 8usize];
    ["Offset of field: AVInputFormat::name"][::std::mem::offset_of!(AVInputFormat, name) - 0usize];
    ["Offset of field: AVInputFormat::long_name"]
        [::std::mem::offset_of!(AVInputFormat, long_name) - 8usize];
    ["Offset of field: AVInputFormat::flags"]
        [::std::mem::offset_of!(AVInputFormat, flags) - 16usize];
    ["Offset of field: AVInputFormat::extensions"]
        [::std::mem::offset_of!(AVInputFormat, extensions) - 24usize];
    ["Offset of field: AVInputFormat::codec_tag"]
        [::std::mem::offset_of!(AVInputFormat, codec_tag) - 32usize];
    ["Offset of field: AVInputFormat::priv_class"]
        [::std::mem::offset_of!(AVInputFormat, priv_class) - 40usize];
    ["Offset of field: AVInputFormat::mime_type"]
        [::std::mem::offset_of!(AVInputFormat, mime_type) - 48usize];
    ["Offset of field: AVInputFormat::next"][::std::mem::offset_of!(AVInputFormat, next) - 56usize];
    ["Offset of field: AVInputFormat::raw_codec_id"]
        [::std::mem::offset_of!(AVInputFormat, raw_codec_id) - 64usize];
    ["Offset of field: AVInputFormat::priv_data_size"]
        [::std::mem::offset_of!(AVInputFormat, priv_data_size) - 68usize];
    ["Offset of field: AVInputFormat::read_probe"]
        [::std::mem::offset_of!(AVInputFormat, read_probe) - 72usize];
    ["Offset of field: AVInputFormat::read_header"]
        [::std::mem::offset_of!(AVInputFormat, read_header) - 80usize];
    ["Offset of field: AVInputFormat::read_packet"]
        [::std::mem::offset_of!(AVInputFormat, read_packet) - 88usize];
    ["Offset of field: AVInputFormat::read_close"]
        [::std::mem::offset_of!(AVInputFormat, read_close) - 96usize];
    ["Offset of field: AVInputFormat::read_seek"]
        [::std::mem::offset_of!(AVInputFormat, read_seek) - 104usize];
    ["Offset of field: AVInputFormat::read_timestamp"]
        [::std::mem::offset_of!(AVInputFormat, read_timestamp) - 112usize];
    ["Offset of field: AVInputFormat::read_play"]
        [::std::mem::offset_of!(AVInputFormat, read_play) - 120usize];
    ["Offset of field: AVInputFormat::read_pause"]
        [::std::mem::offset_of!(AVInputFormat, read_pause) - 128usize];
    ["Offset of field: AVInputFormat::read_seek2"]
        [::std::mem::offset_of!(AVInputFormat, read_seek2) - 136usize];
    ["Offset of field: AVInputFormat::get_device_list"]
        [::std::mem::offset_of!(AVInputFormat, get_device_list) - 144usize];
    ["Offset of field: AVInputFormat::create_device_capabilities"]
        [::std::mem::offset_of!(AVInputFormat, create_device_capabilities) - 152usize];
    ["Offset of field: AVInputFormat::free_device_capabilities"]
        [::std::mem::offset_of!(AVInputFormat, free_device_capabilities) - 160usize];
};
#[repr(u32)]
#[doc = " @}"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVStreamParseType {
    AVSTREAM_PARSE_NONE = 0,
    #[doc = "< full parsing and repack"]
    AVSTREAM_PARSE_FULL = 1,
    #[doc = "< Only parse headers, do not repack."]
    AVSTREAM_PARSE_HEADERS = 2,
    #[doc = "< full parsing and interpolation of timestamps for frames not starting on a packet boundary"]
    AVSTREAM_PARSE_TIMESTAMPS = 3,
    #[doc = "< full parsing and repack of the first frame only, only implemented for H.264 currently"]
    AVSTREAM_PARSE_FULL_ONCE = 4,
    #[doc = "< full parsing and repack with timestamp and position generation by parser for raw\nthis assumes that each packet in the file contains no demuxer level headers and\njust codec level data, otherwise position generation would fail"]
    AVSTREAM_PARSE_FULL_RAW = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVIndexEntry {
    pub pos: i64,
    #[doc = "<\n Timestamp in AVStream.time_base units, preferably the time from which on correctly decoded frames are available\n when seeking to this entry. That means preferable PTS on keyframe based formats.\n But demuxers can choose to store a different timestamp, if it is more convenient for the implementation or nothing better\n is known"]
    pub timestamp: i64,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Minimum distance between this and the previous keyframe, used to avoid unneeded searching."]
    pub min_distance: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVIndexEntry"][::std::mem::size_of::<AVIndexEntry>() - 24usize];
    ["Alignment of AVIndexEntry"][::std::mem::align_of::<AVIndexEntry>() - 8usize];
    ["Offset of field: AVIndexEntry::pos"][::std::mem::offset_of!(AVIndexEntry, pos) - 0usize];
    ["Offset of field: AVIndexEntry::timestamp"]
        [::std::mem::offset_of!(AVIndexEntry, timestamp) - 8usize];
    ["Offset of field: AVIndexEntry::min_distance"]
        [::std::mem::offset_of!(AVIndexEntry, min_distance) - 20usize];
};
impl AVIndexEntry {
    #[inline]
    pub fn flags(&self) -> libc::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: libc::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> libc::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: libc::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: libc::c_int,
        size: libc::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let size: u32 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVStreamInternal {
    _unused: [u8; 0],
}
#[doc = " Stream structure.\n New fields can be added to the end with minor version bumps.\n Removal, reordering and changes to existing fields require a major\n version bump.\n sizeof(AVStream) must not be used outside libav*."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVStream {
    #[doc = "< stream index in AVFormatContext"]
    pub index: libc::c_int,
    #[doc = " Format-specific stream ID.\n decoding: set by libavformat\n encoding: set by the user, replaced by libavformat if left unset"]
    pub id: libc::c_int,
    #[doc = " @deprecated use the codecpar struct instead"]
    pub codec: *mut AVCodecContext,
    pub priv_data: *mut libc::c_void,
    #[doc = " This is the fundamental unit of time (in seconds) in terms\n of which frame timestamps are represented.\n\n decoding: set by libavformat\n encoding: May be set by the caller before avformat_write_header() to\n           provide a hint to the muxer about the desired timebase. In\n           avformat_write_header(), the muxer will overwrite this field\n           with the timebase that will actually be used for the timestamps\n           written into the file (which may or may not be related to the\n           user-provided one, depending on the format)."]
    pub time_base: AVRational,
    #[doc = " Decoding: pts of the first frame of the stream in presentation order, in stream time base.\n Only set this if you are absolutely 100% sure that the value you set\n it to really is the pts of the first frame.\n This may be undefined (AV_NOPTS_VALUE).\n @note The ASF header does NOT contain a correct start_time the ASF\n demuxer must NOT set this."]
    pub start_time: i64,
    #[doc = " Decoding: duration of the stream, in stream time base.\n If a source file does not specify a duration, but does specify\n a bitrate, this value will be estimated from bitrate and file size.\n\n Encoding: May be set by the caller before avformat_write_header() to\n provide a hint to the muxer about the estimated duration."]
    pub duration: i64,
    #[doc = "< number of frames in this stream if known or 0"]
    pub nb_frames: i64,
    #[doc = "< AV_DISPOSITION_* bit field"]
    pub disposition: libc::c_int,
    #[doc = "< Selects which packets can be discarded at will and do not need to be demuxed."]
    pub discard: AVDiscard,
    #[doc = " sample aspect ratio (0 if unknown)\n - encoding: Set by user.\n - decoding: Set by libavformat."]
    pub sample_aspect_ratio: AVRational,
    pub metadata: *mut AVDictionary,
    #[doc = " Average framerate\n\n - demuxing: May be set by libavformat when creating the stream or in\n             avformat_find_stream_info().\n - muxing: May be set by the caller before avformat_write_header()."]
    pub avg_frame_rate: AVRational,
    #[doc = " For streams with AV_DISPOSITION_ATTACHED_PIC disposition, this packet\n will contain the attached picture.\n\n decoding: set by libavformat, must not be modified by the caller.\n encoding: unused"]
    pub attached_pic: AVPacket,
    #[doc = " An array of side data that applies to the whole stream (i.e. the\n container does not allow it to change between packets).\n\n There may be no overlap between the side data in this array and side data\n in the packets. I.e. a given side data is either exported by the muxer\n (demuxing) / set by the caller (muxing) in this array, then it never\n appears in the packets, or the side data is exported / sent through\n the packets (always in the first packet where the value becomes known or\n changes), then it does not appear in this array.\n\n - demuxing: Set by libavformat when the stream is created.\n - muxing: May be set by the caller before avformat_write_header().\n\n Freed by libavformat in avformat_free_context().\n\n @see av_format_inject_global_side_data()"]
    pub side_data: *mut AVPacketSideData,
    #[doc = " The number of elements in the AVStream.side_data array."]
    pub nb_side_data: libc::c_int,
    #[doc = " Flags indicating events happening on the stream, a combination of\n AVSTREAM_EVENT_FLAG_*.\n\n - demuxing: may be set by the demuxer in avformat_open_input(),\n   avformat_find_stream_info() and av_read_frame(). Flags must be cleared\n   by the user once the event has been handled.\n - muxing: may be set by the user after avformat_write_header(). to\n   indicate a user-triggered event.  The muxer will clear the flags for\n   events it has handled in av_[interleaved]_write_frame()."]
    pub event_flags: libc::c_int,
    #[doc = " Real base framerate of the stream.\n This is the lowest framerate with which all timestamps can be\n represented accurately (it is the least common multiple of all\n framerates in the stream). Note, this value is just a guess!\n For example, if the time base is 1/90000 and all frames have either\n approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1."]
    pub r_frame_rate: AVRational,
    #[doc = " String containing pairs of key and values describing recommended encoder configuration.\n Pairs are separated by ','.\n Keys are separated from values by '='.\n\n @deprecated unused"]
    pub recommended_encoder_configuration: *mut libc::c_char,
    #[doc = " Codec parameters associated with this stream. Allocated and freed by\n libavformat in avformat_new_stream() and avformat_free_context()\n respectively.\n\n - demuxing: filled by libavformat on stream creation or in\n             avformat_find_stream_info()\n - muxing: filled by the caller before avformat_write_header()"]
    pub codecpar: *mut AVCodecParameters,
    pub unused: *mut libc::c_void,
    #[doc = "< number of bits in pts (used for wrapping control)"]
    pub pts_wrap_bits: libc::c_int,
    #[doc = " Timestamp corresponding to the last dts sync point.\n\n Initialized when AVCodecParserContext.dts_sync_point >= 0 and\n a DTS is received from the underlying container. Otherwise set to\n AV_NOPTS_VALUE by default."]
    pub first_dts: i64,
    pub cur_dts: i64,
    pub last_IP_pts: i64,
    pub last_IP_duration: libc::c_int,
    #[doc = " Number of packets to buffer for codec probing"]
    pub probe_packets: libc::c_int,
    #[doc = " Number of frames that have been demuxed during avformat_find_stream_info()"]
    pub codec_info_nb_frames: libc::c_int,
    pub need_parsing: AVStreamParseType,
    pub parser: *mut AVCodecParserContext,
    pub unused7: *mut libc::c_void,
    pub unused6: AVProbeData,
    pub unused5: [i64; 17usize],
    #[doc = "< Only used if the format does not\nsupport seeking natively."]
    pub index_entries: *mut AVIndexEntry,
    pub nb_index_entries: libc::c_int,
    pub index_entries_allocated_size: libc::c_uint,
    #[doc = " Stream Identifier\n This is the MPEG-TS stream identifier +1\n 0 means unknown"]
    pub stream_identifier: libc::c_int,
    pub unused8: libc::c_int,
    pub unused9: libc::c_int,
    pub unused10: libc::c_int,
    #[doc = " An opaque field for libavformat internal usage.\n Must not be accessed in any way by callers."]
    pub internal: *mut AVStreamInternal,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVStream"][::std::mem::size_of::<AVStream>() - 496usize];
    ["Alignment of AVStream"][::std::mem::align_of::<AVStream>() - 8usize];
    ["Offset of field: AVStream::index"][::std::mem::offset_of!(AVStream, index) - 0usize];
    ["Offset of field: AVStream::id"][::std::mem::offset_of!(AVStream, id) - 4usize];
    ["Offset of field: AVStream::codec"][::std::mem::offset_of!(AVStream, codec) - 8usize];
    ["Offset of field: AVStream::priv_data"][::std::mem::offset_of!(AVStream, priv_data) - 16usize];
    ["Offset of field: AVStream::time_base"][::std::mem::offset_of!(AVStream, time_base) - 24usize];
    ["Offset of field: AVStream::start_time"]
        [::std::mem::offset_of!(AVStream, start_time) - 32usize];
    ["Offset of field: AVStream::duration"][::std::mem::offset_of!(AVStream, duration) - 40usize];
    ["Offset of field: AVStream::nb_frames"][::std::mem::offset_of!(AVStream, nb_frames) - 48usize];
    ["Offset of field: AVStream::disposition"]
        [::std::mem::offset_of!(AVStream, disposition) - 56usize];
    ["Offset of field: AVStream::discard"][::std::mem::offset_of!(AVStream, discard) - 60usize];
    ["Offset of field: AVStream::sample_aspect_ratio"]
        [::std::mem::offset_of!(AVStream, sample_aspect_ratio) - 64usize];
    ["Offset of field: AVStream::metadata"][::std::mem::offset_of!(AVStream, metadata) - 72usize];
    ["Offset of field: AVStream::avg_frame_rate"]
        [::std::mem::offset_of!(AVStream, avg_frame_rate) - 80usize];
    ["Offset of field: AVStream::attached_pic"]
        [::std::mem::offset_of!(AVStream, attached_pic) - 88usize];
    ["Offset of field: AVStream::side_data"]
        [::std::mem::offset_of!(AVStream, side_data) - 176usize];
    ["Offset of field: AVStream::nb_side_data"]
        [::std::mem::offset_of!(AVStream, nb_side_data) - 184usize];
    ["Offset of field: AVStream::event_flags"]
        [::std::mem::offset_of!(AVStream, event_flags) - 188usize];
    ["Offset of field: AVStream::r_frame_rate"]
        [::std::mem::offset_of!(AVStream, r_frame_rate) - 192usize];
    ["Offset of field: AVStream::recommended_encoder_configuration"]
        [::std::mem::offset_of!(AVStream, recommended_encoder_configuration) - 200usize];
    ["Offset of field: AVStream::codecpar"][::std::mem::offset_of!(AVStream, codecpar) - 208usize];
    ["Offset of field: AVStream::unused"][::std::mem::offset_of!(AVStream, unused) - 216usize];
    ["Offset of field: AVStream::pts_wrap_bits"]
        [::std::mem::offset_of!(AVStream, pts_wrap_bits) - 224usize];
    ["Offset of field: AVStream::first_dts"]
        [::std::mem::offset_of!(AVStream, first_dts) - 232usize];
    ["Offset of field: AVStream::cur_dts"][::std::mem::offset_of!(AVStream, cur_dts) - 240usize];
    ["Offset of field: AVStream::last_IP_pts"]
        [::std::mem::offset_of!(AVStream, last_IP_pts) - 248usize];
    ["Offset of field: AVStream::last_IP_duration"]
        [::std::mem::offset_of!(AVStream, last_IP_duration) - 256usize];
    ["Offset of field: AVStream::probe_packets"]
        [::std::mem::offset_of!(AVStream, probe_packets) - 260usize];
    ["Offset of field: AVStream::codec_info_nb_frames"]
        [::std::mem::offset_of!(AVStream, codec_info_nb_frames) - 264usize];
    ["Offset of field: AVStream::need_parsing"]
        [::std::mem::offset_of!(AVStream, need_parsing) - 268usize];
    ["Offset of field: AVStream::parser"][::std::mem::offset_of!(AVStream, parser) - 272usize];
    ["Offset of field: AVStream::unused7"][::std::mem::offset_of!(AVStream, unused7) - 280usize];
    ["Offset of field: AVStream::unused6"][::std::mem::offset_of!(AVStream, unused6) - 288usize];
    ["Offset of field: AVStream::unused5"][::std::mem::offset_of!(AVStream, unused5) - 320usize];
    ["Offset of field: AVStream::index_entries"]
        [::std::mem::offset_of!(AVStream, index_entries) - 456usize];
    ["Offset of field: AVStream::nb_index_entries"]
        [::std::mem::offset_of!(AVStream, nb_index_entries) - 464usize];
    ["Offset of field: AVStream::index_entries_allocated_size"]
        [::std::mem::offset_of!(AVStream, index_entries_allocated_size) - 468usize];
    ["Offset of field: AVStream::stream_identifier"]
        [::std::mem::offset_of!(AVStream, stream_identifier) - 472usize];
    ["Offset of field: AVStream::unused8"][::std::mem::offset_of!(AVStream, unused8) - 476usize];
    ["Offset of field: AVStream::unused9"][::std::mem::offset_of!(AVStream, unused9) - 480usize];
    ["Offset of field: AVStream::unused10"][::std::mem::offset_of!(AVStream, unused10) - 484usize];
    ["Offset of field: AVStream::internal"][::std::mem::offset_of!(AVStream, internal) - 488usize];
};
extern "C" {
    #[doc = " Accessors for some AVStream fields. These used to be provided for ABI\n compatibility, and do not need to be used anymore."]
    pub fn av_stream_get_r_frame_rate(s: *const AVStream) -> AVRational;
}
extern "C" {
    pub fn av_stream_set_r_frame_rate(s: *mut AVStream, r: AVRational);
}
extern "C" {
    pub fn av_stream_get_recommended_encoder_configuration(s: *const AVStream)
        -> *mut libc::c_char;
}
extern "C" {
    pub fn av_stream_set_recommended_encoder_configuration(
        s: *mut AVStream,
        configuration: *mut libc::c_char,
    );
}
extern "C" {
    pub fn av_stream_get_parser(s: *const AVStream) -> *mut AVCodecParserContext;
}
extern "C" {
    #[doc = " Returns the pts of the last muxed packet + its duration\n\n the retuned value is undefined when used with a demuxer."]
    pub fn av_stream_get_end_pts(st: *const AVStream) -> i64;
}
#[doc = " New fields can be added to the end with minor version bumps.\n Removal, reordering and changes to existing fields require a major\n version bump.\n sizeof(AVProgram) must not be used outside libav*."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVProgram {
    pub id: libc::c_int,
    pub flags: libc::c_int,
    #[doc = "< selects which program to discard and which to feed to the caller"]
    pub discard: AVDiscard,
    pub stream_index: *mut libc::c_uint,
    pub nb_stream_indexes: libc::c_uint,
    pub metadata: *mut AVDictionary,
    pub program_num: libc::c_int,
    pub pmt_pid: libc::c_int,
    pub pcr_pid: libc::c_int,
    pub pmt_version: libc::c_int,
    #[doc = " All fields below this line are not part of the public API. They\n may not be used outside of libavformat and can be changed and\n removed at will.\n New public fields should be added right above.\n"]
    pub start_time: i64,
    pub end_time: i64,
    #[doc = "< reference dts for wrap detection"]
    pub pts_wrap_reference: i64,
    #[doc = "< behavior on wrap detection"]
    pub pts_wrap_behavior: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVProgram"][::std::mem::size_of::<AVProgram>() - 88usize];
    ["Alignment of AVProgram"][::std::mem::align_of::<AVProgram>() - 8usize];
    ["Offset of field: AVProgram::id"][::std::mem::offset_of!(AVProgram, id) - 0usize];
    ["Offset of field: AVProgram::flags"][::std::mem::offset_of!(AVProgram, flags) - 4usize];
    ["Offset of field: AVProgram::discard"][::std::mem::offset_of!(AVProgram, discard) - 8usize];
    ["Offset of field: AVProgram::stream_index"]
        [::std::mem::offset_of!(AVProgram, stream_index) - 16usize];
    ["Offset of field: AVProgram::nb_stream_indexes"]
        [::std::mem::offset_of!(AVProgram, nb_stream_indexes) - 24usize];
    ["Offset of field: AVProgram::metadata"][::std::mem::offset_of!(AVProgram, metadata) - 32usize];
    ["Offset of field: AVProgram::program_num"]
        [::std::mem::offset_of!(AVProgram, program_num) - 40usize];
    ["Offset of field: AVProgram::pmt_pid"][::std::mem::offset_of!(AVProgram, pmt_pid) - 44usize];
    ["Offset of field: AVProgram::pcr_pid"][::std::mem::offset_of!(AVProgram, pcr_pid) - 48usize];
    ["Offset of field: AVProgram::pmt_version"]
        [::std::mem::offset_of!(AVProgram, pmt_version) - 52usize];
    ["Offset of field: AVProgram::start_time"]
        [::std::mem::offset_of!(AVProgram, start_time) - 56usize];
    ["Offset of field: AVProgram::end_time"][::std::mem::offset_of!(AVProgram, end_time) - 64usize];
    ["Offset of field: AVProgram::pts_wrap_reference"]
        [::std::mem::offset_of!(AVProgram, pts_wrap_reference) - 72usize];
    ["Offset of field: AVProgram::pts_wrap_behavior"]
        [::std::mem::offset_of!(AVProgram, pts_wrap_behavior) - 80usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVChapter {
    #[doc = "< unique ID to identify the chapter"]
    pub id: libc::c_int,
    #[doc = "< time base in which the start/end timestamps are specified"]
    pub time_base: AVRational,
    #[doc = "< chapter start/end time in time_base units"]
    pub start: i64,
    #[doc = "< chapter start/end time in time_base units"]
    pub end: i64,
    pub metadata: *mut AVDictionary,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVChapter"][::std::mem::size_of::<AVChapter>() - 40usize];
    ["Alignment of AVChapter"][::std::mem::align_of::<AVChapter>() - 8usize];
    ["Offset of field: AVChapter::id"][::std::mem::offset_of!(AVChapter, id) - 0usize];
    ["Offset of field: AVChapter::time_base"]
        [::std::mem::offset_of!(AVChapter, time_base) - 4usize];
    ["Offset of field: AVChapter::start"][::std::mem::offset_of!(AVChapter, start) - 16usize];
    ["Offset of field: AVChapter::end"][::std::mem::offset_of!(AVChapter, end) - 24usize];
    ["Offset of field: AVChapter::metadata"][::std::mem::offset_of!(AVChapter, metadata) - 32usize];
};
#[doc = " Callback used by devices to communicate with application."]
pub type av_format_control_message = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut AVFormatContext,
        type_: libc::c_int,
        data: *mut libc::c_void,
        data_size: usize,
    ) -> libc::c_int,
>;
pub type AVOpenCallback = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut AVFormatContext,
        pb: *mut *mut AVIOContext,
        url: *const libc::c_char,
        flags: libc::c_int,
        int_cb: *const AVIOInterruptCB,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int,
>;
#[repr(u32)]
#[doc = " The duration of a video can be estimated through various ways, and this enum can be used\n to know how the duration was estimated."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVDurationEstimationMethod {
    #[doc = "< Duration accurately estimated from PTSes"]
    AVFMT_DURATION_FROM_PTS = 0,
    #[doc = "< Duration estimated from a stream with a known duration"]
    AVFMT_DURATION_FROM_STREAM = 1,
    #[doc = "< Duration estimated from bitrate (less accurate)"]
    AVFMT_DURATION_FROM_BITRATE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFormatInternal {
    _unused: [u8; 0],
}
#[doc = " Format I/O context.\n New fields can be added to the end with minor version bumps.\n Removal, reordering and changes to existing fields require a major\n version bump.\n sizeof(AVFormatContext) must not be used outside libav*, use\n avformat_alloc_context() to create an AVFormatContext.\n\n Fields can be accessed through AVOptions (av_opt*),\n the name string used matches the associated command line parameter name and\n can be found in libavformat/options_table.h.\n The AVOption/command line parameter names differ in some cases from the C\n structure field names for historic reasons or brevity."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFormatContext {
    #[doc = " A class for logging and @ref avoptions. Set by avformat_alloc_context().\n Exports (de)muxer private options if they exist."]
    pub av_class: *const AVClass,
    #[doc = " The input container format.\n\n Demuxing only, set by avformat_open_input()."]
    pub iformat: *mut AVInputFormat,
    #[doc = " The output container format.\n\n Muxing only, must be set by the caller before avformat_write_header()."]
    pub oformat: *mut AVOutputFormat,
    #[doc = " Format private data. This is an AVOptions-enabled struct\n if and only if iformat/oformat.priv_class is not NULL.\n\n - muxing: set by avformat_write_header()\n - demuxing: set by avformat_open_input()"]
    pub priv_data: *mut libc::c_void,
    #[doc = " I/O context.\n\n - demuxing: either set by the user before avformat_open_input() (then\n             the user must close it manually) or set by avformat_open_input().\n - muxing: set by the user before avformat_write_header(). The caller must\n           take care of closing / freeing the IO context.\n\n Do NOT set this field if AVFMT_NOFILE flag is set in\n iformat/oformat.flags. In such a case, the (de)muxer will handle\n I/O in some other way and this field will be NULL."]
    pub pb: *mut AVIOContext,
    #[doc = " Flags signalling stream properties. A combination of AVFMTCTX_*.\n Set by libavformat."]
    pub ctx_flags: libc::c_int,
    #[doc = " Number of elements in AVFormatContext.streams.\n\n Set by avformat_new_stream(), must not be modified by any other code."]
    pub nb_streams: libc::c_uint,
    #[doc = " A list of all streams in the file. New streams are created with\n avformat_new_stream().\n\n - demuxing: streams are created by libavformat in avformat_open_input().\n             If AVFMTCTX_NOHEADER is set in ctx_flags, then new streams may also\n             appear in av_read_frame().\n - muxing: streams are created by the user before avformat_write_header().\n\n Freed by libavformat in avformat_free_context()."]
    pub streams: *mut *mut AVStream,
    #[doc = " input or output filename\n\n - demuxing: set by avformat_open_input()\n - muxing: may be set by the caller before avformat_write_header()\n\n @deprecated Use url instead."]
    pub filename: [libc::c_char; 1024usize],
    #[doc = " input or output URL. Unlike the old filename field, this field has no\n length restriction.\n\n - demuxing: set by avformat_open_input(), initialized to an empty\n             string if url parameter was NULL in avformat_open_input().\n - muxing: may be set by the caller before calling avformat_write_header()\n           (or avformat_init_output() if that is called first) to a string\n           which is freeable by av_free(). Set to an empty string if it\n           was NULL in avformat_init_output().\n\n Freed by libavformat in avformat_free_context()."]
    pub url: *mut libc::c_char,
    #[doc = " Position of the first frame of the component, in\n AV_TIME_BASE fractional seconds. NEVER set this value directly:\n It is deduced from the AVStream values.\n\n Demuxing only, set by libavformat."]
    pub start_time: i64,
    #[doc = " Duration of the stream, in AV_TIME_BASE fractional\n seconds. Only set this value if you know none of the individual stream\n durations and also do not set any of them. This is deduced from the\n AVStream values if not set.\n\n Demuxing only, set by libavformat."]
    pub duration: i64,
    #[doc = " Total stream bitrate in bit/s, 0 if not\n available. Never set it directly if the file_size and the\n duration are known as FFmpeg can compute it automatically."]
    pub bit_rate: i64,
    pub packet_size: libc::c_uint,
    pub max_delay: libc::c_int,
    #[doc = " Flags modifying the (de)muxer behaviour. A combination of AVFMT_FLAG_*.\n Set by the user before avformat_open_input() / avformat_write_header()."]
    pub flags: libc::c_int,
    #[doc = " Maximum size of the data read from input for determining\n the input container format.\n Demuxing only, set by the caller before avformat_open_input()."]
    pub probesize: i64,
    #[doc = " Maximum duration (in AV_TIME_BASE units) of the data read\n from input in avformat_find_stream_info().\n Demuxing only, set by the caller before avformat_find_stream_info().\n Can be set to 0 to let avformat choose using a heuristic."]
    pub max_analyze_duration: i64,
    pub key: *const u8,
    pub keylen: libc::c_int,
    pub nb_programs: libc::c_uint,
    pub programs: *mut *mut AVProgram,
    #[doc = " Forced video codec_id.\n Demuxing: Set by user."]
    pub video_codec_id: AVCodecID,
    #[doc = " Forced audio codec_id.\n Demuxing: Set by user."]
    pub audio_codec_id: AVCodecID,
    #[doc = " Forced subtitle codec_id.\n Demuxing: Set by user."]
    pub subtitle_codec_id: AVCodecID,
    #[doc = " Maximum amount of memory in bytes to use for the index of each stream.\n If the index exceeds this size, entries will be discarded as\n needed to maintain a smaller size. This can lead to slower or less\n accurate seeking (depends on demuxer).\n Demuxers for which a full in-memory index is mandatory will ignore\n this.\n - muxing: unused\n - demuxing: set by user"]
    pub max_index_size: libc::c_uint,
    #[doc = " Maximum amount of memory in bytes to use for buffering frames\n obtained from realtime capture devices."]
    pub max_picture_buffer: libc::c_uint,
    #[doc = " Number of chapters in AVChapter array.\n When muxing, chapters are normally written in the file header,\n so nb_chapters should normally be initialized before write_header\n is called. Some muxers (e.g. mov and mkv) can also write chapters\n in the trailer.  To write chapters in the trailer, nb_chapters\n must be zero when write_header is called and non-zero when\n write_trailer is called.\n - muxing: set by user\n - demuxing: set by libavformat"]
    pub nb_chapters: libc::c_uint,
    pub chapters: *mut *mut AVChapter,
    #[doc = " Metadata that applies to the whole file.\n\n - demuxing: set by libavformat in avformat_open_input()\n - muxing: may be set by the caller before avformat_write_header()\n\n Freed by libavformat in avformat_free_context()."]
    pub metadata: *mut AVDictionary,
    #[doc = " Start time of the stream in real world time, in microseconds\n since the Unix epoch (00:00 1st January 1970). That is, pts=0 in the\n stream was captured at this real world time.\n - muxing: Set by the caller before avformat_write_header(). If set to\n           either 0 or AV_NOPTS_VALUE, then the current wall-time will\n           be used.\n - demuxing: Set by libavformat. AV_NOPTS_VALUE if unknown. Note that\n             the value may become known after some number of frames\n             have been received."]
    pub start_time_realtime: i64,
    #[doc = " The number of frames used for determining the framerate in\n avformat_find_stream_info().\n Demuxing only, set by the caller before avformat_find_stream_info()."]
    pub fps_probe_size: libc::c_int,
    #[doc = " Error recognition; higher values will detect more errors but may\n misdetect some more or less valid parts as errors.\n Demuxing only, set by the caller before avformat_open_input()."]
    pub error_recognition: libc::c_int,
    #[doc = " Custom interrupt callbacks for the I/O layer.\n\n demuxing: set by the user before avformat_open_input().\n muxing: set by the user before avformat_write_header()\n (mainly useful for AVFMT_NOFILE formats). The callback\n should also be passed to avio_open2() if it's used to\n open the file."]
    pub interrupt_callback: AVIOInterruptCB,
    #[doc = " Flags to enable debugging."]
    pub debug: libc::c_int,
    #[doc = " Maximum buffering duration for interleaving.\n\n To ensure all the streams are interleaved correctly,\n av_interleaved_write_frame() will wait until it has at least one packet\n for each stream before actually writing any packets to the output file.\n When some streams are \"sparse\" (i.e. there are large gaps between\n successive packets), this can result in excessive buffering.\n\n This field specifies the maximum difference between the timestamps of the\n first and the last packet in the muxing queue, above which libavformat\n will output a packet regardless of whether it has queued a packet for all\n the streams.\n\n Muxing only, set by the caller before avformat_write_header()."]
    pub max_interleave_delta: i64,
    #[doc = " Allow non-standard and experimental extension\n @see AVCodecContext.strict_std_compliance"]
    pub strict_std_compliance: libc::c_int,
    #[doc = " Flags indicating events happening on the file, a combination of\n AVFMT_EVENT_FLAG_*.\n\n - demuxing: may be set by the demuxer in avformat_open_input(),\n   avformat_find_stream_info() and av_read_frame(). Flags must be cleared\n   by the user once the event has been handled.\n - muxing: may be set by the user after avformat_write_header() to\n   indicate a user-triggered event.  The muxer will clear the flags for\n   events it has handled in av_[interleaved]_write_frame()."]
    pub event_flags: libc::c_int,
    #[doc = " Maximum number of packets to read while waiting for the first timestamp.\n Decoding only."]
    pub max_ts_probe: libc::c_int,
    #[doc = " Avoid negative timestamps during muxing.\n Any value of the AVFMT_AVOID_NEG_TS_* constants.\n Note, this only works when using av_interleaved_write_frame. (interleave_packet_per_dts is in use)\n - muxing: Set by user\n - demuxing: unused"]
    pub avoid_negative_ts: libc::c_int,
    #[doc = " Transport stream id.\n This will be moved into demuxer private options. Thus no API/ABI compatibility"]
    pub ts_id: libc::c_int,
    #[doc = " Audio preload in microseconds.\n Note, not all formats support this and unpredictable things may happen if it is used when not supported.\n - encoding: Set by user\n - decoding: unused"]
    pub audio_preload: libc::c_int,
    #[doc = " Max chunk time in microseconds.\n Note, not all formats support this and unpredictable things may happen if it is used when not supported.\n - encoding: Set by user\n - decoding: unused"]
    pub max_chunk_duration: libc::c_int,
    #[doc = " Max chunk size in bytes\n Note, not all formats support this and unpredictable things may happen if it is used when not supported.\n - encoding: Set by user\n - decoding: unused"]
    pub max_chunk_size: libc::c_int,
    #[doc = " forces the use of wallclock timestamps as pts/dts of packets\n This has undefined results in the presence of B frames.\n - encoding: unused\n - decoding: Set by user"]
    pub use_wallclock_as_timestamps: libc::c_int,
    #[doc = " avio flags, used to force AVIO_FLAG_DIRECT.\n - encoding: unused\n - decoding: Set by user"]
    pub avio_flags: libc::c_int,
    #[doc = " The duration field can be estimated through various ways, and this field can be used\n to know how the duration was estimated.\n - encoding: unused\n - decoding: Read by user"]
    pub duration_estimation_method: AVDurationEstimationMethod,
    #[doc = " Skip initial bytes when opening stream\n - encoding: unused\n - decoding: Set by user"]
    pub skip_initial_bytes: i64,
    #[doc = " Correct single timestamp overflows\n - encoding: unused\n - decoding: Set by user"]
    pub correct_ts_overflow: libc::c_uint,
    #[doc = " Force seeking to any (also non key) frames.\n - encoding: unused\n - decoding: Set by user"]
    pub seek2any: libc::c_int,
    #[doc = " Flush the I/O context after each packet.\n - encoding: Set by user\n - decoding: unused"]
    pub flush_packets: libc::c_int,
    #[doc = " format probing score.\n The maximal score is AVPROBE_SCORE_MAX, its set when the demuxer probes\n the format.\n - encoding: unused\n - decoding: set by avformat, read by user"]
    pub probe_score: libc::c_int,
    #[doc = " number of bytes to read maximally to identify format.\n - encoding: unused\n - decoding: set by user"]
    pub format_probesize: libc::c_int,
    #[doc = " ',' separated list of allowed decoders.\n If NULL then all are allowed\n - encoding: unused\n - decoding: set by user"]
    pub codec_whitelist: *mut libc::c_char,
    #[doc = " ',' separated list of allowed demuxers.\n If NULL then all are allowed\n - encoding: unused\n - decoding: set by user"]
    pub format_whitelist: *mut libc::c_char,
    #[doc = " An opaque field for libavformat internal usage.\n Must not be accessed in any way by callers."]
    pub internal: *mut AVFormatInternal,
    #[doc = " IO repositioned flag.\n This is set by avformat when the underlaying IO context read pointer\n is repositioned, for example when doing byte based seeking.\n Demuxers can use the flag to detect such changes."]
    pub io_repositioned: libc::c_int,
    #[doc = " Forced video codec.\n This allows forcing a specific decoder, even when there are multiple with\n the same codec_id.\n Demuxing: Set by user"]
    pub video_codec: *mut AVCodec,
    #[doc = " Forced audio codec.\n This allows forcing a specific decoder, even when there are multiple with\n the same codec_id.\n Demuxing: Set by user"]
    pub audio_codec: *mut AVCodec,
    #[doc = " Forced subtitle codec.\n This allows forcing a specific decoder, even when there are multiple with\n the same codec_id.\n Demuxing: Set by user"]
    pub subtitle_codec: *mut AVCodec,
    #[doc = " Forced data codec.\n This allows forcing a specific decoder, even when there are multiple with\n the same codec_id.\n Demuxing: Set by user"]
    pub data_codec: *mut AVCodec,
    #[doc = " Number of bytes to be written as padding in a metadata header.\n Demuxing: Unused.\n Muxing: Set by user via av_format_set_metadata_header_padding."]
    pub metadata_header_padding: libc::c_int,
    #[doc = " User data.\n This is a place for some private data of the user."]
    pub opaque: *mut libc::c_void,
    #[doc = " Callback used by devices to communicate with application."]
    pub control_message_cb: av_format_control_message,
    #[doc = " Output timestamp offset, in microseconds.\n Muxing: set by user"]
    pub output_ts_offset: i64,
    #[doc = " dump format separator.\n can be \", \" or \"\\n      \" or anything else\n - muxing: Set by user.\n - demuxing: Set by user."]
    pub dump_separator: *mut u8,
    #[doc = " Forced Data codec_id.\n Demuxing: Set by user."]
    pub data_codec_id: AVCodecID,
    #[doc = " Called to open further IO contexts when needed for demuxing.\n\n This can be set by the user application to perform security checks on\n the URLs before opening them.\n The function should behave like avio_open2(), AVFormatContext is provided\n as contextual information and to reach AVFormatContext.opaque.\n\n If NULL then some simple checks are used together with avio_open2().\n\n Must not be accessed directly from outside avformat.\n @See av_format_set_open_cb()\n\n Demuxing: Set by user.\n\n @deprecated Use io_open and io_close."]
    pub open_cb: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            p: *mut *mut AVIOContext,
            url: *const libc::c_char,
            flags: libc::c_int,
            int_cb: *const AVIOInterruptCB,
            options: *mut *mut AVDictionary,
        ) -> libc::c_int,
    >,
    #[doc = " ',' separated list of allowed protocols.\n - encoding: unused\n - decoding: set by user"]
    pub protocol_whitelist: *mut libc::c_char,
    #[doc = " A callback for opening new IO streams.\n\n Whenever a muxer or a demuxer needs to open an IO stream (typically from\n avformat_open_input() for demuxers, but for certain formats can happen at\n other times as well), it will call this callback to obtain an IO context.\n\n @param s the format context\n @param pb on success, the newly opened IO context should be returned here\n @param url the url to open\n @param flags a combination of AVIO_FLAG_*\n @param options a dictionary of additional options, with the same\n                semantics as in avio_open2()\n @return 0 on success, a negative AVERROR code on failure\n\n @note Certain muxers and demuxers do nesting, i.e. they open one or more\n additional internal format contexts. Thus the AVFormatContext pointer\n passed to this callback may be different from the one facing the caller.\n It will, however, have the same 'opaque' field."]
    pub io_open: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            pb: *mut *mut AVIOContext,
            url: *const libc::c_char,
            flags: libc::c_int,
            options: *mut *mut AVDictionary,
        ) -> libc::c_int,
    >,
    #[doc = " A callback for closing the streams opened with AVFormatContext.io_open()."]
    pub io_close:
        ::std::option::Option<unsafe extern "C" fn(s: *mut AVFormatContext, pb: *mut AVIOContext)>,
    #[doc = " ',' separated list of disallowed protocols.\n - encoding: unused\n - decoding: set by user"]
    pub protocol_blacklist: *mut libc::c_char,
    #[doc = " The maximum number of streams.\n - encoding: unused\n - decoding: set by user"]
    pub max_streams: libc::c_int,
    #[doc = " Skip duration calcuation in estimate_timings_from_pts.\n - encoding: unused\n - decoding: set by user"]
    pub skip_estimate_duration_from_pts: libc::c_int,
    #[doc = " Maximum number of packets that can be probed\n - encoding: unused\n - decoding: set by user"]
    pub max_probe_packets: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVFormatContext"][::std::mem::size_of::<AVFormatContext>() - 1504usize];
    ["Alignment of AVFormatContext"][::std::mem::align_of::<AVFormatContext>() - 8usize];
    ["Offset of field: AVFormatContext::av_class"]
        [::std::mem::offset_of!(AVFormatContext, av_class) - 0usize];
    ["Offset of field: AVFormatContext::iformat"]
        [::std::mem::offset_of!(AVFormatContext, iformat) - 8usize];
    ["Offset of field: AVFormatContext::oformat"]
        [::std::mem::offset_of!(AVFormatContext, oformat) - 16usize];
    ["Offset of field: AVFormatContext::priv_data"]
        [::std::mem::offset_of!(AVFormatContext, priv_data) - 24usize];
    ["Offset of field: AVFormatContext::pb"][::std::mem::offset_of!(AVFormatContext, pb) - 32usize];
    ["Offset of field: AVFormatContext::ctx_flags"]
        [::std::mem::offset_of!(AVFormatContext, ctx_flags) - 40usize];
    ["Offset of field: AVFormatContext::nb_streams"]
        [::std::mem::offset_of!(AVFormatContext, nb_streams) - 44usize];
    ["Offset of field: AVFormatContext::streams"]
        [::std::mem::offset_of!(AVFormatContext, streams) - 48usize];
    ["Offset of field: AVFormatContext::filename"]
        [::std::mem::offset_of!(AVFormatContext, filename) - 56usize];
    ["Offset of field: AVFormatContext::url"]
        [::std::mem::offset_of!(AVFormatContext, url) - 1080usize];
    ["Offset of field: AVFormatContext::start_time"]
        [::std::mem::offset_of!(AVFormatContext, start_time) - 1088usize];
    ["Offset of field: AVFormatContext::duration"]
        [::std::mem::offset_of!(AVFormatContext, duration) - 1096usize];
    ["Offset of field: AVFormatContext::bit_rate"]
        [::std::mem::offset_of!(AVFormatContext, bit_rate) - 1104usize];
    ["Offset of field: AVFormatContext::packet_size"]
        [::std::mem::offset_of!(AVFormatContext, packet_size) - 1112usize];
    ["Offset of field: AVFormatContext::max_delay"]
        [::std::mem::offset_of!(AVFormatContext, max_delay) - 1116usize];
    ["Offset of field: AVFormatContext::flags"]
        [::std::mem::offset_of!(AVFormatContext, flags) - 1120usize];
    ["Offset of field: AVFormatContext::probesize"]
        [::std::mem::offset_of!(AVFormatContext, probesize) - 1128usize];
    ["Offset of field: AVFormatContext::max_analyze_duration"]
        [::std::mem::offset_of!(AVFormatContext, max_analyze_duration) - 1136usize];
    ["Offset of field: AVFormatContext::key"]
        [::std::mem::offset_of!(AVFormatContext, key) - 1144usize];
    ["Offset of field: AVFormatContext::keylen"]
        [::std::mem::offset_of!(AVFormatContext, keylen) - 1152usize];
    ["Offset of field: AVFormatContext::nb_programs"]
        [::std::mem::offset_of!(AVFormatContext, nb_programs) - 1156usize];
    ["Offset of field: AVFormatContext::programs"]
        [::std::mem::offset_of!(AVFormatContext, programs) - 1160usize];
    ["Offset of field: AVFormatContext::video_codec_id"]
        [::std::mem::offset_of!(AVFormatContext, video_codec_id) - 1168usize];
    ["Offset of field: AVFormatContext::audio_codec_id"]
        [::std::mem::offset_of!(AVFormatContext, audio_codec_id) - 1172usize];
    ["Offset of field: AVFormatContext::subtitle_codec_id"]
        [::std::mem::offset_of!(AVFormatContext, subtitle_codec_id) - 1176usize];
    ["Offset of field: AVFormatContext::max_index_size"]
        [::std::mem::offset_of!(AVFormatContext, max_index_size) - 1180usize];
    ["Offset of field: AVFormatContext::max_picture_buffer"]
        [::std::mem::offset_of!(AVFormatContext, max_picture_buffer) - 1184usize];
    ["Offset of field: AVFormatContext::nb_chapters"]
        [::std::mem::offset_of!(AVFormatContext, nb_chapters) - 1188usize];
    ["Offset of field: AVFormatContext::chapters"]
        [::std::mem::offset_of!(AVFormatContext, chapters) - 1192usize];
    ["Offset of field: AVFormatContext::metadata"]
        [::std::mem::offset_of!(AVFormatContext, metadata) - 1200usize];
    ["Offset of field: AVFormatContext::start_time_realtime"]
        [::std::mem::offset_of!(AVFormatContext, start_time_realtime) - 1208usize];
    ["Offset of field: AVFormatContext::fps_probe_size"]
        [::std::mem::offset_of!(AVFormatContext, fps_probe_size) - 1216usize];
    ["Offset of field: AVFormatContext::error_recognition"]
        [::std::mem::offset_of!(AVFormatContext, error_recognition) - 1220usize];
    ["Offset of field: AVFormatContext::interrupt_callback"]
        [::std::mem::offset_of!(AVFormatContext, interrupt_callback) - 1224usize];
    ["Offset of field: AVFormatContext::debug"]
        [::std::mem::offset_of!(AVFormatContext, debug) - 1240usize];
    ["Offset of field: AVFormatContext::max_interleave_delta"]
        [::std::mem::offset_of!(AVFormatContext, max_interleave_delta) - 1248usize];
    ["Offset of field: AVFormatContext::strict_std_compliance"]
        [::std::mem::offset_of!(AVFormatContext, strict_std_compliance) - 1256usize];
    ["Offset of field: AVFormatContext::event_flags"]
        [::std::mem::offset_of!(AVFormatContext, event_flags) - 1260usize];
    ["Offset of field: AVFormatContext::max_ts_probe"]
        [::std::mem::offset_of!(AVFormatContext, max_ts_probe) - 1264usize];
    ["Offset of field: AVFormatContext::avoid_negative_ts"]
        [::std::mem::offset_of!(AVFormatContext, avoid_negative_ts) - 1268usize];
    ["Offset of field: AVFormatContext::ts_id"]
        [::std::mem::offset_of!(AVFormatContext, ts_id) - 1272usize];
    ["Offset of field: AVFormatContext::audio_preload"]
        [::std::mem::offset_of!(AVFormatContext, audio_preload) - 1276usize];
    ["Offset of field: AVFormatContext::max_chunk_duration"]
        [::std::mem::offset_of!(AVFormatContext, max_chunk_duration) - 1280usize];
    ["Offset of field: AVFormatContext::max_chunk_size"]
        [::std::mem::offset_of!(AVFormatContext, max_chunk_size) - 1284usize];
    ["Offset of field: AVFormatContext::use_wallclock_as_timestamps"]
        [::std::mem::offset_of!(AVFormatContext, use_wallclock_as_timestamps) - 1288usize];
    ["Offset of field: AVFormatContext::avio_flags"]
        [::std::mem::offset_of!(AVFormatContext, avio_flags) - 1292usize];
    ["Offset of field: AVFormatContext::duration_estimation_method"]
        [::std::mem::offset_of!(AVFormatContext, duration_estimation_method) - 1296usize];
    ["Offset of field: AVFormatContext::skip_initial_bytes"]
        [::std::mem::offset_of!(AVFormatContext, skip_initial_bytes) - 1304usize];
    ["Offset of field: AVFormatContext::correct_ts_overflow"]
        [::std::mem::offset_of!(AVFormatContext, correct_ts_overflow) - 1312usize];
    ["Offset of field: AVFormatContext::seek2any"]
        [::std::mem::offset_of!(AVFormatContext, seek2any) - 1316usize];
    ["Offset of field: AVFormatContext::flush_packets"]
        [::std::mem::offset_of!(AVFormatContext, flush_packets) - 1320usize];
    ["Offset of field: AVFormatContext::probe_score"]
        [::std::mem::offset_of!(AVFormatContext, probe_score) - 1324usize];
    ["Offset of field: AVFormatContext::format_probesize"]
        [::std::mem::offset_of!(AVFormatContext, format_probesize) - 1328usize];
    ["Offset of field: AVFormatContext::codec_whitelist"]
        [::std::mem::offset_of!(AVFormatContext, codec_whitelist) - 1336usize];
    ["Offset of field: AVFormatContext::format_whitelist"]
        [::std::mem::offset_of!(AVFormatContext, format_whitelist) - 1344usize];
    ["Offset of field: AVFormatContext::internal"]
        [::std::mem::offset_of!(AVFormatContext, internal) - 1352usize];
    ["Offset of field: AVFormatContext::io_repositioned"]
        [::std::mem::offset_of!(AVFormatContext, io_repositioned) - 1360usize];
    ["Offset of field: AVFormatContext::video_codec"]
        [::std::mem::offset_of!(AVFormatContext, video_codec) - 1368usize];
    ["Offset of field: AVFormatContext::audio_codec"]
        [::std::mem::offset_of!(AVFormatContext, audio_codec) - 1376usize];
    ["Offset of field: AVFormatContext::subtitle_codec"]
        [::std::mem::offset_of!(AVFormatContext, subtitle_codec) - 1384usize];
    ["Offset of field: AVFormatContext::data_codec"]
        [::std::mem::offset_of!(AVFormatContext, data_codec) - 1392usize];
    ["Offset of field: AVFormatContext::metadata_header_padding"]
        [::std::mem::offset_of!(AVFormatContext, metadata_header_padding) - 1400usize];
    ["Offset of field: AVFormatContext::opaque"]
        [::std::mem::offset_of!(AVFormatContext, opaque) - 1408usize];
    ["Offset of field: AVFormatContext::control_message_cb"]
        [::std::mem::offset_of!(AVFormatContext, control_message_cb) - 1416usize];
    ["Offset of field: AVFormatContext::output_ts_offset"]
        [::std::mem::offset_of!(AVFormatContext, output_ts_offset) - 1424usize];
    ["Offset of field: AVFormatContext::dump_separator"]
        [::std::mem::offset_of!(AVFormatContext, dump_separator) - 1432usize];
    ["Offset of field: AVFormatContext::data_codec_id"]
        [::std::mem::offset_of!(AVFormatContext, data_codec_id) - 1440usize];
    ["Offset of field: AVFormatContext::open_cb"]
        [::std::mem::offset_of!(AVFormatContext, open_cb) - 1448usize];
    ["Offset of field: AVFormatContext::protocol_whitelist"]
        [::std::mem::offset_of!(AVFormatContext, protocol_whitelist) - 1456usize];
    ["Offset of field: AVFormatContext::io_open"]
        [::std::mem::offset_of!(AVFormatContext, io_open) - 1464usize];
    ["Offset of field: AVFormatContext::io_close"]
        [::std::mem::offset_of!(AVFormatContext, io_close) - 1472usize];
    ["Offset of field: AVFormatContext::protocol_blacklist"]
        [::std::mem::offset_of!(AVFormatContext, protocol_blacklist) - 1480usize];
    ["Offset of field: AVFormatContext::max_streams"]
        [::std::mem::offset_of!(AVFormatContext, max_streams) - 1488usize];
    ["Offset of field: AVFormatContext::skip_estimate_duration_from_pts"]
        [::std::mem::offset_of!(AVFormatContext, skip_estimate_duration_from_pts) - 1492usize];
    ["Offset of field: AVFormatContext::max_probe_packets"]
        [::std::mem::offset_of!(AVFormatContext, max_probe_packets) - 1496usize];
};
extern "C" {
    #[doc = " Accessors for some AVFormatContext fields. These used to be provided for ABI\n compatibility, and do not need to be used anymore."]
    pub fn av_format_get_probe_score(s: *const AVFormatContext) -> libc::c_int;
}
extern "C" {
    pub fn av_format_get_video_codec(s: *const AVFormatContext) -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_video_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_audio_codec(s: *const AVFormatContext) -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_audio_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_subtitle_codec(s: *const AVFormatContext) -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_subtitle_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_data_codec(s: *const AVFormatContext) -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_data_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_metadata_header_padding(s: *const AVFormatContext) -> libc::c_int;
}
extern "C" {
    pub fn av_format_set_metadata_header_padding(s: *mut AVFormatContext, c: libc::c_int);
}
extern "C" {
    pub fn av_format_get_opaque(s: *const AVFormatContext) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_format_set_opaque(s: *mut AVFormatContext, opaque: *mut libc::c_void);
}
extern "C" {
    pub fn av_format_get_control_message_cb(s: *const AVFormatContext)
        -> av_format_control_message;
}
extern "C" {
    pub fn av_format_set_control_message_cb(
        s: *mut AVFormatContext,
        callback: av_format_control_message,
    );
}
extern "C" {
    pub fn av_format_get_open_cb(s: *const AVFormatContext) -> AVOpenCallback;
}
extern "C" {
    pub fn av_format_set_open_cb(s: *mut AVFormatContext, callback: AVOpenCallback);
}
extern "C" {
    #[doc = " This function will cause global side data to be injected in the next packet\n of each stream as well as after any subsequent seek."]
    pub fn av_format_inject_global_side_data(s: *mut AVFormatContext);
}
extern "C" {
    #[doc = " Returns the method used to set ctx->duration.\n\n @return AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or AVFMT_DURATION_FROM_BITRATE."]
    pub fn av_fmt_ctx_get_duration_estimation_method(
        ctx: *const AVFormatContext,
    ) -> AVDurationEstimationMethod;
}
extern "C" {
    #[doc = " Return the LIBAVFORMAT_VERSION_INT constant."]
    pub fn avformat_version() -> libc::c_uint;
}
extern "C" {
    #[doc = " Return the libavformat build-time configuration."]
    pub fn avformat_configuration() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return the libavformat license."]
    pub fn avformat_license() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Initialize libavformat and register all the muxers, demuxers and\n protocols. If you do not call this function, then you can select\n exactly which formats you want to support.\n\n @see av_register_input_format()\n @see av_register_output_format()"]
    pub fn av_register_all();
}
extern "C" {
    pub fn av_register_input_format(format: *mut AVInputFormat);
}
extern "C" {
    pub fn av_register_output_format(format: *mut AVOutputFormat);
}
extern "C" {
    #[doc = " Do global initialization of network libraries. This is optional,\n and not recommended anymore.\n\n This functions only exists to work around thread-safety issues\n with older GnuTLS or OpenSSL libraries. If libavformat is linked\n to newer versions of those libraries, or if you do not use them,\n calling this function is unnecessary. Otherwise, you need to call\n this function before any other threads using them are started.\n\n This function will be deprecated once support for older GnuTLS and\n OpenSSL libraries is removed, and this function has no purpose\n anymore."]
    pub fn avformat_network_init() -> libc::c_int;
}
extern "C" {
    #[doc = " Undo the initialization done by avformat_network_init. Call it only\n once for each time you called avformat_network_init."]
    pub fn avformat_network_deinit() -> libc::c_int;
}
extern "C" {
    #[doc = " If f is NULL, returns the first registered input format,\n if f is non-NULL, returns the next registered input format after f\n or NULL if f is the last one."]
    pub fn av_iformat_next(f: *const AVInputFormat) -> *mut AVInputFormat;
}
extern "C" {
    #[doc = " If f is NULL, returns the first registered output format,\n if f is non-NULL, returns the next registered output format after f\n or NULL if f is the last one."]
    pub fn av_oformat_next(f: *const AVOutputFormat) -> *mut AVOutputFormat;
}
extern "C" {
    #[doc = " Iterate over all registered muxers.\n\n @param opaque a pointer where libavformat will store the iteration state. Must\n               point to NULL to start the iteration.\n\n @return the next registered muxer or NULL when the iteration is\n         finished"]
    pub fn av_muxer_iterate(opaque: *mut *mut libc::c_void) -> *const AVOutputFormat;
}
extern "C" {
    #[doc = " Iterate over all registered demuxers.\n\n @param opaque a pointer where libavformat will store the iteration state. Must\n               point to NULL to start the iteration.\n\n @return the next registered demuxer or NULL when the iteration is\n         finished"]
    pub fn av_demuxer_iterate(opaque: *mut *mut libc::c_void) -> *const AVInputFormat;
}
extern "C" {
    #[doc = " Allocate an AVFormatContext.\n avformat_free_context() can be used to free the context and everything\n allocated by the framework within it."]
    pub fn avformat_alloc_context() -> *mut AVFormatContext;
}
extern "C" {
    #[doc = " Free an AVFormatContext and all its streams.\n @param s context to free"]
    pub fn avformat_free_context(s: *mut AVFormatContext);
}
extern "C" {
    #[doc = " Get the AVClass for AVFormatContext. It can be used in combination with\n AV_OPT_SEARCH_FAKE_OBJ for examining options.\n\n @see av_opt_find()."]
    pub fn avformat_get_class() -> *const AVClass;
}
extern "C" {
    #[doc = " Add a new stream to a media file.\n\n When demuxing, it is called by the demuxer in read_header(). If the\n flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also\n be called in read_packet().\n\n When muxing, should be called by the user before avformat_write_header().\n\n User is required to call avcodec_close() and avformat_free_context() to\n clean up the allocation by avformat_new_stream().\n\n @param s media file handle\n @param c If non-NULL, the AVCodecContext corresponding to the new stream\n will be initialized to use this codec. This is needed for e.g. codec-specific\n defaults to be set, so codec should be provided if it is known.\n\n @return newly created stream or NULL on error."]
    pub fn avformat_new_stream(s: *mut AVFormatContext, c: *const AVCodec) -> *mut AVStream;
}
extern "C" {
    #[doc = " Wrap an existing array as stream side data.\n\n @param st stream\n @param type side information type\n @param data the side data array. It must be allocated with the av_malloc()\n             family of functions. The ownership of the data is transferred to\n             st.\n @param size side information size\n @return zero on success, a negative AVERROR code on failure. On failure,\n         the stream is unchanged and the data remains owned by the caller."]
    pub fn av_stream_add_side_data(
        st: *mut AVStream,
        type_: AVPacketSideDataType,
        data: *mut u8,
        size: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate new information from stream.\n\n @param stream stream\n @param type desired side information type\n @param size side information size\n @return pointer to fresh allocated data or NULL otherwise"]
    pub fn av_stream_new_side_data(
        stream: *mut AVStream,
        type_: AVPacketSideDataType,
        size: libc::c_int,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Get side information from stream.\n\n @param stream stream\n @param type desired side information type\n @param size If supplied, *size will be set to the size of the side data\n             or to zero if the desired side data is not present.\n @return pointer to data if present or NULL otherwise"]
    pub fn av_stream_get_side_data(
        stream: *const AVStream,
        type_: AVPacketSideDataType,
        size: *mut libc::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_new_program(s: *mut AVFormatContext, id: libc::c_int) -> *mut AVProgram;
}
extern "C" {
    #[doc = " Allocate an AVFormatContext for an output format.\n avformat_free_context() can be used to free the context and\n everything allocated by the framework within it.\n\n @param *ctx is set to the created format context, or to NULL in\n case of failure\n @param oformat format to use for allocating the context, if NULL\n format_name and filename are used instead\n @param format_name the name of output format to use for allocating the\n context, if NULL filename is used instead\n @param filename the name of the filename to use for allocating the\n context, may be NULL\n @return >= 0 in case of success, a negative AVERROR code in case of\n failure"]
    pub fn avformat_alloc_output_context2(
        ctx: *mut *mut AVFormatContext,
        oformat: *mut AVOutputFormat,
        format_name: *const libc::c_char,
        filename: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Find AVInputFormat based on the short name of the input format."]
    pub fn av_find_input_format(short_name: *const libc::c_char) -> *mut AVInputFormat;
}
extern "C" {
    #[doc = " Guess the file format.\n\n @param pd        data to be probed\n @param is_opened Whether the file is already opened; determines whether\n                  demuxers with or without AVFMT_NOFILE are probed."]
    pub fn av_probe_input_format(
        pd: *mut AVProbeData,
        is_opened: libc::c_int,
    ) -> *mut AVInputFormat;
}
extern "C" {
    #[doc = " Guess the file format.\n\n @param pd        data to be probed\n @param is_opened Whether the file is already opened; determines whether\n                  demuxers with or without AVFMT_NOFILE are probed.\n @param score_max A probe score larger that this is required to accept a\n                  detection, the variable is set to the actual detection\n                  score afterwards.\n                  If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended\n                  to retry with a larger probe buffer."]
    pub fn av_probe_input_format2(
        pd: *mut AVProbeData,
        is_opened: libc::c_int,
        score_max: *mut libc::c_int,
    ) -> *mut AVInputFormat;
}
extern "C" {
    #[doc = " Guess the file format.\n\n @param is_opened Whether the file is already opened; determines whether\n                  demuxers with or without AVFMT_NOFILE are probed.\n @param score_ret The score of the best detection."]
    pub fn av_probe_input_format3(
        pd: *mut AVProbeData,
        is_opened: libc::c_int,
        score_ret: *mut libc::c_int,
    ) -> *mut AVInputFormat;
}
extern "C" {
    #[doc = " Probe a bytestream to determine the input format. Each time a probe returns\n with a score that is too low, the probe buffer size is increased and another\n attempt is made. When the maximum probe size is reached, the input format\n with the highest score is returned.\n\n @param pb the bytestream to probe\n @param fmt the input format is put here\n @param url the url of the stream\n @param logctx the log context\n @param offset the offset within the bytestream to probe from\n @param max_probe_size the maximum probe buffer size (zero for default)\n @return the score in case of success, a negative value corresponding to an\n         the maximal score is AVPROBE_SCORE_MAX\n AVERROR code otherwise"]
    pub fn av_probe_input_buffer2(
        pb: *mut AVIOContext,
        fmt: *mut *mut AVInputFormat,
        url: *const libc::c_char,
        logctx: *mut libc::c_void,
        offset: libc::c_uint,
        max_probe_size: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Like av_probe_input_buffer2() but returns 0 on success"]
    pub fn av_probe_input_buffer(
        pb: *mut AVIOContext,
        fmt: *mut *mut AVInputFormat,
        url: *const libc::c_char,
        logctx: *mut libc::c_void,
        offset: libc::c_uint,
        max_probe_size: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Open an input stream and read the header. The codecs are not opened.\n The stream must be closed with avformat_close_input().\n\n @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context).\n           May be a pointer to NULL, in which case an AVFormatContext is allocated by this\n           function and written into ps.\n           Note that a user-supplied AVFormatContext will be freed on failure.\n @param url URL of the stream to open.\n @param fmt If non-NULL, this parameter forces a specific input format.\n            Otherwise the format is autodetected.\n @param options  A dictionary filled with AVFormatContext and demuxer-private options.\n                 On return this parameter will be destroyed and replaced with a dict containing\n                 options that were not found. May be NULL.\n\n @return 0 on success, a negative AVERROR on failure.\n\n @note If you want to use custom IO, preallocate the format context and set its pb field."]
    pub fn avformat_open_input(
        ps: *mut *mut AVFormatContext,
        url: *const libc::c_char,
        fmt: *mut AVInputFormat,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @deprecated Use an AVDictionary to pass options to a demuxer."]
    pub fn av_demuxer_open(ic: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Read packets of a media file to get stream information. This\n is useful for file formats with no headers such as MPEG. This\n function also computes the real framerate in case of MPEG-2 repeat\n frame mode.\n The logical file position is not changed by this function;\n examined packets may be buffered for later processing.\n\n @param ic media file handle\n @param options  If non-NULL, an ic.nb_streams long array of pointers to\n                 dictionaries, where i-th member contains options for\n                 codec corresponding to i-th stream.\n                 On return each dictionary will be filled with options that were not found.\n @return >=0 if OK, AVERROR_xxx on error\n\n @note this function isn't guaranteed to open all the codecs, so\n       options being non-empty at return is a perfectly normal behavior.\n\n @todo Let the user decide somehow what information is needed so that\n       we do not waste time getting stuff the user does not need."]
    pub fn avformat_find_stream_info(
        ic: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Find the programs which belong to a given stream.\n\n @param ic    media file handle\n @param last  the last found program, the search will start after this\n              program, or from the beginning if it is NULL\n @param s     stream index\n @return the next program which belongs to s, NULL if no program is found or\n         the last program is not among the programs of ic."]
    pub fn av_find_program_from_stream(
        ic: *mut AVFormatContext,
        last: *mut AVProgram,
        s: libc::c_int,
    ) -> *mut AVProgram;
}
extern "C" {
    pub fn av_program_add_stream_index(
        ac: *mut AVFormatContext,
        progid: libc::c_int,
        idx: libc::c_uint,
    );
}
extern "C" {
    #[doc = " Find the \"best\" stream in the file.\n The best stream is determined according to various heuristics as the most\n likely to be what the user expects.\n If the decoder parameter is non-NULL, av_find_best_stream will find the\n default decoder for the stream's codec; streams for which no decoder can\n be found are ignored.\n\n @param ic                media file handle\n @param type              stream type: video, audio, subtitles, etc.\n @param wanted_stream_nb  user-requested stream number,\n                          or -1 for automatic selection\n @param related_stream    try to find a stream related (eg. in the same\n                          program) to this one, or -1 if none\n @param decoder_ret       if non-NULL, returns the decoder for the\n                          selected stream\n @param flags             flags; none are currently defined\n @return  the non-negative stream number in case of success,\n          AVERROR_STREAM_NOT_FOUND if no stream with the requested type\n          could be found,\n          AVERROR_DECODER_NOT_FOUND if streams were found but no decoder\n @note  If av_find_best_stream returns successfully and decoder_ret is not\n        NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec."]
    pub fn av_find_best_stream(
        ic: *mut AVFormatContext,
        type_: AVMediaType,
        wanted_stream_nb: libc::c_int,
        related_stream: libc::c_int,
        decoder_ret: *mut *mut AVCodec,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the next frame of a stream.\n This function returns what is stored in the file, and does not validate\n that what is there are valid frames for the decoder. It will split what is\n stored in the file into frames and return one for each call. It will not\n omit invalid data between valid frames so as to give the decoder the maximum\n information possible for decoding.\n\n On success, the returned packet is reference-counted (pkt->buf is set) and\n valid indefinitely. The packet must be freed with av_packet_unref() when\n it is no longer needed. For video, the packet contains exactly one frame.\n For audio, it contains an integer number of frames if each frame has\n a known fixed size (e.g. PCM or ADPCM data). If the audio frames have\n a variable size (e.g. MPEG audio), then it contains one frame.\n\n pkt->pts, pkt->dts and pkt->duration are always set to correct\n values in AVStream.time_base units (and guessed if the format cannot\n provide them). pkt->pts can be AV_NOPTS_VALUE if the video format\n has B-frames, so it is better to rely on pkt->dts if you do not\n decompress the payload.\n\n @return 0 if OK, < 0 on error or end of file. On error, pkt will be blank\n         (as if it came from av_packet_alloc()).\n\n @note pkt will be initialized, so it may be uninitialized, but it must not\n       contain data that needs to be freed."]
    pub fn av_read_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Seek to the keyframe at timestamp.\n 'timestamp' in 'stream_index'.\n\n @param s media file handle\n @param stream_index If stream_index is (-1), a default\n stream is selected, and timestamp is automatically converted\n from AV_TIME_BASE units to the stream specific time_base.\n @param timestamp Timestamp in AVStream.time_base units\n        or, if no stream is specified, in AV_TIME_BASE units.\n @param flags flags which select direction and seeking mode\n @return >= 0 on success"]
    pub fn av_seek_frame(
        s: *mut AVFormatContext,
        stream_index: libc::c_int,
        timestamp: i64,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Seek to timestamp ts.\n Seeking will be done so that the point from which all active streams\n can be presented successfully will be closest to ts and within min/max_ts.\n Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.\n\n If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and\n are the file position (this may not be supported by all demuxers).\n If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames\n in the stream with stream_index (this may not be supported by all demuxers).\n Otherwise all timestamps are in units of the stream selected by stream_index\n or if stream_index is -1, in AV_TIME_BASE units.\n If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as\n keyframes (this may not be supported by all demuxers).\n If flags contain AVSEEK_FLAG_BACKWARD, it is ignored.\n\n @param s media file handle\n @param stream_index index of the stream which is used as time base reference\n @param min_ts smallest acceptable timestamp\n @param ts target timestamp\n @param max_ts largest acceptable timestamp\n @param flags flags\n @return >=0 on success, error code otherwise\n\n @note This is part of the new seek API which is still under construction."]
    pub fn avformat_seek_file(
        s: *mut AVFormatContext,
        stream_index: libc::c_int,
        min_ts: i64,
        ts: i64,
        max_ts: i64,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Discard all internally buffered data. This can be useful when dealing with\n discontinuities in the byte stream. Generally works only with formats that\n can resync. This includes headerless formats like MPEG-TS/TS but should also\n work with NUT, Ogg and in a limited way AVI for example.\n\n The set of streams, the detected duration, stream parameters and codecs do\n not change when calling this function. If you want a complete reset, it's\n better to open a new AVFormatContext.\n\n This does not flush the AVIOContext (s->pb). If necessary, call\n avio_flush(s->pb) before calling this function.\n\n @param s media file handle\n @return >=0 on success, error code otherwise"]
    pub fn avformat_flush(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Start playing a network-based stream (e.g. RTSP stream) at the\n current position."]
    pub fn av_read_play(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Pause a network-based stream (e.g. RTSP stream).\n\n Use av_read_play() to resume it."]
    pub fn av_read_pause(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Close an opened input AVFormatContext. Free it and all its contents\n and set *s to NULL."]
    pub fn avformat_close_input(s: *mut *mut AVFormatContext);
}
extern "C" {
    #[doc = " Allocate the stream private data and write the stream header to\n an output media file.\n\n @param s Media file handle, must be allocated with avformat_alloc_context().\n          Its oformat field must be set to the desired output format;\n          Its pb field must be set to an already opened AVIOContext.\n @param options  An AVDictionary filled with AVFormatContext and muxer-private options.\n                 On return this parameter will be destroyed and replaced with a dict containing\n                 options that were not found. May be NULL.\n\n @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec had not already been fully initialized in avformat_init,\n         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec had already been fully initialized in avformat_init,\n         negative AVERROR on failure.\n\n @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_init_output."]
    pub fn avformat_write_header(
        s: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate the stream private data and initialize the codec, but do not write the header.\n May optionally be used before avformat_write_header to initialize stream parameters\n before actually writing the header.\n If using this function, do not pass the same options to avformat_write_header.\n\n @param s Media file handle, must be allocated with avformat_alloc_context().\n          Its oformat field must be set to the desired output format;\n          Its pb field must be set to an already opened AVIOContext.\n @param options  An AVDictionary filled with AVFormatContext and muxer-private options.\n                 On return this parameter will be destroyed and replaced with a dict containing\n                 options that were not found. May be NULL.\n\n @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec requires avformat_write_header to fully initialize,\n         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec has been fully initialized,\n         negative AVERROR on failure.\n\n @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_write_header."]
    pub fn avformat_init_output(
        s: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Write a packet to an output media file.\n\n This function passes the packet directly to the muxer, without any buffering\n or reordering. The caller is responsible for correctly interleaving the\n packets if the format requires it. Callers that want libavformat to handle\n the interleaving should call av_interleaved_write_frame() instead of this\n function.\n\n @param s media file handle\n @param pkt The packet containing the data to be written. Note that unlike\n            av_interleaved_write_frame(), this function does not take\n            ownership of the packet passed to it (though some muxers may make\n            an internal reference to the input packet).\n            <br>\n            This parameter can be NULL (at any time, not just at the end), in\n            order to immediately flush data buffered within the muxer, for\n            muxers that buffer up data internally before writing it to the\n            output.\n            <br>\n            Packet's @ref AVPacket.stream_index \"stream_index\" field must be\n            set to the index of the corresponding stream in @ref\n            AVFormatContext.streams \"s->streams\".\n            <br>\n            The timestamps (@ref AVPacket.pts \"pts\", @ref AVPacket.dts \"dts\")\n            must be set to correct values in the stream's timebase (unless the\n            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then\n            they can be set to AV_NOPTS_VALUE).\n            The dts for subsequent packets passed to this function must be strictly\n            increasing when compared in their respective timebases (unless the\n            output format is flagged with the AVFMT_TS_NONSTRICT, then they\n            merely have to be nondecreasing).  @ref AVPacket.duration\n            \"duration\") should also be set if known.\n @return < 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush\n\n @see av_interleaved_write_frame()"]
    pub fn av_write_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Write a packet to an output media file ensuring correct interleaving.\n\n This function will buffer the packets internally as needed to make sure the\n packets in the output file are properly interleaved in the order of\n increasing dts. Callers doing their own interleaving should call\n av_write_frame() instead of this function.\n\n Using this function instead of av_write_frame() can give muxers advance\n knowledge of future packets, improving e.g. the behaviour of the mp4\n muxer for VFR content in fragmenting mode.\n\n @param s media file handle\n @param pkt The packet containing the data to be written.\n            <br>\n            If the packet is reference-counted, this function will take\n            ownership of this reference and unreference it later when it sees\n            fit.\n            The caller must not access the data through this reference after\n            this function returns. If the packet is not reference-counted,\n            libavformat will make a copy.\n            <br>\n            This parameter can be NULL (at any time, not just at the end), to\n            flush the interleaving queues.\n            <br>\n            Packet's @ref AVPacket.stream_index \"stream_index\" field must be\n            set to the index of the corresponding stream in @ref\n            AVFormatContext.streams \"s->streams\".\n            <br>\n            The timestamps (@ref AVPacket.pts \"pts\", @ref AVPacket.dts \"dts\")\n            must be set to correct values in the stream's timebase (unless the\n            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then\n            they can be set to AV_NOPTS_VALUE).\n            The dts for subsequent packets in one stream must be strictly\n            increasing (unless the output format is flagged with the\n            AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing).\n            @ref AVPacket.duration \"duration\") should also be set if known.\n\n @return 0 on success, a negative AVERROR on error. Libavformat will always\n         take care of freeing the packet, even if this function fails.\n\n @see av_write_frame(), AVFormatContext.max_interleave_delta"]
    pub fn av_interleaved_write_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Write an uncoded frame to an output media file.\n\n The frame must be correctly interleaved according to the container\n specification; if not, av_interleaved_write_uncoded_frame() must be used.\n\n See av_interleaved_write_uncoded_frame() for details."]
    pub fn av_write_uncoded_frame(
        s: *mut AVFormatContext,
        stream_index: libc::c_int,
        frame: *mut AVFrame,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Write an uncoded frame to an output media file.\n\n If the muxer supports it, this function makes it possible to write an AVFrame\n structure directly, without encoding it into a packet.\n It is mostly useful for devices and similar special muxers that use raw\n video or PCM data and will not serialize it into a byte stream.\n\n To test whether it is possible to use it with a given muxer and stream,\n use av_write_uncoded_frame_query().\n\n The caller gives up ownership of the frame and must not access it\n afterwards.\n\n @return  >=0 for success, a negative code on error"]
    pub fn av_interleaved_write_uncoded_frame(
        s: *mut AVFormatContext,
        stream_index: libc::c_int,
        frame: *mut AVFrame,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Test whether a muxer supports uncoded frame.\n\n @return  >=0 if an uncoded frame can be written to that muxer and stream,\n          <0 if not"]
    pub fn av_write_uncoded_frame_query(
        s: *mut AVFormatContext,
        stream_index: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Write the stream trailer to an output media file and free the\n file private data.\n\n May only be called after a successful call to avformat_write_header.\n\n @param s media file handle\n @return 0 if OK, AVERROR_xxx on error"]
    pub fn av_write_trailer(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the output format in the list of registered output formats\n which best matches the provided parameters, or return NULL if\n there is no match.\n\n @param short_name if non-NULL checks if short_name matches with the\n names of the registered formats\n @param filename if non-NULL checks if filename terminates with the\n extensions of the registered formats\n @param mime_type if non-NULL checks if mime_type matches with the\n MIME type of the registered formats"]
    pub fn av_guess_format(
        short_name: *const libc::c_char,
        filename: *const libc::c_char,
        mime_type: *const libc::c_char,
    ) -> *mut AVOutputFormat;
}
extern "C" {
    #[doc = " Guess the codec ID based upon muxer and filename."]
    pub fn av_guess_codec(
        fmt: *mut AVOutputFormat,
        short_name: *const libc::c_char,
        filename: *const libc::c_char,
        mime_type: *const libc::c_char,
        type_: AVMediaType,
    ) -> AVCodecID;
}
extern "C" {
    #[doc = " Get timing information for the data currently output.\n The exact meaning of \"currently output\" depends on the format.\n It is mostly relevant for devices that have an internal buffer and/or\n work in real time.\n @param s          media file handle\n @param stream     stream in the media file\n @param[out] dts   DTS of the last packet output for the stream, in stream\n                   time_base units\n @param[out] wall  absolute time when that packet whas output,\n                   in microsecond\n @return  0 if OK, AVERROR(ENOSYS) if the format does not support it\n Note: some formats or devices may not allow to measure dts and wall\n atomically."]
    pub fn av_get_output_timestamp(
        s: *mut AVFormatContext,
        stream: libc::c_int,
        dts: *mut i64,
        wall: *mut i64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Send a nice hexadecimal dump of a buffer to the specified file stream.\n\n @param f The file stream pointer where the dump should be sent to.\n @param buf buffer\n @param size buffer size\n\n @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2"]
    pub fn av_hex_dump(f: *mut FILE, buf: *const u8, size: libc::c_int);
}
extern "C" {
    #[doc = " Send a nice hexadecimal dump of a buffer to the log.\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n pointer to an AVClass struct.\n @param level The importance level of the message, lower values signifying\n higher importance.\n @param buf buffer\n @param size buffer size\n\n @see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2"]
    pub fn av_hex_dump_log(
        avcl: *mut libc::c_void,
        level: libc::c_int,
        buf: *const u8,
        size: libc::c_int,
    );
}
extern "C" {
    #[doc = " Send a nice dump of a packet to the specified file stream.\n\n @param f The file stream pointer where the dump should be sent to.\n @param pkt packet to dump\n @param dump_payload True if the payload must be displayed, too.\n @param st AVStream that the packet belongs to"]
    pub fn av_pkt_dump2(
        f: *mut FILE,
        pkt: *const AVPacket,
        dump_payload: libc::c_int,
        st: *const AVStream,
    );
}
extern "C" {
    #[doc = " Send a nice dump of a packet to the log.\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n pointer to an AVClass struct.\n @param level The importance level of the message, lower values signifying\n higher importance.\n @param pkt packet to dump\n @param dump_payload True if the payload must be displayed, too.\n @param st AVStream that the packet belongs to"]
    pub fn av_pkt_dump_log2(
        avcl: *mut libc::c_void,
        level: libc::c_int,
        pkt: *const AVPacket,
        dump_payload: libc::c_int,
        st: *const AVStream,
    );
}
extern "C" {
    #[doc = " Get the AVCodecID for the given codec tag tag.\n If no codec id is found returns AV_CODEC_ID_NONE.\n\n @param tags list of supported codec_id-codec_tag pairs, as stored\n in AVInputFormat.codec_tag and AVOutputFormat.codec_tag\n @param tag  codec tag to match to a codec ID"]
    pub fn av_codec_get_id(tags: *const *const AVCodecTag, tag: libc::c_uint) -> AVCodecID;
}
extern "C" {
    #[doc = " Get the codec tag for the given codec id id.\n If no codec tag is found returns 0.\n\n @param tags list of supported codec_id-codec_tag pairs, as stored\n in AVInputFormat.codec_tag and AVOutputFormat.codec_tag\n @param id   codec ID to match to a codec tag"]
    pub fn av_codec_get_tag(tags: *const *const AVCodecTag, id: AVCodecID) -> libc::c_uint;
}
extern "C" {
    #[doc = " Get the codec tag for the given codec id.\n\n @param tags list of supported codec_id - codec_tag pairs, as stored\n in AVInputFormat.codec_tag and AVOutputFormat.codec_tag\n @param id codec id that should be searched for in the list\n @param tag A pointer to the found tag\n @return 0 if id was not found in tags, > 0 if it was found"]
    pub fn av_codec_get_tag2(
        tags: *const *const AVCodecTag,
        id: AVCodecID,
        tag: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_find_default_stream_index(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the index for a specific timestamp.\n\n @param st        stream that the timestamp belongs to\n @param timestamp timestamp to retrieve the index for\n @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond\n                 to the timestamp which is <= the requested one, if backward\n                 is 0, then it will be >=\n              if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise\n @return < 0 if no such timestamp could be found"]
    pub fn av_index_search_timestamp(
        st: *mut AVStream,
        timestamp: i64,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Add an index entry into a sorted list. Update the entry if the list\n already contains it.\n\n @param timestamp timestamp in the time base of the given stream"]
    pub fn av_add_index_entry(
        st: *mut AVStream,
        pos: i64,
        timestamp: i64,
        size: libc::c_int,
        distance: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Split a URL string into components.\n\n The pointers to buffers for storing individual components may be null,\n in order to ignore that component. Buffers for components not found are\n set to empty strings. If the port is not found, it is set to a negative\n value.\n\n @param proto the buffer for the protocol\n @param proto_size the size of the proto buffer\n @param authorization the buffer for the authorization\n @param authorization_size the size of the authorization buffer\n @param hostname the buffer for the host name\n @param hostname_size the size of the hostname buffer\n @param port_ptr a pointer to store the port number in\n @param path the buffer for the path\n @param path_size the size of the path buffer\n @param url the URL to split"]
    pub fn av_url_split(
        proto: *mut libc::c_char,
        proto_size: libc::c_int,
        authorization: *mut libc::c_char,
        authorization_size: libc::c_int,
        hostname: *mut libc::c_char,
        hostname_size: libc::c_int,
        port_ptr: *mut libc::c_int,
        path: *mut libc::c_char,
        path_size: libc::c_int,
        url: *const libc::c_char,
    );
}
extern "C" {
    #[doc = " Print detailed information about the input or output format, such as\n duration, bitrate, streams, container, programs, metadata, side data,\n codec and time base.\n\n @param ic        the context to analyze\n @param index     index of the stream to dump information about\n @param url       the URL to print, such as source or destination file\n @param is_output Select whether the specified context is an input(0) or output(1)"]
    pub fn av_dump_format(
        ic: *mut AVFormatContext,
        index: libc::c_int,
        url: *const libc::c_char,
        is_output: libc::c_int,
    );
}
extern "C" {
    #[doc = " Return in 'buf' the path with '%d' replaced by a number.\n\n Also handles the '%0nd' format where 'n' is the total number\n of digits and '%%'.\n\n @param buf destination buffer\n @param buf_size destination buffer size\n @param path numbered sequence string\n @param number frame number\n @param flags AV_FRAME_FILENAME_FLAGS_*\n @return 0 if OK, -1 on format error"]
    pub fn av_get_frame_filename2(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        path: *const libc::c_char,
        number: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_get_frame_filename(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        path: *const libc::c_char,
        number: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Check whether filename actually is a numbered sequence generator.\n\n @param filename possible numbered sequence string\n @return 1 if a valid numbered sequence string, 0 otherwise"]
    pub fn av_filename_number_test(filename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Generate an SDP for an RTP session.\n\n Note, this overwrites the id values of AVStreams in the muxer contexts\n for getting unique dynamic payload types.\n\n @param ac array of AVFormatContexts describing the RTP streams. If the\n           array is composed by only one context, such context can contain\n           multiple AVStreams (one AVStream per RTP stream). Otherwise,\n           all the contexts in the array (an AVCodecContext per RTP stream)\n           must contain only one AVStream.\n @param n_files number of AVCodecContexts contained in ac\n @param buf buffer where the SDP will be stored (must be allocated by\n            the caller)\n @param size the size of the buffer\n @return 0 if OK, AVERROR_xxx on error"]
    pub fn av_sdp_create(
        ac: *mut *mut AVFormatContext,
        n_files: libc::c_int,
        buf: *mut libc::c_char,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return a positive value if the given filename has one of the given\n extensions, 0 otherwise.\n\n @param filename   file name to check against the given extensions\n @param extensions a comma-separated list of filename extensions"]
    pub fn av_match_ext(
        filename: *const libc::c_char,
        extensions: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Test if the given container can store a codec.\n\n @param ofmt           container to check for compatibility\n @param codec_id       codec to potentially store in container\n @param std_compliance standards compliance level, one of FF_COMPLIANCE_*\n\n @return 1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot.\n         A negative number if this information is not available."]
    pub fn avformat_query_codec(
        ofmt: *const AVOutputFormat,
        codec_id: AVCodecID,
        std_compliance: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @defgroup riff_fourcc RIFF FourCCs\n @{\n Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are\n meant to be passed to av_codec_get_id()/av_codec_get_tag() as in the\n following code:\n @code\n uint32_t tag = MKTAG('H', '2', '6', '4');\n const struct AVCodecTag *table[] = { avformat_get_riff_video_tags(), 0 };\n enum AVCodecID id = av_codec_get_id(table, tag);\n @endcode\n/\n/**\n @return the table mapping RIFF FourCCs for video to libavcodec AVCodecID."]
    pub fn avformat_get_riff_video_tags() -> *const AVCodecTag;
}
extern "C" {
    #[doc = " @return the table mapping RIFF FourCCs for audio to AVCodecID."]
    pub fn avformat_get_riff_audio_tags() -> *const AVCodecTag;
}
extern "C" {
    #[doc = " @return the table mapping MOV FourCCs for video to libavcodec AVCodecID."]
    pub fn avformat_get_mov_video_tags() -> *const AVCodecTag;
}
extern "C" {
    #[doc = " @return the table mapping MOV FourCCs for audio to AVCodecID."]
    pub fn avformat_get_mov_audio_tags() -> *const AVCodecTag;
}
extern "C" {
    #[doc = " Guess the sample aspect ratio of a frame, based on both the stream and the\n frame aspect ratio.\n\n Since the frame aspect ratio is set by the codec but the stream aspect ratio\n is set by the demuxer, these two may not be equal. This function tries to\n return the value that you should use if you would like to display the frame.\n\n Basic logic is to use the stream aspect ratio if it is set to something sane\n otherwise use the frame aspect ratio. This way a container setting, which is\n usually easy to modify can override the coded value in the frames.\n\n @param format the format context which the stream is part of\n @param stream the stream which the frame is part of\n @param frame the frame with the aspect ratio to be determined\n @return the guessed (valid) sample_aspect_ratio, 0/1 if no idea"]
    pub fn av_guess_sample_aspect_ratio(
        format: *mut AVFormatContext,
        stream: *mut AVStream,
        frame: *mut AVFrame,
    ) -> AVRational;
}
extern "C" {
    #[doc = " Guess the frame rate, based on both the container and codec information.\n\n @param ctx the format context which the stream is part of\n @param stream the stream which the frame is part of\n @param frame the frame for which the frame rate should be determined, may be NULL\n @return the guessed (valid) frame rate, 0/1 if no idea"]
    pub fn av_guess_frame_rate(
        ctx: *mut AVFormatContext,
        stream: *mut AVStream,
        frame: *mut AVFrame,
    ) -> AVRational;
}
extern "C" {
    #[doc = " Check if the stream st contained in s is matched by the stream specifier\n spec.\n\n See the \"stream specifiers\" chapter in the documentation for the syntax\n of spec.\n\n @return  >0 if st is matched by spec;\n          0  if st is not matched by spec;\n          AVERROR code if spec is invalid\n\n @note  A stream specifier can match several streams in the format."]
    pub fn avformat_match_stream_specifier(
        s: *mut AVFormatContext,
        st: *mut AVStream,
        spec: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avformat_queue_attached_pictures(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Apply a list of bitstream filters to a packet.\n\n @param codec AVCodecContext, usually from an AVStream\n @param pkt the packet to apply filters to. If, on success, the returned\n        packet has size == 0 and side_data_elems == 0, it indicates that\n        the packet should be dropped\n @param bsfc a NULL-terminated list of filters to apply\n @return  >=0 on success;\n          AVERROR code on failure"]
    pub fn av_apply_bitstream_filters(
        codec: *mut AVCodecContext,
        pkt: *mut AVPacket,
        bsfc: *mut AVBitStreamFilterContext,
    ) -> libc::c_int;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVTimebaseSource {
    AVFMT_TBCF_AUTO = -1,
    AVFMT_TBCF_DECODER = 0,
    AVFMT_TBCF_DEMUXER = 1,
    AVFMT_TBCF_R_FRAMERATE = 2,
}
extern "C" {
    #[doc = " Transfer internal timing information from one stream to another.\n\n This function is useful when doing stream copy.\n\n @param ofmt     target output format for ost\n @param ost      output stream which needs timings copy and adjustments\n @param ist      reference input stream to copy timings from\n @param copy_tb  define from where the stream codec timebase needs to be imported"]
    pub fn avformat_transfer_internal_stream_timing_info(
        ofmt: *const AVOutputFormat,
        ost: *mut AVStream,
        ist: *const AVStream,
        copy_tb: AVTimebaseSource,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the internal codec timebase from a stream.\n\n @param st  input stream to extract the timebase from"]
    pub fn av_stream_get_codec_timebase(st: *const AVStream) -> AVRational;
}
pub type AVAdler = libc::c_ulong;
extern "C" {
    #[doc = " Calculate the Adler32 checksum of a buffer.\n\n Passing the return value to a subsequent av_adler32_update() call\n allows the checksum of multiple buffers to be calculated as though\n they were concatenated.\n\n @param adler initial checksum value\n @param buf   pointer to input buffer\n @param len   size of input buffer\n @return      updated checksum"]
    pub fn av_adler32_update(adler: AVAdler, buf: *const u8, len: libc::c_uint) -> AVAdler;
}
extern "C" {
    #[doc = " @defgroup lavu_aes AES\n @ingroup lavu_crypto\n @{"]
    pub static av_aes_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVAES {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVAES context."]
    pub fn av_aes_alloc() -> *mut AVAES;
}
extern "C" {
    #[doc = " Initialize an AVAES context.\n @param key_bits 128, 192 or 256\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_aes_init(
        a: *mut AVAES,
        key: *const u8,
        key_bits: libc::c_int,
        decrypt: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context.\n @param count number of 16 byte blocks\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param iv initialization vector for CBC mode, if NULL then ECB will be used\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_aes_crypt(
        a: *mut AVAES,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFifoBuffer {
    pub buffer: *mut u8,
    pub rptr: *mut u8,
    pub wptr: *mut u8,
    pub end: *mut u8,
    pub rndx: u32,
    pub wndx: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVFifoBuffer"][::std::mem::size_of::<AVFifoBuffer>() - 40usize];
    ["Alignment of AVFifoBuffer"][::std::mem::align_of::<AVFifoBuffer>() - 8usize];
    ["Offset of field: AVFifoBuffer::buffer"]
        [::std::mem::offset_of!(AVFifoBuffer, buffer) - 0usize];
    ["Offset of field: AVFifoBuffer::rptr"][::std::mem::offset_of!(AVFifoBuffer, rptr) - 8usize];
    ["Offset of field: AVFifoBuffer::wptr"][::std::mem::offset_of!(AVFifoBuffer, wptr) - 16usize];
    ["Offset of field: AVFifoBuffer::end"][::std::mem::offset_of!(AVFifoBuffer, end) - 24usize];
    ["Offset of field: AVFifoBuffer::rndx"][::std::mem::offset_of!(AVFifoBuffer, rndx) - 32usize];
    ["Offset of field: AVFifoBuffer::wndx"][::std::mem::offset_of!(AVFifoBuffer, wndx) - 36usize];
};
extern "C" {
    #[doc = " Initialize an AVFifoBuffer.\n @param size of FIFO\n @return AVFifoBuffer or NULL in case of memory allocation failure"]
    pub fn av_fifo_alloc(size: libc::c_uint) -> *mut AVFifoBuffer;
}
extern "C" {
    #[doc = " Initialize an AVFifoBuffer.\n @param nmemb number of elements\n @param size  size of the single element\n @return AVFifoBuffer or NULL in case of memory allocation failure"]
    pub fn av_fifo_alloc_array(nmemb: usize, size: usize) -> *mut AVFifoBuffer;
}
extern "C" {
    #[doc = " Free an AVFifoBuffer.\n @param f AVFifoBuffer to free"]
    pub fn av_fifo_free(f: *mut AVFifoBuffer);
}
extern "C" {
    #[doc = " Free an AVFifoBuffer and reset pointer to NULL.\n @param f AVFifoBuffer to free"]
    pub fn av_fifo_freep(f: *mut *mut AVFifoBuffer);
}
extern "C" {
    #[doc = " Reset the AVFifoBuffer to the state right after av_fifo_alloc, in particular it is emptied.\n @param f AVFifoBuffer to reset"]
    pub fn av_fifo_reset(f: *mut AVFifoBuffer);
}
extern "C" {
    #[doc = " Return the amount of data in bytes in the AVFifoBuffer, that is the\n amount of data you can read from it.\n @param f AVFifoBuffer to read from\n @return size"]
    pub fn av_fifo_size(f: *const AVFifoBuffer) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the amount of space in bytes in the AVFifoBuffer, that is the\n amount of data you can write into it.\n @param f AVFifoBuffer to write into\n @return size"]
    pub fn av_fifo_space(f: *const AVFifoBuffer) -> libc::c_int;
}
extern "C" {
    #[doc = " Feed data at specific position from an AVFifoBuffer to a user-supplied callback.\n Similar as av_fifo_gereric_read but without discarding data.\n @param f AVFifoBuffer to read from\n @param offset offset from current read position\n @param buf_size number of bytes to read\n @param func generic read function\n @param dest data destination"]
    pub fn av_fifo_generic_peek_at(
        f: *mut AVFifoBuffer,
        dest: *mut libc::c_void,
        offset: libc::c_int,
        buf_size: libc::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *mut libc::c_void,
                arg3: libc::c_int,
            ),
        >,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Feed data from an AVFifoBuffer to a user-supplied callback.\n Similar as av_fifo_gereric_read but without discarding data.\n @param f AVFifoBuffer to read from\n @param buf_size number of bytes to read\n @param func generic read function\n @param dest data destination"]
    pub fn av_fifo_generic_peek(
        f: *mut AVFifoBuffer,
        dest: *mut libc::c_void,
        buf_size: libc::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *mut libc::c_void,
                arg3: libc::c_int,
            ),
        >,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Feed data from an AVFifoBuffer to a user-supplied callback.\n @param f AVFifoBuffer to read from\n @param buf_size number of bytes to read\n @param func generic read function\n @param dest data destination"]
    pub fn av_fifo_generic_read(
        f: *mut AVFifoBuffer,
        dest: *mut libc::c_void,
        buf_size: libc::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *mut libc::c_void,
                arg3: libc::c_int,
            ),
        >,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Feed data from a user-supplied callback to an AVFifoBuffer.\n @param f AVFifoBuffer to write to\n @param src data source; non-const since it may be used as a\n modifiable context by the function defined in func\n @param size number of bytes to write\n @param func generic write function; the first parameter is src,\n the second is dest_buf, the third is dest_buf_size.\n func must return the number of bytes written to dest_buf, or <= 0 to\n indicate no more data available to write.\n If func is NULL, src is interpreted as a simple byte array for source data.\n @return the number of bytes written to the FIFO"]
    pub fn av_fifo_generic_write(
        f: *mut AVFifoBuffer,
        src: *mut libc::c_void,
        size: libc::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *mut libc::c_void,
                arg3: libc::c_int,
            ) -> libc::c_int,
        >,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Resize an AVFifoBuffer.\n In case of reallocation failure, the old FIFO is kept unchanged.\n\n @param f AVFifoBuffer to resize\n @param size new AVFifoBuffer size in bytes\n @return <0 for failure, >=0 otherwise"]
    pub fn av_fifo_realloc2(f: *mut AVFifoBuffer, size: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " Enlarge an AVFifoBuffer.\n In case of reallocation failure, the old FIFO is kept unchanged.\n The new fifo size may be larger than the requested size.\n\n @param f AVFifoBuffer to resize\n @param additional_space the amount of space in bytes to allocate in addition to av_fifo_size()\n @return <0 for failure, >=0 otherwise"]
    pub fn av_fifo_grow(f: *mut AVFifoBuffer, additional_space: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " Read and discard the specified amount of data from an AVFifoBuffer.\n @param f AVFifoBuffer to read from\n @param size amount of data to read in bytes"]
    pub fn av_fifo_drain(f: *mut AVFifoBuffer, size: libc::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVAudioFifo {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Free an AVAudioFifo.\n\n @param af  AVAudioFifo to free"]
    pub fn av_audio_fifo_free(af: *mut AVAudioFifo);
}
extern "C" {
    #[doc = " Allocate an AVAudioFifo.\n\n @param sample_fmt  sample format\n @param channels    number of channels\n @param nb_samples  initial allocation size, in samples\n @return            newly allocated AVAudioFifo, or NULL on error"]
    pub fn av_audio_fifo_alloc(
        sample_fmt: AVSampleFormat,
        channels: libc::c_int,
        nb_samples: libc::c_int,
    ) -> *mut AVAudioFifo;
}
extern "C" {
    #[doc = " Reallocate an AVAudioFifo.\n\n @param af          AVAudioFifo to reallocate\n @param nb_samples  new allocation size, in samples\n @return            0 if OK, or negative AVERROR code on failure"]
    pub fn av_audio_fifo_realloc(af: *mut AVAudioFifo, nb_samples: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Write data to an AVAudioFifo.\n\n The AVAudioFifo will be reallocated automatically if the available space\n is less than nb_samples.\n\n @see enum AVSampleFormat\n The documentation for AVSampleFormat describes the data layout.\n\n @param af          AVAudioFifo to write to\n @param data        audio data plane pointers\n @param nb_samples  number of samples to write\n @return            number of samples actually written, or negative AVERROR\n                    code on failure. If successful, the number of samples\n                    actually written will always be nb_samples."]
    pub fn av_audio_fifo_write(
        af: *mut AVAudioFifo,
        data: *mut *mut libc::c_void,
        nb_samples: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Peek data from an AVAudioFifo.\n\n @see enum AVSampleFormat\n The documentation for AVSampleFormat describes the data layout.\n\n @param af          AVAudioFifo to read from\n @param data        audio data plane pointers\n @param nb_samples  number of samples to peek\n @return            number of samples actually peek, or negative AVERROR code\n                    on failure. The number of samples actually peek will not\n                    be greater than nb_samples, and will only be less than\n                    nb_samples if av_audio_fifo_size is less than nb_samples."]
    pub fn av_audio_fifo_peek(
        af: *mut AVAudioFifo,
        data: *mut *mut libc::c_void,
        nb_samples: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Peek data from an AVAudioFifo.\n\n @see enum AVSampleFormat\n The documentation for AVSampleFormat describes the data layout.\n\n @param af          AVAudioFifo to read from\n @param data        audio data plane pointers\n @param nb_samples  number of samples to peek\n @param offset      offset from current read position\n @return            number of samples actually peek, or negative AVERROR code\n                    on failure. The number of samples actually peek will not\n                    be greater than nb_samples, and will only be less than\n                    nb_samples if av_audio_fifo_size is less than nb_samples."]
    pub fn av_audio_fifo_peek_at(
        af: *mut AVAudioFifo,
        data: *mut *mut libc::c_void,
        nb_samples: libc::c_int,
        offset: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read data from an AVAudioFifo.\n\n @see enum AVSampleFormat\n The documentation for AVSampleFormat describes the data layout.\n\n @param af          AVAudioFifo to read from\n @param data        audio data plane pointers\n @param nb_samples  number of samples to read\n @return            number of samples actually read, or negative AVERROR code\n                    on failure. The number of samples actually read will not\n                    be greater than nb_samples, and will only be less than\n                    nb_samples if av_audio_fifo_size is less than nb_samples."]
    pub fn av_audio_fifo_read(
        af: *mut AVAudioFifo,
        data: *mut *mut libc::c_void,
        nb_samples: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Drain data from an AVAudioFifo.\n\n Removes the data without reading it.\n\n @param af          AVAudioFifo to drain\n @param nb_samples  number of samples to drain\n @return            0 if OK, or negative AVERROR code on failure"]
    pub fn av_audio_fifo_drain(af: *mut AVAudioFifo, nb_samples: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Reset the AVAudioFifo buffer.\n\n This empties all data in the buffer.\n\n @param af  AVAudioFifo to reset"]
    pub fn av_audio_fifo_reset(af: *mut AVAudioFifo);
}
extern "C" {
    #[doc = " Get the current number of samples in the AVAudioFifo available for reading.\n\n @param af  the AVAudioFifo to query\n @return    number of samples available for reading"]
    pub fn av_audio_fifo_size(af: *mut AVAudioFifo) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the current number of samples in the AVAudioFifo available for writing.\n\n @param af  the AVAudioFifo to query\n @return    number of samples available for writing"]
    pub fn av_audio_fifo_space(af: *mut AVAudioFifo) -> libc::c_int;
}
extern "C" {
    #[doc = " Decode a base64-encoded string.\n\n @param out      buffer for decoded data\n @param in       null-terminated input string\n @param out_size size in bytes of the out buffer, must be at\n                 least 3/4 of the length of in, that is AV_BASE64_DECODE_SIZE(strlen(in))\n @return         number of bytes written, or a negative value in case of\n                 invalid input"]
    pub fn av_base64_decode(
        out: *mut u8,
        in_: *const libc::c_char,
        out_size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Encode data to base64 and null-terminate.\n\n @param out      buffer for encoded data\n @param out_size size in bytes of the out buffer (including the\n                 null terminator), must be at least AV_BASE64_SIZE(in_size)\n @param in       input buffer containing the data to encode\n @param in_size  size in bytes of the in buffer\n @return         out or NULL in case of error"]
    pub fn av_base64_encode(
        out: *mut libc::c_char,
        out_size: libc::c_int,
        in_: *const u8,
        in_size: libc::c_int,
    ) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVBlowfish {
    pub p: [u32; 18usize],
    pub s: [[u32; 256usize]; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVBlowfish"][::std::mem::size_of::<AVBlowfish>() - 4168usize];
    ["Alignment of AVBlowfish"][::std::mem::align_of::<AVBlowfish>() - 4usize];
    ["Offset of field: AVBlowfish::p"][::std::mem::offset_of!(AVBlowfish, p) - 0usize];
    ["Offset of field: AVBlowfish::s"][::std::mem::offset_of!(AVBlowfish, s) - 72usize];
};
extern "C" {
    #[doc = " Allocate an AVBlowfish context."]
    pub fn av_blowfish_alloc() -> *mut AVBlowfish;
}
extern "C" {
    #[doc = " Initialize an AVBlowfish context.\n\n @param ctx an AVBlowfish context\n @param key a key\n @param key_len length of the key"]
    pub fn av_blowfish_init(ctx: *mut AVBlowfish, key: *const u8, key_len: libc::c_int);
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context.\n\n @param ctx an AVBlowfish context\n @param xl left four bytes halves of input to be encrypted\n @param xr right four bytes halves of input to be encrypted\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_blowfish_crypt_ecb(
        ctx: *mut AVBlowfish,
        xl: *mut u32,
        xr: *mut u32,
        decrypt: libc::c_int,
    );
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context.\n\n @param ctx an AVBlowfish context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param count number of 8 byte blocks\n @param iv initialization vector for CBC mode, if NULL ECB will be used\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_blowfish_crypt(
        ctx: *mut AVBlowfish,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
extern "C" {
    #[doc = " Return non-zero if pfx is a prefix of str. If it is, *ptr is set to\n the address of the first character in str after the prefix.\n\n @param str input string\n @param pfx prefix to test\n @param ptr updated if the prefix is matched inside str\n @return non-zero if the prefix matches, zero otherwise"]
    pub fn av_strstart(
        str_: *const libc::c_char,
        pfx: *const libc::c_char,
        ptr: *mut *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return non-zero if pfx is a prefix of str independent of case. If\n it is, *ptr is set to the address of the first character in str\n after the prefix.\n\n @param str input string\n @param pfx prefix to test\n @param ptr updated if the prefix is matched inside str\n @return non-zero if the prefix matches, zero otherwise"]
    pub fn av_stristart(
        str_: *const libc::c_char,
        pfx: *const libc::c_char,
        ptr: *mut *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Locate the first case-independent occurrence in the string haystack\n of the string needle.  A zero-length string needle is considered to\n match at the start of haystack.\n\n This function is a case-insensitive version of the standard strstr().\n\n @param haystack string to search in\n @param needle   string to search for\n @return         pointer to the located match within haystack\n                 or a null pointer if no match"]
    pub fn av_stristr(
        haystack: *const libc::c_char,
        needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Locate the first occurrence of the string needle in the string haystack\n where not more than hay_length characters are searched. A zero-length\n string needle is considered to match at the start of haystack.\n\n This function is a length-limited version of the standard strstr().\n\n @param haystack   string to search in\n @param needle     string to search for\n @param hay_length length of string to search in\n @return           pointer to the located match within haystack\n                   or a null pointer if no match"]
    pub fn av_strnstr(
        haystack: *const libc::c_char,
        needle: *const libc::c_char,
        hay_length: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Copy the string src to dst, but no more than size - 1 bytes, and\n null-terminate dst.\n\n This function is the same as BSD strlcpy().\n\n @param dst destination buffer\n @param src source string\n @param size size of destination buffer\n @return the length of src\n\n @warning since the return value is the length of src, src absolutely\n _must_ be a properly 0-terminated string, otherwise this will read beyond\n the end of the buffer and possibly crash."]
    pub fn av_strlcpy(dst: *mut libc::c_char, src: *const libc::c_char, size: usize) -> usize;
}
extern "C" {
    #[doc = " Append the string src to the string dst, but to a total length of\n no more than size - 1 bytes, and null-terminate dst.\n\n This function is similar to BSD strlcat(), but differs when\n size <= strlen(dst).\n\n @param dst destination buffer\n @param src source string\n @param size size of destination buffer\n @return the total length of src and dst\n\n @warning since the return value use the length of src and dst, these\n absolutely _must_ be a properly 0-terminated strings, otherwise this\n will read beyond the end of the buffer and possibly crash."]
    pub fn av_strlcat(dst: *mut libc::c_char, src: *const libc::c_char, size: usize) -> usize;
}
extern "C" {
    #[doc = " Append output to a string, according to a format. Never write out of\n the destination buffer, and always put a terminating 0 within\n the buffer.\n @param dst destination buffer (string to which the output is\n  appended)\n @param size total size of the destination buffer\n @param fmt printf-compatible format string, specifying how the\n  following parameters are used\n @return the length of the string that would have been generated\n  if enough space had been available"]
    pub fn av_strlcatf(dst: *mut libc::c_char, size: usize, fmt: *const libc::c_char, ...)
        -> usize;
}
extern "C" {
    #[doc = " Print arguments following specified format into a large enough auto\n allocated buffer. It is similar to GNU asprintf().\n @param fmt printf-compatible format string, specifying how the\n            following parameters are used.\n @return the allocated string\n @note You have to free the string yourself with av_free()."]
    pub fn av_asprintf(fmt: *const libc::c_char, ...) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Convert a number to an av_malloced string.\n @deprecated  use av_asprintf() with \"%f\" or a more specific format"]
    pub fn av_d2str(d: f64) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Unescape the given string until a non escaped terminating char,\n and return the token corresponding to the unescaped string.\n\n The normal \\ and ' escaping is supported. Leading and trailing\n whitespaces are removed, unless they are escaped with '\\' or are\n enclosed between ''.\n\n @param buf the buffer to parse, buf will be updated to point to the\n terminating char\n @param term a 0-terminated list of terminating chars\n @return the malloced unescaped string, which must be av_freed by\n the user, NULL in case of allocation failure"]
    pub fn av_get_token(
        buf: *mut *const libc::c_char,
        term: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Split the string into several tokens which can be accessed by\n successive calls to av_strtok().\n\n A token is defined as a sequence of characters not belonging to the\n set specified in delim.\n\n On the first call to av_strtok(), s should point to the string to\n parse, and the value of saveptr is ignored. In subsequent calls, s\n should be NULL, and saveptr should be unchanged since the previous\n call.\n\n This function is similar to strtok_r() defined in POSIX.1.\n\n @param s the string to parse, may be NULL\n @param delim 0-terminated list of token delimiters, must be non-NULL\n @param saveptr user-provided pointer which points to stored\n information necessary for av_strtok() to continue scanning the same\n string. saveptr is updated to point to the next character after the\n first delimiter found, or to NULL if the string was terminated\n @return the found token, or NULL when no token is found"]
    pub fn av_strtok(
        s: *mut libc::c_char,
        delim: *const libc::c_char,
        saveptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Locale-independent case-insensitive compare.\n @note This means only ASCII-range characters are case-insensitive"]
    pub fn av_strcasecmp(a: *const libc::c_char, b: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Locale-independent case-insensitive compare.\n @note This means only ASCII-range characters are case-insensitive"]
    pub fn av_strncasecmp(a: *const libc::c_char, b: *const libc::c_char, n: usize) -> libc::c_int;
}
extern "C" {
    #[doc = " Locale-independent strings replace.\n @note This means only ASCII-range characters are replace"]
    pub fn av_strireplace(
        str_: *const libc::c_char,
        from: *const libc::c_char,
        to: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Thread safe basename.\n @param path the string to parse, on DOS both \\ and / are considered separators.\n @return pointer to the basename substring.\n If path does not contain a slash, the function returns a copy of path.\n If path is a NULL pointer or points to an empty string, a pointer\n to a string \".\" is returned."]
    pub fn av_basename(path: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Thread safe dirname.\n @param path the string to parse, on DOS both \\ and / are considered separators.\n @return A pointer to a string that's the parent directory of path.\n If path is a NULL pointer or points to an empty string, a pointer\n to a string \".\" is returned.\n @note the function may modify the contents of the path, so copies should be passed."]
    pub fn av_dirname(path: *mut libc::c_char) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Match instances of a name in a comma-separated list of names.\n List entries are checked from the start to the end of the names list,\n the first match ends further processing. If an entry prefixed with '-'\n matches, then 0 is returned. The \"ALL\" list entry is considered to\n match all names.\n\n @param name  Name to look for.\n @param names List of names.\n @return 1 on match, 0 otherwise."]
    pub fn av_match_name(name: *const libc::c_char, names: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Append path component to the existing path.\n Path separator '/' is placed between when needed.\n Resulting string have to be freed with av_free().\n @param path      base path\n @param component component to be appended\n @return new path or NULL on error."]
    pub fn av_append_path_component(
        path: *const libc::c_char,
        component: *const libc::c_char,
    ) -> *mut libc::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVEscapeMode {
    #[doc = "< Use auto-selected escaping mode."]
    AV_ESCAPE_MODE_AUTO = 0,
    #[doc = "< Use backslash escaping."]
    AV_ESCAPE_MODE_BACKSLASH = 1,
    #[doc = "< Use single-quote escaping."]
    AV_ESCAPE_MODE_QUOTE = 2,
    #[doc = "< Use XML non-markup character data escaping."]
    AV_ESCAPE_MODE_XML = 3,
}
extern "C" {
    #[doc = " Escape string in src, and put the escaped string in an allocated\n string in *dst, which must be freed with av_free().\n\n @param dst           pointer where an allocated string is put\n @param src           string to escape, must be non-NULL\n @param special_chars string containing the special characters which\n                      need to be escaped, can be NULL\n @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.\n                      Any unknown value for mode will be considered equivalent to\n                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without\n                      notice.\n @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_ macros\n @return the length of the allocated string, or a negative error code in case of error\n @see av_bprint_escape()"]
    pub fn av_escape(
        dst: *mut *mut libc::c_char,
        src: *const libc::c_char,
        special_chars: *const libc::c_char,
        mode: AVEscapeMode,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read and decode a single UTF-8 code point (character) from the\n buffer in *buf, and update *buf to point to the next byte to\n decode.\n\n In case of an invalid byte sequence, the pointer will be updated to\n the next byte after the invalid sequence and the function will\n return an error code.\n\n Depending on the specified flags, the function will also fail in\n case the decoded code point does not belong to a valid range.\n\n @note For speed-relevant code a carefully implemented use of\n GET_UTF8() may be preferred.\n\n @param codep   pointer used to return the parsed code in case of success.\n                The value in *codep is set even in case the range check fails.\n @param bufp    pointer to the address the first byte of the sequence\n                to decode, updated by the function to point to the\n                byte next after the decoded sequence\n @param buf_end pointer to the end of the buffer, points to the next\n                byte past the last in the buffer. This is used to\n                avoid buffer overreads (in case of an unfinished\n                UTF-8 sequence towards the end of the buffer).\n @param flags   a collection of AV_UTF8_FLAG_* flags\n @return >= 0 in case a sequence was successfully read, a negative\n value in case of invalid sequence"]
    pub fn av_utf8_decode(
        codep: *mut i32,
        bufp: *mut *const u8,
        buf_end: *const u8,
        flags: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Check if a name is in a list.\n @returns 0 if not found, or the 1 based index where it has been found in the\n            list."]
    pub fn av_match_list(
        name: *const libc::c_char,
        list: *const libc::c_char,
        separator: libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " See libc sscanf manual for more information.\n Locale-independent sscanf implementation."]
    pub fn av_sscanf(string: *const libc::c_char, format: *const libc::c_char, ...) -> libc::c_int;
}
#[doc = " Buffer to print data progressively\n\n The string buffer grows as necessary and is always 0-terminated.\n The content of the string is never accessed, and thus is\n encoding-agnostic and can even hold binary data.\n\n Small buffers are kept in the structure itself, and thus require no\n memory allocation at all (unless the contents of the buffer is needed\n after the structure goes out of scope). This is almost as lightweight as\n declaring a local \"char buf[512]\".\n\n The length of the string can go beyond the allocated size: the buffer is\n then truncated, but the functions still keep account of the actual total\n length.\n\n In other words, buf->len can be greater than buf->size and records the\n total length of what would have been to the buffer if there had been\n enough memory.\n\n Append operations do not need to be tested for failure: if a memory\n allocation fails, data stop being appended to the buffer, but the length\n is still updated. This situation can be tested with\n av_bprint_is_complete().\n\n The size_max field determines several possible behaviours:\n\n size_max = -1 (= UINT_MAX) or any large value will let the buffer be\n reallocated as necessary, with an amortized linear cost.\n\n size_max = 0 prevents writing anything to the buffer: only the total\n length is computed. The write operations can then possibly be repeated in\n a buffer with exactly the necessary size\n (using size_init = size_max = len + 1).\n\n size_max = 1 is automatically replaced by the exact size available in the\n structure itself, thus ensuring no dynamic memory allocation. The\n internal buffer is large enough to hold a reasonable paragraph of text,\n such as the current paragraph."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ff_pad_helper_AVBPrint {
    #[doc = "< string so far"]
    pub str_: *mut libc::c_char,
    #[doc = "< length so far"]
    pub len: libc::c_uint,
    #[doc = "< allocated memory"]
    pub size: libc::c_uint,
    #[doc = "< maximum allocated memory"]
    pub size_max: libc::c_uint,
    pub reserved_internal_buffer: [libc::c_char; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ff_pad_helper_AVBPrint"][::std::mem::size_of::<ff_pad_helper_AVBPrint>() - 24usize];
    ["Alignment of ff_pad_helper_AVBPrint"]
        [::std::mem::align_of::<ff_pad_helper_AVBPrint>() - 8usize];
    ["Offset of field: ff_pad_helper_AVBPrint::str_"]
        [::std::mem::offset_of!(ff_pad_helper_AVBPrint, str_) - 0usize];
    ["Offset of field: ff_pad_helper_AVBPrint::len"]
        [::std::mem::offset_of!(ff_pad_helper_AVBPrint, len) - 8usize];
    ["Offset of field: ff_pad_helper_AVBPrint::size"]
        [::std::mem::offset_of!(ff_pad_helper_AVBPrint, size) - 12usize];
    ["Offset of field: ff_pad_helper_AVBPrint::size_max"]
        [::std::mem::offset_of!(ff_pad_helper_AVBPrint, size_max) - 16usize];
    ["Offset of field: ff_pad_helper_AVBPrint::reserved_internal_buffer"]
        [::std::mem::offset_of!(ff_pad_helper_AVBPrint, reserved_internal_buffer) - 20usize];
};
#[doc = " Buffer to print data progressively\n\n The string buffer grows as necessary and is always 0-terminated.\n The content of the string is never accessed, and thus is\n encoding-agnostic and can even hold binary data.\n\n Small buffers are kept in the structure itself, and thus require no\n memory allocation at all (unless the contents of the buffer is needed\n after the structure goes out of scope). This is almost as lightweight as\n declaring a local \"char buf[512]\".\n\n The length of the string can go beyond the allocated size: the buffer is\n then truncated, but the functions still keep account of the actual total\n length.\n\n In other words, buf->len can be greater than buf->size and records the\n total length of what would have been to the buffer if there had been\n enough memory.\n\n Append operations do not need to be tested for failure: if a memory\n allocation fails, data stop being appended to the buffer, but the length\n is still updated. This situation can be tested with\n av_bprint_is_complete().\n\n The size_max field determines several possible behaviours:\n\n size_max = -1 (= UINT_MAX) or any large value will let the buffer be\n reallocated as necessary, with an amortized linear cost.\n\n size_max = 0 prevents writing anything to the buffer: only the total\n length is computed. The write operations can then possibly be repeated in\n a buffer with exactly the necessary size\n (using size_init = size_max = len + 1).\n\n size_max = 1 is automatically replaced by the exact size available in the\n structure itself, thus ensuring no dynamic memory allocation. The\n internal buffer is large enough to hold a reasonable paragraph of text,\n such as the current paragraph."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVBPrint {
    #[doc = "< string so far"]
    pub str_: *mut libc::c_char,
    #[doc = "< length so far"]
    pub len: libc::c_uint,
    #[doc = "< allocated memory"]
    pub size: libc::c_uint,
    #[doc = "< maximum allocated memory"]
    pub size_max: libc::c_uint,
    pub reserved_internal_buffer: [libc::c_char; 1usize],
    pub reserved_padding: [libc::c_char; 1000usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVBPrint"][::std::mem::size_of::<AVBPrint>() - 1024usize];
    ["Alignment of AVBPrint"][::std::mem::align_of::<AVBPrint>() - 8usize];
    ["Offset of field: AVBPrint::str_"][::std::mem::offset_of!(AVBPrint, str_) - 0usize];
    ["Offset of field: AVBPrint::len"][::std::mem::offset_of!(AVBPrint, len) - 8usize];
    ["Offset of field: AVBPrint::size"][::std::mem::offset_of!(AVBPrint, size) - 12usize];
    ["Offset of field: AVBPrint::size_max"][::std::mem::offset_of!(AVBPrint, size_max) - 16usize];
    ["Offset of field: AVBPrint::reserved_internal_buffer"]
        [::std::mem::offset_of!(AVBPrint, reserved_internal_buffer) - 20usize];
    ["Offset of field: AVBPrint::reserved_padding"]
        [::std::mem::offset_of!(AVBPrint, reserved_padding) - 21usize];
};
extern "C" {
    #[doc = " Init a print buffer.\n\n @param buf        buffer to init\n @param size_init  initial size (including the final 0)\n @param size_max   maximum size;\n                   0 means do not write anything, just count the length;\n                   1 is replaced by the maximum value for automatic storage;\n                   any large value means that the internal buffer will be\n                   reallocated as needed up to that limit; -1 is converted to\n                   UINT_MAX, the largest limit possible.\n                   Check also AV_BPRINT_SIZE_* macros."]
    pub fn av_bprint_init(buf: *mut AVBPrint, size_init: libc::c_uint, size_max: libc::c_uint);
}
extern "C" {
    #[doc = " Init a print buffer using a pre-existing buffer.\n\n The buffer will not be reallocated.\n\n @param buf     buffer structure to init\n @param buffer  byte buffer to use for the string data\n @param size    size of buffer"]
    pub fn av_bprint_init_for_buffer(
        buf: *mut AVBPrint,
        buffer: *mut libc::c_char,
        size: libc::c_uint,
    );
}
extern "C" {
    #[doc = " Append a formatted string to a print buffer."]
    pub fn av_bprintf(buf: *mut AVBPrint, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Append a formatted string to a print buffer."]
    pub fn av_vbprintf(buf: *mut AVBPrint, fmt: *const libc::c_char, vl_arg: *mut __va_list_tag);
}
extern "C" {
    #[doc = " Append char c n times to a print buffer."]
    pub fn av_bprint_chars(buf: *mut AVBPrint, c: libc::c_char, n: libc::c_uint);
}
extern "C" {
    #[doc = " Append data to a print buffer.\n\n param buf  bprint buffer to use\n param data pointer to data\n param size size of data"]
    pub fn av_bprint_append_data(buf: *mut AVBPrint, data: *const libc::c_char, size: libc::c_uint);
}
extern "C" {
    #[doc = " Append a formatted date and time to a print buffer.\n\n param buf  bprint buffer to use\n param fmt  date and time format string, see strftime()\n param tm   broken-down time structure to translate\n\n @note due to poor design of the standard strftime function, it may\n produce poor results if the format string expands to a very long text and\n the bprint buffer is near the limit stated by the size_max option."]
    pub fn av_bprint_strftime(buf: *mut AVBPrint, fmt: *const libc::c_char, tm: *const tm);
}
extern "C" {
    #[doc = " Allocate bytes in the buffer for external use.\n\n @param[in]  buf          buffer structure\n @param[in]  size         required size\n @param[out] mem          pointer to the memory area\n @param[out] actual_size  size of the memory area after allocation;\n                          can be larger or smaller than size"]
    pub fn av_bprint_get_buffer(
        buf: *mut AVBPrint,
        size: libc::c_uint,
        mem: *mut *mut libc::c_uchar,
        actual_size: *mut libc::c_uint,
    );
}
extern "C" {
    #[doc = " Reset the string to \"\" but keep internal allocated data."]
    pub fn av_bprint_clear(buf: *mut AVBPrint);
}
extern "C" {
    #[doc = " Finalize a print buffer.\n\n The print buffer can no longer be used afterwards,\n but the len and size fields are still valid.\n\n @arg[out] ret_str  if not NULL, used to return a permanent copy of the\n                    buffer contents, or NULL if memory allocation fails;\n                    if NULL, the buffer is discarded and freed\n @return  0 for success or error code (probably AVERROR(ENOMEM))"]
    pub fn av_bprint_finalize(buf: *mut AVBPrint, ret_str: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Escape the content in src and append it to dstbuf.\n\n @param dstbuf        already inited destination bprint buffer\n @param src           string containing the text to escape\n @param special_chars string containing the special characters which\n                      need to be escaped, can be NULL\n @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.\n                      Any unknown value for mode will be considered equivalent to\n                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without\n                      notice.\n @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_* macros"]
    pub fn av_bprint_escape(
        dstbuf: *mut AVBPrint,
        src: *const libc::c_char,
        special_chars: *const libc::c_char,
        mode: AVEscapeMode,
        flags: libc::c_int,
    );
}
extern "C" {
    #[doc = " @file\n @brief Public header for libavutil CAMELLIA algorithm\n @defgroup lavu_camellia CAMELLIA\n @ingroup lavu_crypto\n @{"]
    pub static av_camellia_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCAMELLIA {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVCAMELLIA context\n To free the struct: av_free(ptr)"]
    pub fn av_camellia_alloc() -> *mut AVCAMELLIA;
}
extern "C" {
    #[doc = " Initialize an AVCAMELLIA context.\n\n @param ctx an AVCAMELLIA context\n @param key a key of 16, 24, 32 bytes used for encryption/decryption\n @param key_bits number of keybits: possible are 128, 192, 256"]
    pub fn av_camellia_init(
        ctx: *mut AVCAMELLIA,
        key: *const u8,
        key_bits: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context\n\n @param ctx an AVCAMELLIA context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param count number of 16 byte blocks\n @paran iv initialization vector for CBC mode, NULL for ECB mode\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_camellia_crypt(
        ctx: *mut AVCAMELLIA,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
extern "C" {
    #[doc = " @file\n @brief Public header for libavutil CAST5 algorithm\n @defgroup lavu_cast5 CAST5\n @ingroup lavu_crypto\n @{"]
    pub static av_cast5_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCAST5 {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVCAST5 context\n To free the struct: av_free(ptr)"]
    pub fn av_cast5_alloc() -> *mut AVCAST5;
}
extern "C" {
    #[doc = " Initialize an AVCAST5 context.\n\n @param ctx an AVCAST5 context\n @param key a key of 5,6,...16 bytes used for encryption/decryption\n @param key_bits number of keybits: possible are 40,48,...,128\n @return 0 on success, less than 0 on failure"]
    pub fn av_cast5_init(ctx: *mut AVCAST5, key: *const u8, key_bits: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context, ECB mode only\n\n @param ctx an AVCAST5 context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param count number of 8 byte blocks\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_cast5_crypt(
        ctx: *mut AVCAST5,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        decrypt: libc::c_int,
    );
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context\n\n @param ctx an AVCAST5 context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param count number of 8 byte blocks\n @param iv initialization vector for CBC mode, NULL for ECB mode\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_cast5_crypt2(
        ctx: *mut AVCAST5,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
#[doc = " @defgroup lavu_crc32 CRC\n @ingroup lavu_hash\n CRC (Cyclic Redundancy Check) hash function implementation.\n\n This module supports numerous CRC polynomials, in addition to the most\n widely used CRC-32-IEEE. See @ref AVCRCId for a list of available\n polynomials.\n\n @{"]
pub type AVCRC = u32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVCRCId {
    AV_CRC_8_ATM = 0,
    AV_CRC_16_ANSI = 1,
    AV_CRC_16_CCITT = 2,
    AV_CRC_32_IEEE = 3,
    AV_CRC_32_IEEE_LE = 4,
    AV_CRC_16_ANSI_LE = 5,
    AV_CRC_24_IEEE = 6,
    AV_CRC_8_EBU = 7,
    AV_CRC_MAX = 8,
}
extern "C" {
    #[doc = " Initialize a CRC table.\n @param ctx must be an array of size sizeof(AVCRC)*257 or sizeof(AVCRC)*1024\n @param le If 1, the lowest bit represents the coefficient for the highest\n           exponent of the corresponding polynomial (both for poly and\n           actual CRC).\n           If 0, you must swap the CRC parameter and the result of av_crc\n           if you need the standard representation (can be simplified in\n           most cases to e.g. bswap16):\n           av_bswap32(crc << (32-bits))\n @param bits number of bits for the CRC\n @param poly generator polynomial without the x**bits coefficient, in the\n             representation as specified by le\n @param ctx_size size of ctx in bytes\n @return <0 on failure"]
    pub fn av_crc_init(
        ctx: *mut AVCRC,
        le: libc::c_int,
        bits: libc::c_int,
        poly: u32,
        ctx_size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get an initialized standard CRC table.\n @param crc_id ID of a standard CRC\n @return a pointer to the CRC table or NULL on failure"]
    pub fn av_crc_get_table(crc_id: AVCRCId) -> *const AVCRC;
}
extern "C" {
    #[doc = " Calculate the CRC of a block.\n @param crc CRC of previous blocks if any or initial value for CRC\n @return CRC updated with the data from the given block\n\n @see av_crc_init() \"le\" parameter"]
    pub fn av_crc(ctx: *const AVCRC, crc: u32, buffer: *const u8, length: usize) -> u32;
}
extern "C" {
    #[doc = " Extract the rotation component of the transformation matrix.\n\n @param matrix the transformation matrix\n @return the angle (in degrees) by which the transformation rotates the frame\n         counterclockwise. The angle will be in range [-180.0, 180.0],\n         or NaN if the matrix is singular.\n\n @note floating point numbers are inherently inexact, so callers are\n       recommended to round the return value to nearest integer before use."]
    pub fn av_display_rotation_get(matrix: *const i32) -> f64;
}
extern "C" {
    #[doc = " Initialize a transformation matrix describing a pure counterclockwise\n rotation by the specified angle (in degrees).\n\n @param matrix an allocated transformation matrix (will be fully overwritten\n               by this function)\n @param angle rotation angle in degrees."]
    pub fn av_display_rotation_set(matrix: *mut i32, angle: f64);
}
extern "C" {
    #[doc = " Flip the input matrix horizontally and/or vertically.\n\n @param matrix an allocated transformation matrix\n @param hflip whether the matrix should be flipped horizontally\n @param vflip whether the matrix should be flipped vertically"]
    pub fn av_display_matrix_flip(matrix: *mut i32, hflip: libc::c_int, vflip: libc::c_int);
}
#[repr(u32)]
#[doc = " Possible downmix types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVDownmixType {
    #[doc = "< Not indicated."]
    AV_DOWNMIX_TYPE_UNKNOWN = 0,
    #[doc = "< Lo/Ro 2-channel downmix (Stereo)."]
    AV_DOWNMIX_TYPE_LORO = 1,
    #[doc = "< Lt/Rt 2-channel downmix, Dolby Surround compatible."]
    AV_DOWNMIX_TYPE_LTRT = 2,
    #[doc = "< Lt/Rt 2-channel downmix, Dolby Pro Logic II compatible."]
    AV_DOWNMIX_TYPE_DPLII = 3,
    #[doc = "< Number of downmix types. Not part of ABI."]
    AV_DOWNMIX_TYPE_NB = 4,
}
#[doc = " This structure describes optional metadata relevant to a downmix procedure.\n\n All fields are set by the decoder to the value indicated in the audio\n bitstream (if present), or to a \"sane\" default otherwise."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct AVDownmixInfo {
    #[doc = " Type of downmix preferred by the mastering engineer."]
    pub preferred_downmix_type: AVDownmixType,
    #[doc = " Absolute scale factor representing the nominal level of the center\n channel during a regular downmix."]
    pub center_mix_level: f64,
    #[doc = " Absolute scale factor representing the nominal level of the center\n channel during an Lt/Rt compatible downmix."]
    pub center_mix_level_ltrt: f64,
    #[doc = " Absolute scale factor representing the nominal level of the surround\n channels during a regular downmix."]
    pub surround_mix_level: f64,
    #[doc = " Absolute scale factor representing the nominal level of the surround\n channels during an Lt/Rt compatible downmix."]
    pub surround_mix_level_ltrt: f64,
    #[doc = " Absolute scale factor representing the level at which the LFE data is\n mixed into L/R channels during downmixing."]
    pub lfe_mix_level: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVDownmixInfo"][::std::mem::size_of::<AVDownmixInfo>() - 48usize];
    ["Alignment of AVDownmixInfo"][::std::mem::align_of::<AVDownmixInfo>() - 8usize];
    ["Offset of field: AVDownmixInfo::preferred_downmix_type"]
        [::std::mem::offset_of!(AVDownmixInfo, preferred_downmix_type) - 0usize];
    ["Offset of field: AVDownmixInfo::center_mix_level"]
        [::std::mem::offset_of!(AVDownmixInfo, center_mix_level) - 8usize];
    ["Offset of field: AVDownmixInfo::center_mix_level_ltrt"]
        [::std::mem::offset_of!(AVDownmixInfo, center_mix_level_ltrt) - 16usize];
    ["Offset of field: AVDownmixInfo::surround_mix_level"]
        [::std::mem::offset_of!(AVDownmixInfo, surround_mix_level) - 24usize];
    ["Offset of field: AVDownmixInfo::surround_mix_level_ltrt"]
        [::std::mem::offset_of!(AVDownmixInfo, surround_mix_level_ltrt) - 32usize];
    ["Offset of field: AVDownmixInfo::lfe_mix_level"]
        [::std::mem::offset_of!(AVDownmixInfo, lfe_mix_level) - 40usize];
};
extern "C" {
    #[doc = " Get a frame's AV_FRAME_DATA_DOWNMIX_INFO side data for editing.\n\n If the side data is absent, it is created and added to the frame.\n\n @param frame the frame for which the side data is to be obtained or created\n\n @return the AVDownmixInfo structure to be edited by the caller, or NULL if\n         the structure cannot be allocated."]
    pub fn av_downmix_info_update_side_data(frame: *mut AVFrame) -> *mut AVDownmixInfo;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVExpr {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Parse and evaluate an expression.\n Note, this is significantly slower than av_expr_eval().\n\n @param res a pointer to a double where is put the result value of\n the expression, or NAN in case of error\n @param s expression as a zero terminated string, for example \"1+2^3+5*5+sin(2/3)\"\n @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {\"PI\", \"E\", 0}\n @param const_values a zero terminated array of values for the identifiers from const_names\n @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers\n @param funcs1 NULL terminated array of function pointers for functions which take 1 argument\n @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers\n @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments\n @param opaque a pointer which will be passed to all functions from funcs1 and funcs2\n @param log_ctx parent logging context\n @return >= 0 in case of success, a negative value corresponding to an\n AVERROR code otherwise"]
    pub fn av_expr_parse_and_eval(
        res: *mut f64,
        s: *const libc::c_char,
        const_names: *const *const libc::c_char,
        const_values: *const f64,
        func1_names: *const *const libc::c_char,
        funcs1: *const ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: f64) -> f64,
        >,
        func2_names: *const *const libc::c_char,
        funcs2: *const ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: f64, arg3: f64) -> f64,
        >,
        opaque: *mut libc::c_void,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Parse an expression.\n\n @param expr a pointer where is put an AVExpr containing the parsed\n value in case of successful parsing, or NULL otherwise.\n The pointed to AVExpr must be freed with av_expr_free() by the user\n when it is not needed anymore.\n @param s expression as a zero terminated string, for example \"1+2^3+5*5+sin(2/3)\"\n @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {\"PI\", \"E\", 0}\n @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers\n @param funcs1 NULL terminated array of function pointers for functions which take 1 argument\n @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers\n @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments\n @param log_ctx parent logging context\n @return >= 0 in case of success, a negative value corresponding to an\n AVERROR code otherwise"]
    pub fn av_expr_parse(
        expr: *mut *mut AVExpr,
        s: *const libc::c_char,
        const_names: *const *const libc::c_char,
        func1_names: *const *const libc::c_char,
        funcs1: *const ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: f64) -> f64,
        >,
        func2_names: *const *const libc::c_char,
        funcs2: *const ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: f64, arg3: f64) -> f64,
        >,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Evaluate a previously parsed expression.\n\n @param const_values a zero terminated array of values for the identifiers from av_expr_parse() const_names\n @param opaque a pointer which will be passed to all functions from funcs1 and funcs2\n @return the value of the expression"]
    pub fn av_expr_eval(e: *mut AVExpr, const_values: *const f64, opaque: *mut libc::c_void)
        -> f64;
}
extern "C" {
    #[doc = " Track the presence of variables and their number of occurrences in a parsed expression\n\n @param counter a zero-initialized array where the count of each variable will be stored\n @param size size of array\n @return 0 on success, a negative value indicates that no expression or array was passed\n or size was zero"]
    pub fn av_expr_count_vars(
        e: *mut AVExpr,
        counter: *mut libc::c_uint,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Track the presence of user provided functions and their number of occurrences\n in a parsed expression.\n\n @param counter a zero-initialized array where the count of each function will be stored\n                if you passed 5 functions with 2 arguments to av_expr_parse()\n                then for arg=2 this will use upto 5 entries.\n @param size size of array\n @param arg number of arguments the counted functions have\n @return 0 on success, a negative value indicates that no expression or array was passed\n or size was zero"]
    pub fn av_expr_count_func(
        e: *mut AVExpr,
        counter: *mut libc::c_uint,
        size: libc::c_int,
        arg: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Free a parsed expression previously created with av_expr_parse()."]
    pub fn av_expr_free(e: *mut AVExpr);
}
extern "C" {
    #[doc = " Parse the string in numstr and return its value as a double. If\n the string is empty, contains only whitespaces, or does not contain\n an initial substring that has the expected syntax for a\n floating-point number, no conversion is performed. In this case,\n returns a value of zero and the value returned in tail is the value\n of numstr.\n\n @param numstr a string representing a number, may contain one of\n the International System number postfixes, for example 'K', 'M',\n 'G'. If 'i' is appended after the postfix, powers of 2 are used\n instead of powers of 10. The 'B' postfix multiplies the value by\n 8, and can be appended after another postfix or used alone. This\n allows using for example 'KB', 'MiB', 'G' and 'B' as postfix.\n @param tail if non-NULL puts here the pointer to the char next\n after the last parsed character"]
    pub fn av_strtod(numstr: *const libc::c_char, tail: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    #[doc = " Read the file with name filename, and put its content in a newly\n allocated buffer or map it with mmap() when available.\n In case of success set *bufptr to the read or mmapped buffer, and\n *size to the size in bytes of the buffer in *bufptr.\n Unlike mmap this function succeeds with zero sized files, in this\n case *bufptr will be set to NULL and *size will be set to 0.\n The returned buffer must be released with av_file_unmap().\n\n @param log_offset loglevel offset used for logging\n @param log_ctx context used for logging\n @return a non negative number in case of success, a negative value\n corresponding to an AVERROR error code in case of failure"]
    pub fn av_file_map(
        filename: *const libc::c_char,
        bufptr: *mut *mut u8,
        size: *mut usize,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Unmap or free the buffer bufptr created by av_file_map().\n\n @param size size in bytes of bufptr, must be the same as returned\n by av_file_map()"]
    pub fn av_file_unmap(bufptr: *mut u8, size: usize);
}
extern "C" {
    #[doc = " Wrapper to work around the lack of mkstemp() on mingw.\n Also, tries to create file in /tmp first, if possible.\n *prefix can be a character constant; *filename will be allocated internally.\n @return file descriptor of opened file (or negative value corresponding to an\n AVERROR code on error)\n and opened file name in **filename.\n @note On very old libcs it is necessary to set a secure umask before\n       calling this, av_tempfile() can't call umask itself as it is used in\n       libraries and could interfere with the calling application.\n @deprecated as fd numbers cannot be passed saftely between libs on some platforms"]
    pub fn av_tempfile(
        prefix: *const libc::c_char,
        filename: *mut *mut libc::c_char,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
#[doc = " @example ffhash.c\n This example is a simple command line application that takes one or more\n arguments. It demonstrates a typical use of the hashing API with allocation,\n initialization, updating, and finalizing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHashContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate a hash context for the algorithm specified by name.\n\n @return  >= 0 for success, a negative error code for failure\n\n @note The context is not initialized after a call to this function; you must\n call av_hash_init() to do so."]
    pub fn av_hash_alloc(ctx: *mut *mut AVHashContext, name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the names of available hash algorithms.\n\n This function can be used to enumerate the algorithms.\n\n @param[in] i  Index of the hash algorithm, starting from 0\n @return       Pointer to a static string or `NULL` if `i` is out of range"]
    pub fn av_hash_names(i: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the name of the algorithm corresponding to the given hash context."]
    pub fn av_hash_get_name(ctx: *const AVHashContext) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the size of the resulting hash value in bytes.\n\n The maximum value this function will currently return is available as macro\n #AV_HASH_MAX_SIZE.\n\n @param[in]     ctx Hash context\n @return            Size of the hash value in bytes"]
    pub fn av_hash_get_size(ctx: *const AVHashContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Initialize or reset a hash context.\n\n @param[in,out] ctx Hash context"]
    pub fn av_hash_init(ctx: *mut AVHashContext);
}
extern "C" {
    pub fn av_hash_update(ctx: *mut AVHashContext, src: *const u8, len: libc::c_int);
}
extern "C" {
    #[doc = " Finalize a hash context and compute the actual hash value.\n\n The minimum size of `dst` buffer is given by av_hash_get_size() or\n #AV_HASH_MAX_SIZE. The use of the latter macro is discouraged.\n\n It is not safe to update or finalize a hash context again, if it has already\n been finalized.\n\n @param[in,out] ctx Hash context\n @param[out]    dst Where the final hash value will be stored\n\n @see av_hash_final_bin() provides an alternative API"]
    pub fn av_hash_final(ctx: *mut AVHashContext, dst: *mut u8);
}
extern "C" {
    #[doc = " Finalize a hash context and store the actual hash value in a buffer.\n\n It is not safe to update or finalize a hash context again, if it has already\n been finalized.\n\n If `size` is smaller than the hash size (given by av_hash_get_size()), the\n hash is truncated; if size is larger, the buffer is padded with 0.\n\n @param[in,out] ctx  Hash context\n @param[out]    dst  Where the final hash value will be stored\n @param[in]     size Number of bytes to write to `dst`"]
    pub fn av_hash_final_bin(ctx: *mut AVHashContext, dst: *mut u8, size: libc::c_int);
}
extern "C" {
    #[doc = " Finalize a hash context and store the hexadecimal representation of the\n actual hash value as a string.\n\n It is not safe to update or finalize a hash context again, if it has already\n been finalized.\n\n The string is always 0-terminated.\n\n If `size` is smaller than `2 * hash_size + 1`, where `hash_size` is the\n value returned by av_hash_get_size(), the string will be truncated.\n\n @param[in,out] ctx  Hash context\n @param[out]    dst  Where the string will be stored\n @param[in]     size Maximum number of bytes to write to `dst`"]
    pub fn av_hash_final_hex(ctx: *mut AVHashContext, dst: *mut u8, size: libc::c_int);
}
extern "C" {
    #[doc = " Finalize a hash context and store the Base64 representation of the\n actual hash value as a string.\n\n It is not safe to update or finalize a hash context again, if it has already\n been finalized.\n\n The string is always 0-terminated.\n\n If `size` is smaller than AV_BASE64_SIZE(hash_size), where `hash_size` is\n the value returned by av_hash_get_size(), the string will be truncated.\n\n @param[in,out] ctx  Hash context\n @param[out]    dst  Where the final hash value will be stored\n @param[in]     size Maximum number of bytes to write to `dst`"]
    pub fn av_hash_final_b64(ctx: *mut AVHashContext, dst: *mut u8, size: libc::c_int);
}
extern "C" {
    #[doc = " Free hash context and set hash context pointer to `NULL`.\n\n @param[in,out] ctx  Pointer to hash context"]
    pub fn av_hash_freep(ctx: *mut *mut AVHashContext);
}
#[repr(u32)]
#[doc = " @defgroup lavu_hmac HMAC\n @ingroup lavu_crypto\n @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVHMACType {
    AV_HMAC_MD5 = 0,
    AV_HMAC_SHA1 = 1,
    AV_HMAC_SHA224 = 2,
    AV_HMAC_SHA256 = 3,
    AV_HMAC_SHA384 = 4,
    AV_HMAC_SHA512 = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHMAC {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVHMAC context.\n @param type The hash function used for the HMAC."]
    pub fn av_hmac_alloc(type_: AVHMACType) -> *mut AVHMAC;
}
extern "C" {
    #[doc = " Free an AVHMAC context.\n @param ctx The context to free, may be NULL"]
    pub fn av_hmac_free(ctx: *mut AVHMAC);
}
extern "C" {
    #[doc = " Initialize an AVHMAC context with an authentication key.\n @param ctx    The HMAC context\n @param key    The authentication key\n @param keylen The length of the key, in bytes"]
    pub fn av_hmac_init(ctx: *mut AVHMAC, key: *const u8, keylen: libc::c_uint);
}
extern "C" {
    #[doc = " Hash data with the HMAC.\n @param ctx  The HMAC context\n @param data The data to hash\n @param len  The length of the data, in bytes"]
    pub fn av_hmac_update(ctx: *mut AVHMAC, data: *const u8, len: libc::c_uint);
}
extern "C" {
    #[doc = " Finish hashing and output the HMAC digest.\n @param ctx    The HMAC context\n @param out    The output buffer to write the digest into\n @param outlen The length of the out buffer, in bytes\n @return       The number of bytes written to out, or a negative error code."]
    pub fn av_hmac_final(ctx: *mut AVHMAC, out: *mut u8, outlen: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " Hash an array of data with a key.\n @param ctx    The HMAC context\n @param data   The data to hash\n @param len    The length of the data, in bytes\n @param key    The authentication key\n @param keylen The length of the key, in bytes\n @param out    The output buffer to write the digest into\n @param outlen The length of the out buffer, in bytes\n @return       The number of bytes written to out, or a negative error code."]
    pub fn av_hmac_calc(
        ctx: *mut AVHMAC,
        data: *const u8,
        len: libc::c_uint,
        key: *const u8,
        keylen: libc::c_uint,
        out: *mut u8,
        outlen: libc::c_uint,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVComponentDescriptor {
    #[doc = " Which of the 4 planes contains the component."]
    pub plane: libc::c_int,
    #[doc = " Number of elements between 2 horizontally consecutive pixels.\n Elements are bits for bitstream formats, bytes otherwise."]
    pub step: libc::c_int,
    #[doc = " Number of elements before the component of the first pixel.\n Elements are bits for bitstream formats, bytes otherwise."]
    pub offset: libc::c_int,
    #[doc = " Number of least significant bits that must be shifted away\n to get the value."]
    pub shift: libc::c_int,
    #[doc = " Number of bits in the component."]
    pub depth: libc::c_int,
    #[doc = " deprecated, use step instead"]
    pub step_minus1: libc::c_int,
    #[doc = " deprecated, use depth instead"]
    pub depth_minus1: libc::c_int,
    #[doc = " deprecated, use offset instead"]
    pub offset_plus1: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVComponentDescriptor"][::std::mem::size_of::<AVComponentDescriptor>() - 32usize];
    ["Alignment of AVComponentDescriptor"]
        [::std::mem::align_of::<AVComponentDescriptor>() - 4usize];
    ["Offset of field: AVComponentDescriptor::plane"]
        [::std::mem::offset_of!(AVComponentDescriptor, plane) - 0usize];
    ["Offset of field: AVComponentDescriptor::step"]
        [::std::mem::offset_of!(AVComponentDescriptor, step) - 4usize];
    ["Offset of field: AVComponentDescriptor::offset"]
        [::std::mem::offset_of!(AVComponentDescriptor, offset) - 8usize];
    ["Offset of field: AVComponentDescriptor::shift"]
        [::std::mem::offset_of!(AVComponentDescriptor, shift) - 12usize];
    ["Offset of field: AVComponentDescriptor::depth"]
        [::std::mem::offset_of!(AVComponentDescriptor, depth) - 16usize];
    ["Offset of field: AVComponentDescriptor::step_minus1"]
        [::std::mem::offset_of!(AVComponentDescriptor, step_minus1) - 20usize];
    ["Offset of field: AVComponentDescriptor::depth_minus1"]
        [::std::mem::offset_of!(AVComponentDescriptor, depth_minus1) - 24usize];
    ["Offset of field: AVComponentDescriptor::offset_plus1"]
        [::std::mem::offset_of!(AVComponentDescriptor, offset_plus1) - 28usize];
};
#[doc = " Descriptor that unambiguously describes how the bits of a pixel are\n stored in the up to 4 data planes of an image. It also stores the\n subsampling factors and number of components.\n\n @note This is separate of the colorspace (RGB, YCbCr, YPbPr, JPEG-style YUV\n       and all the YUV variants) AVPixFmtDescriptor just stores how values\n       are stored not what these values represent."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPixFmtDescriptor {
    pub name: *const libc::c_char,
    #[doc = "< The number of components each pixel has, (1-4)"]
    pub nb_components: u8,
    #[doc = " Amount to shift the luma width right to find the chroma width.\n For YV12 this is 1 for example.\n chroma_width = AV_CEIL_RSHIFT(luma_width, log2_chroma_w)\n The note above is needed to ensure rounding up.\n This value only refers to the chroma components."]
    pub log2_chroma_w: u8,
    #[doc = " Amount to shift the luma height right to find the chroma height.\n For YV12 this is 1 for example.\n chroma_height= AV_CEIL_RSHIFT(luma_height, log2_chroma_h)\n The note above is needed to ensure rounding up.\n This value only refers to the chroma components."]
    pub log2_chroma_h: u8,
    #[doc = " Combination of AV_PIX_FMT_FLAG_... flags."]
    pub flags: u64,
    #[doc = " Parameters that describe how pixels are packed.\n If the format has 1 or 2 components, then luma is 0.\n If the format has 3 or 4 components:\n   if the RGB flag is set then 0 is red, 1 is green and 2 is blue;\n   otherwise 0 is luma, 1 is chroma-U and 2 is chroma-V.\n\n If present, the Alpha channel is always the last component."]
    pub comp: [AVComponentDescriptor; 4usize],
    #[doc = " Alternative comma-separated names."]
    pub alias: *const libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVPixFmtDescriptor"][::std::mem::size_of::<AVPixFmtDescriptor>() - 160usize];
    ["Alignment of AVPixFmtDescriptor"][::std::mem::align_of::<AVPixFmtDescriptor>() - 8usize];
    ["Offset of field: AVPixFmtDescriptor::name"]
        [::std::mem::offset_of!(AVPixFmtDescriptor, name) - 0usize];
    ["Offset of field: AVPixFmtDescriptor::nb_components"]
        [::std::mem::offset_of!(AVPixFmtDescriptor, nb_components) - 8usize];
    ["Offset of field: AVPixFmtDescriptor::log2_chroma_w"]
        [::std::mem::offset_of!(AVPixFmtDescriptor, log2_chroma_w) - 9usize];
    ["Offset of field: AVPixFmtDescriptor::log2_chroma_h"]
        [::std::mem::offset_of!(AVPixFmtDescriptor, log2_chroma_h) - 10usize];
    ["Offset of field: AVPixFmtDescriptor::flags"]
        [::std::mem::offset_of!(AVPixFmtDescriptor, flags) - 16usize];
    ["Offset of field: AVPixFmtDescriptor::comp"]
        [::std::mem::offset_of!(AVPixFmtDescriptor, comp) - 24usize];
    ["Offset of field: AVPixFmtDescriptor::alias"]
        [::std::mem::offset_of!(AVPixFmtDescriptor, alias) - 152usize];
};
extern "C" {
    #[doc = " Return the number of bits per pixel used by the pixel format\n described by pixdesc. Note that this is not the same as the number\n of bits per sample.\n\n The returned number of bits refers to the number of bits actually\n used for storing the pixel information, that is padding bits are\n not counted."]
    pub fn av_get_bits_per_pixel(pixdesc: *const AVPixFmtDescriptor) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the number of bits per pixel for the pixel format\n described by pixdesc, including any padding or unused bits."]
    pub fn av_get_padded_bits_per_pixel(pixdesc: *const AVPixFmtDescriptor) -> libc::c_int;
}
extern "C" {
    #[doc = " @return a pixel format descriptor for provided pixel format or NULL if\n this pixel format is unknown."]
    pub fn av_pix_fmt_desc_get(pix_fmt: AVPixelFormat) -> *const AVPixFmtDescriptor;
}
extern "C" {
    #[doc = " Iterate over all pixel format descriptors known to libavutil.\n\n @param prev previous descriptor. NULL to get the first descriptor.\n\n @return next descriptor or NULL after the last descriptor"]
    pub fn av_pix_fmt_desc_next(prev: *const AVPixFmtDescriptor) -> *const AVPixFmtDescriptor;
}
extern "C" {
    #[doc = " @return an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc\n is not a valid pointer to a pixel format descriptor."]
    pub fn av_pix_fmt_desc_get_id(desc: *const AVPixFmtDescriptor) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Utility function to access log2_chroma_w log2_chroma_h from\n the pixel format AVPixFmtDescriptor.\n\n @param[in]  pix_fmt the pixel format\n @param[out] h_shift store log2_chroma_w (horizontal/width shift)\n @param[out] v_shift store log2_chroma_h (vertical/height shift)\n\n @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format"]
    pub fn av_pix_fmt_get_chroma_sub_sample(
        pix_fmt: AVPixelFormat,
        h_shift: *mut libc::c_int,
        v_shift: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a\n valid pixel format."]
    pub fn av_pix_fmt_count_planes(pix_fmt: AVPixelFormat) -> libc::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color range or NULL if unknown."]
    pub fn av_color_range_name(range: AVColorRange) -> *const libc::c_char;
}
extern "C" {
    #[doc = " @return the AVColorRange value for name or an AVError if not found."]
    pub fn av_color_range_from_name(name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color primaries or NULL if unknown."]
    pub fn av_color_primaries_name(primaries: AVColorPrimaries) -> *const libc::c_char;
}
extern "C" {
    #[doc = " @return the AVColorPrimaries value for name or an AVError if not found."]
    pub fn av_color_primaries_from_name(name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color transfer or NULL if unknown."]
    pub fn av_color_transfer_name(transfer: AVColorTransferCharacteristic) -> *const libc::c_char;
}
extern "C" {
    #[doc = " @return the AVColorTransferCharacteristic value for name or an AVError if not found."]
    pub fn av_color_transfer_from_name(name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color space or NULL if unknown."]
    pub fn av_color_space_name(space: AVColorSpace) -> *const libc::c_char;
}
extern "C" {
    #[doc = " @return the AVColorSpace value for name or an AVError if not found."]
    pub fn av_color_space_from_name(name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " @return the name for provided chroma location or NULL if unknown."]
    pub fn av_chroma_location_name(location: AVChromaLocation) -> *const libc::c_char;
}
extern "C" {
    #[doc = " @return the AVChromaLocation value for name or an AVError if not found."]
    pub fn av_chroma_location_from_name(name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the pixel format corresponding to name.\n\n If there is no pixel format with name name, then looks for a\n pixel format with the name corresponding to the native endian\n format of name.\n For example in a little-endian system, first looks for \"gray16\",\n then for \"gray16le\".\n\n Finally if no pixel format has been found, returns AV_PIX_FMT_NONE."]
    pub fn av_get_pix_fmt(name: *const libc::c_char) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Return the short name for a pixel format, NULL in case pix_fmt is\n unknown.\n\n @see av_get_pix_fmt(), av_get_pix_fmt_string()"]
    pub fn av_get_pix_fmt_name(pix_fmt: AVPixelFormat) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Print in buf the string corresponding to the pixel format with\n number pix_fmt, or a header if pix_fmt is negative.\n\n @param buf the buffer where to write the string\n @param buf_size the size of buf\n @param pix_fmt the number of the pixel format to print the\n corresponding info string, or a negative value to print the\n corresponding header."]
    pub fn av_get_pix_fmt_string(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        pix_fmt: AVPixelFormat,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Read a line from an image, and write the values of the\n pixel format component c to dst.\n\n @param data the array containing the pointers to the planes of the image\n @param linesize the array containing the linesizes of the image\n @param desc the pixel format descriptor for the image\n @param x the horizontal coordinate of the first pixel to read\n @param y the vertical coordinate of the first pixel to read\n @param w the width of the line to read, that is the number of\n values to write to dst\n @param read_pal_component if not zero and the format is a paletted\n format writes the values corresponding to the palette\n component c in data[1] to dst, rather than the palette indexes in\n data[0]. The behavior is undefined if the format is not paletted.\n @param dst_element_size size of elements in dst array (2 or 4 byte)"]
    pub fn av_read_image_line2(
        dst: *mut libc::c_void,
        data: *mut *const u8,
        linesize: *const libc::c_int,
        desc: *const AVPixFmtDescriptor,
        x: libc::c_int,
        y: libc::c_int,
        c: libc::c_int,
        w: libc::c_int,
        read_pal_component: libc::c_int,
        dst_element_size: libc::c_int,
    );
}
extern "C" {
    pub fn av_read_image_line(
        dst: *mut u16,
        data: *mut *const u8,
        linesize: *const libc::c_int,
        desc: *const AVPixFmtDescriptor,
        x: libc::c_int,
        y: libc::c_int,
        c: libc::c_int,
        w: libc::c_int,
        read_pal_component: libc::c_int,
    );
}
extern "C" {
    #[doc = " Write the values from src to the pixel format component c of an\n image line.\n\n @param src array containing the values to write\n @param data the array containing the pointers to the planes of the\n image to write into. It is supposed to be zeroed.\n @param linesize the array containing the linesizes of the image\n @param desc the pixel format descriptor for the image\n @param x the horizontal coordinate of the first pixel to write\n @param y the vertical coordinate of the first pixel to write\n @param w the width of the line to write, that is the number of\n values to write to the image line\n @param src_element_size size of elements in src array (2 or 4 byte)"]
    pub fn av_write_image_line2(
        src: *const libc::c_void,
        data: *mut *mut u8,
        linesize: *const libc::c_int,
        desc: *const AVPixFmtDescriptor,
        x: libc::c_int,
        y: libc::c_int,
        c: libc::c_int,
        w: libc::c_int,
        src_element_size: libc::c_int,
    );
}
extern "C" {
    pub fn av_write_image_line(
        src: *const u16,
        data: *mut *mut u8,
        linesize: *const libc::c_int,
        desc: *const AVPixFmtDescriptor,
        x: libc::c_int,
        y: libc::c_int,
        c: libc::c_int,
        w: libc::c_int,
    );
}
extern "C" {
    #[doc = " Utility function to swap the endianness of a pixel format.\n\n @param[in]  pix_fmt the pixel format\n\n @return pixel format with swapped endianness if it exists,\n otherwise AV_PIX_FMT_NONE"]
    pub fn av_pix_fmt_swap_endianness(pix_fmt: AVPixelFormat) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Compute what kind of losses will occur when converting from one specific\n pixel format to another.\n When converting from one pixel format to another, information loss may occur.\n For example, when converting from RGB24 to GRAY, the color information will\n be lost. Similarly, other losses occur when converting from some formats to\n other formats. These losses can involve loss of chroma, but also loss of\n resolution, loss of color depth, loss due to the color space conversion, loss\n of the alpha bits or loss due to color quantization.\n av_get_fix_fmt_loss() informs you about the various types of losses\n which will occur when converting from one pixel format to another.\n\n @param[in] dst_pix_fmt destination pixel format\n @param[in] src_pix_fmt source pixel format\n @param[in] has_alpha Whether the source pixel format alpha channel is used.\n @return Combination of flags informing you what kind of losses will occur\n (maximum loss for an invalid dst_pix_fmt)."]
    pub fn av_get_pix_fmt_loss(
        dst_pix_fmt: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Compute what kind of losses will occur when converting from one specific\n pixel format to another.\n When converting from one pixel format to another, information loss may occur.\n For example, when converting from RGB24 to GRAY, the color information will\n be lost. Similarly, other losses occur when converting from some formats to\n other formats. These losses can involve loss of chroma, but also loss of\n resolution, loss of color depth, loss due to the color space conversion, loss\n of the alpha bits or loss due to color quantization.\n av_get_fix_fmt_loss() informs you about the various types of losses\n which will occur when converting from one pixel format to another.\n\n @param[in] dst_pix_fmt destination pixel format\n @param[in] src_pix_fmt source pixel format\n @param[in] has_alpha Whether the source pixel format alpha channel is used.\n @return Combination of flags informing you what kind of losses will occur\n (maximum loss for an invalid dst_pix_fmt)."]
    pub fn av_find_best_pix_fmt_of_2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: libc::c_int,
        loss_ptr: *mut libc::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Compute the max pixel step for each plane of an image with a\n format described by pixdesc.\n\n The pixel step is the distance in bytes between the first byte of\n the group of bytes which describe a pixel component and the first\n byte of the successive group in the same plane for the same\n component.\n\n @param max_pixsteps an array which is filled with the max pixel step\n for each plane. Since a plane may contain different pixel\n components, the computed max_pixsteps[plane] is relative to the\n component in the plane with the max pixel step.\n @param max_pixstep_comps an array which is filled with the component\n for each plane which has the max pixel step. May be NULL."]
    pub fn av_image_fill_max_pixsteps(
        max_pixsteps: *mut libc::c_int,
        max_pixstep_comps: *mut libc::c_int,
        pixdesc: *const AVPixFmtDescriptor,
    );
}
extern "C" {
    #[doc = " Compute the size of an image line with format pix_fmt and width\n width for the plane plane.\n\n @return the computed size in bytes"]
    pub fn av_image_get_linesize(
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        plane: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill plane linesizes for an image with pixel format pix_fmt and\n width width.\n\n @param linesizes array to be filled with the linesize for each plane\n @return >= 0 in case of success, a negative error code otherwise"]
    pub fn av_image_fill_linesizes(
        linesizes: *mut libc::c_int,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill plane sizes for an image with pixel format pix_fmt and height height.\n\n @param size the array to be filled with the size of each image plane\n @param linesizes the array containing the linesize for each\n        plane, should be filled by av_image_fill_linesizes()\n @return >= 0 in case of success, a negative error code otherwise\n\n @note The linesize parameters have the type ptrdiff_t here, while they are\n       int for av_image_fill_linesizes()."]
    pub fn av_image_fill_plane_sizes(
        size: *mut usize,
        pix_fmt: AVPixelFormat,
        height: libc::c_int,
        linesizes: *const isize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill plane data pointers for an image with pixel format pix_fmt and\n height height.\n\n @param data pointers array to be filled with the pointer for each image plane\n @param ptr the pointer to a buffer which will contain the image\n @param linesizes the array containing the linesize for each\n plane, should be filled by av_image_fill_linesizes()\n @return the size in bytes required for the image buffer, a negative\n error code in case of failure"]
    pub fn av_image_fill_pointers(
        data: *mut *mut u8,
        pix_fmt: AVPixelFormat,
        height: libc::c_int,
        ptr: *mut u8,
        linesizes: *const libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate an image with size w and h and pixel format pix_fmt, and\n fill pointers and linesizes accordingly.\n The allocated image buffer has to be freed by using\n av_freep(&pointers[0]).\n\n @param align the value to use for buffer size alignment\n @return the size in bytes required for the image buffer, a negative\n error code in case of failure"]
    pub fn av_image_alloc(
        pointers: *mut *mut u8,
        linesizes: *mut libc::c_int,
        w: libc::c_int,
        h: libc::c_int,
        pix_fmt: AVPixelFormat,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy image plane from src to dst.\n That is, copy \"height\" number of lines of \"bytewidth\" bytes each.\n The first byte of each successive line is separated by *_linesize\n bytes.\n\n bytewidth must be contained by both absolute values of dst_linesize\n and src_linesize, otherwise the function behavior is undefined.\n\n @param dst_linesize linesize for the image plane in dst\n @param src_linesize linesize for the image plane in src"]
    pub fn av_image_copy_plane(
        dst: *mut u8,
        dst_linesize: libc::c_int,
        src: *const u8,
        src_linesize: libc::c_int,
        bytewidth: libc::c_int,
        height: libc::c_int,
    );
}
extern "C" {
    #[doc = " Copy image in src_data to dst_data.\n\n @param dst_linesizes linesizes for the image in dst_data\n @param src_linesizes linesizes for the image in src_data"]
    pub fn av_image_copy(
        dst_data: *mut *mut u8,
        dst_linesizes: *mut libc::c_int,
        src_data: *mut *const u8,
        src_linesizes: *const libc::c_int,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
    );
}
extern "C" {
    #[doc = " Copy image data located in uncacheable (e.g. GPU mapped) memory. Where\n available, this function will use special functionality for reading from such\n memory, which may result in greatly improved performance compared to plain\n av_image_copy().\n\n The data pointers and the linesizes must be aligned to the maximum required\n by the CPU architecture.\n\n @note The linesize parameters have the type ptrdiff_t here, while they are\n       int for av_image_copy().\n @note On x86, the linesizes currently need to be aligned to the cacheline\n       size (i.e. 64) to get improved performance."]
    pub fn av_image_copy_uc_from(
        dst_data: *mut *mut u8,
        dst_linesizes: *const isize,
        src_data: *mut *const u8,
        src_linesizes: *const isize,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
    );
}
extern "C" {
    #[doc = " Setup the data pointers and linesizes based on the specified image\n parameters and the provided array.\n\n The fields of the given image are filled in by using the src\n address which points to the image data buffer. Depending on the\n specified pixel format, one or multiple image data pointers and\n line sizes will be set.  If a planar format is specified, several\n pointers will be set pointing to the different picture planes and\n the line sizes of the different planes will be stored in the\n lines_sizes array. Call with src == NULL to get the required\n size for the src buffer.\n\n To allocate the buffer and fill in the dst_data and dst_linesize in\n one call, use av_image_alloc().\n\n @param dst_data      data pointers to be filled in\n @param dst_linesize  linesizes for the image in dst_data to be filled in\n @param src           buffer which will contain or contains the actual image data, can be NULL\n @param pix_fmt       the pixel format of the image\n @param width         the width of the image in pixels\n @param height        the height of the image in pixels\n @param align         the value used in src for linesize alignment\n @return the size in bytes required for src, a negative error code\n in case of failure"]
    pub fn av_image_fill_arrays(
        dst_data: *mut *mut u8,
        dst_linesize: *mut libc::c_int,
        src: *const u8,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the size in bytes of the amount of data required to store an\n image with the given parameters.\n\n @param pix_fmt  the pixel format of the image\n @param width    the width of the image in pixels\n @param height   the height of the image in pixels\n @param align    the assumed linesize alignment\n @return the buffer size in bytes, a negative error code in case of failure"]
    pub fn av_image_get_buffer_size(
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy image data from an image into a buffer.\n\n av_image_get_buffer_size() can be used to compute the required size\n for the buffer to fill.\n\n @param dst           a buffer into which picture data will be copied\n @param dst_size      the size in bytes of dst\n @param src_data      pointers containing the source image data\n @param src_linesize  linesizes for the image in src_data\n @param pix_fmt       the pixel format of the source image\n @param width         the width of the source image in pixels\n @param height        the height of the source image in pixels\n @param align         the assumed linesize alignment for dst\n @return the number of bytes written to dst, or a negative value\n (error code) on error"]
    pub fn av_image_copy_to_buffer(
        dst: *mut u8,
        dst_size: libc::c_int,
        src_data: *const *const u8,
        src_linesize: *const libc::c_int,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Check if the given dimension of an image is valid, meaning that all\n bytes of the image can be addressed with a signed int.\n\n @param w the width of the picture\n @param h the height of the picture\n @param log_offset the offset to sum to the log level for logging with log_ctx\n @param log_ctx the parent logging context, it may be NULL\n @return >= 0 if valid, a negative error code otherwise"]
    pub fn av_image_check_size(
        w: libc::c_uint,
        h: libc::c_uint,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Check if the given dimension of an image is valid, meaning that all\n bytes of a plane of an image with the specified pix_fmt can be addressed\n with a signed int.\n\n @param w the width of the picture\n @param h the height of the picture\n @param max_pixels the maximum number of pixels the user wants to accept\n @param pix_fmt the pixel format, can be AV_PIX_FMT_NONE if unknown.\n @param log_offset the offset to sum to the log level for logging with log_ctx\n @param log_ctx the parent logging context, it may be NULL\n @return >= 0 if valid, a negative error code otherwise"]
    pub fn av_image_check_size2(
        w: libc::c_uint,
        h: libc::c_uint,
        max_pixels: i64,
        pix_fmt: AVPixelFormat,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Check if the given sample aspect ratio of an image is valid.\n\n It is considered invalid if the denominator is 0 or if applying the ratio\n to the image size would make the smaller dimension less than 1. If the\n sar numerator is 0, it is considered unknown and will return as valid.\n\n @param w width of the image\n @param h height of the image\n @param sar sample aspect ratio of the image\n @return 0 if valid, a negative AVERROR code otherwise"]
    pub fn av_image_check_sar(w: libc::c_uint, h: libc::c_uint, sar: AVRational) -> libc::c_int;
}
extern "C" {
    #[doc = " Overwrite the image data with black. This is suitable for filling a\n sub-rectangle of an image, meaning the padding between the right most pixel\n and the left most pixel on the next line will not be overwritten. For some\n formats, the image size might be rounded up due to inherent alignment.\n\n If the pixel format has alpha, the alpha is cleared to opaque.\n\n This can return an error if the pixel format is not supported. Normally, all\n non-hwaccel pixel formats should be supported.\n\n Passing NULL for dst_data is allowed. Then the function returns whether the\n operation would have succeeded. (It can return an error if the pix_fmt is\n not supported.)\n\n @param dst_data      data pointers to destination image\n @param dst_linesize  linesizes for the destination image\n @param pix_fmt       the pixel format of the image\n @param range         the color range of the image (important for colorspaces such as YUV)\n @param width         the width of the image in pixels\n @param height        the height of the image in pixels\n @return 0 if the image data was cleared, a negative AVERROR code otherwise"]
    pub fn av_image_fill_black(
        dst_data: *mut *mut u8,
        dst_linesize: *const isize,
        pix_fmt: AVPixelFormat,
        range: AVColorRange,
        width: libc::c_int,
        height: libc::c_int,
    ) -> libc::c_int;
}
#[doc = " Context structure for the Lagged Fibonacci PRNG.\n The exact layout, types and content of this struct may change and should\n not be accessed directly. Only its sizeof() is guranteed to stay the same\n to allow easy instanciation."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVLFG {
    pub state: [libc::c_uint; 64usize],
    pub index: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVLFG"][::std::mem::size_of::<AVLFG>() - 260usize];
    ["Alignment of AVLFG"][::std::mem::align_of::<AVLFG>() - 4usize];
    ["Offset of field: AVLFG::state"][::std::mem::offset_of!(AVLFG, state) - 0usize];
    ["Offset of field: AVLFG::index"][::std::mem::offset_of!(AVLFG, index) - 256usize];
};
extern "C" {
    pub fn av_lfg_init(c: *mut AVLFG, seed: libc::c_uint);
}
extern "C" {
    #[doc = " Seed the state of the ALFG using binary data.\n\n Return value: 0 on success, negative value (AVERROR) on failure."]
    pub fn av_lfg_init_from_data(
        c: *mut AVLFG,
        data: *const u8,
        length: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the next two numbers generated by a Box-Muller Gaussian\n generator using the random numbers issued by lfg.\n\n @param out array where the two generated numbers are placed"]
    pub fn av_bmg_get(lfg: *mut AVLFG, out: *mut f64);
}
extern "C" {
    #[doc = " @brief Decodes LZO 1x compressed data.\n @param out output buffer\n @param outlen size of output buffer, number of bytes left are returned here\n @param in input buffer\n @param inlen size of input buffer, number of bytes left are returned here\n @return 0 on success, otherwise a combination of the error flags above\n\n Make sure all buffers are appropriately padded, in must provide\n AV_LZO_INPUT_PADDING, out must provide AV_LZO_OUTPUT_PADDING additional bytes."]
    pub fn av_lzo1x_decode(
        out: *mut libc::c_void,
        outlen: *mut libc::c_int,
        in_: *const libc::c_void,
        inlen: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @defgroup lavu_md5 MD5\n @ingroup lavu_hash\n MD5 hash function implementation.\n\n @{"]
    pub static av_md5_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVMD5 {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVMD5 context."]
    pub fn av_md5_alloc() -> *mut AVMD5;
}
extern "C" {
    #[doc = " Initialize MD5 hashing.\n\n @param ctx pointer to the function context (of size av_md5_size)"]
    pub fn av_md5_init(ctx: *mut AVMD5);
}
extern "C" {
    pub fn av_md5_update(ctx: *mut AVMD5, src: *const u8, len: libc::c_int);
}
extern "C" {
    #[doc = " Finish hashing and output digest value.\n\n @param ctx hash function context\n @param dst buffer where output digest value is stored"]
    pub fn av_md5_final(ctx: *mut AVMD5, dst: *mut u8);
}
extern "C" {
    pub fn av_md5_sum(dst: *mut u8, src: *const u8, len: libc::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVMotionVector {
    #[doc = " Where the current macroblock comes from; negative value when it comes\n from the past, positive value when it comes from the future.\n XXX: set exact relative ref frame reference instead of a +/- 1 \"direction\"."]
    pub source: i32,
    #[doc = " Width and height of the block."]
    pub w: u8,
    #[doc = " Width and height of the block."]
    pub h: u8,
    #[doc = " Absolute source position. Can be outside the frame area."]
    pub src_x: i16,
    #[doc = " Absolute source position. Can be outside the frame area."]
    pub src_y: i16,
    #[doc = " Absolute destination position. Can be outside the frame area."]
    pub dst_x: i16,
    #[doc = " Absolute destination position. Can be outside the frame area."]
    pub dst_y: i16,
    #[doc = " Extra flag information.\n Currently unused."]
    pub flags: u64,
    #[doc = " Motion vector\n src_x = dst_x + motion_x / motion_scale\n src_y = dst_y + motion_y / motion_scale"]
    pub motion_x: i32,
    #[doc = " Motion vector\n src_x = dst_x + motion_x / motion_scale\n src_y = dst_y + motion_y / motion_scale"]
    pub motion_y: i32,
    pub motion_scale: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVMotionVector"][::std::mem::size_of::<AVMotionVector>() - 40usize];
    ["Alignment of AVMotionVector"][::std::mem::align_of::<AVMotionVector>() - 8usize];
    ["Offset of field: AVMotionVector::source"]
        [::std::mem::offset_of!(AVMotionVector, source) - 0usize];
    ["Offset of field: AVMotionVector::w"][::std::mem::offset_of!(AVMotionVector, w) - 4usize];
    ["Offset of field: AVMotionVector::h"][::std::mem::offset_of!(AVMotionVector, h) - 5usize];
    ["Offset of field: AVMotionVector::src_x"]
        [::std::mem::offset_of!(AVMotionVector, src_x) - 6usize];
    ["Offset of field: AVMotionVector::src_y"]
        [::std::mem::offset_of!(AVMotionVector, src_y) - 8usize];
    ["Offset of field: AVMotionVector::dst_x"]
        [::std::mem::offset_of!(AVMotionVector, dst_x) - 10usize];
    ["Offset of field: AVMotionVector::dst_y"]
        [::std::mem::offset_of!(AVMotionVector, dst_y) - 12usize];
    ["Offset of field: AVMotionVector::flags"]
        [::std::mem::offset_of!(AVMotionVector, flags) - 16usize];
    ["Offset of field: AVMotionVector::motion_x"]
        [::std::mem::offset_of!(AVMotionVector, motion_x) - 24usize];
    ["Offset of field: AVMotionVector::motion_y"]
        [::std::mem::offset_of!(AVMotionVector, motion_y) - 28usize];
    ["Offset of field: AVMotionVector::motion_scale"]
        [::std::mem::offset_of!(AVMotionVector, motion_scale) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVMurMur3 {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVMurMur3 hash context.\n\n @return Uninitialized hash context or `NULL` in case of error"]
    pub fn av_murmur3_alloc() -> *mut AVMurMur3;
}
extern "C" {
    #[doc = " Initialize or reinitialize an AVMurMur3 hash context with a seed.\n\n @param[out] c    Hash context\n @param[in]  seed Random seed\n\n @see av_murmur3_init()\n @see @ref lavu_murmur3_seedinfo \"Detailed description\" on a discussion of\n seeds for MurmurHash3."]
    pub fn av_murmur3_init_seeded(c: *mut AVMurMur3, seed: u64);
}
extern "C" {
    #[doc = " Initialize or reinitialize an AVMurMur3 hash context.\n\n Equivalent to av_murmur3_init_seeded() with a built-in seed.\n\n @param[out] c    Hash context\n\n @see av_murmur3_init_seeded()\n @see @ref lavu_murmur3_seedinfo \"Detailed description\" on a discussion of\n seeds for MurmurHash3."]
    pub fn av_murmur3_init(c: *mut AVMurMur3);
}
extern "C" {
    pub fn av_murmur3_update(c: *mut AVMurMur3, src: *const u8, len: libc::c_int);
}
extern "C" {
    #[doc = " Finish hashing and output digest value.\n\n @param[in,out] c    Hash context\n @param[out]    dst  Buffer where output digest value is stored"]
    pub fn av_murmur3_final(c: *mut AVMurMur3, dst: *mut u8);
}
#[repr(u32)]
#[doc = " @defgroup avoptions AVOptions\n @ingroup lavu_data\n @{\n AVOptions provide a generic system to declare options on arbitrary structs\n (\"objects\"). An option can have a help text, a type and a range of possible\n values. Options may then be enumerated, read and written to.\n\n @section avoptions_implement Implementing AVOptions\n This section describes how to add AVOptions capabilities to a struct.\n\n All AVOptions-related information is stored in an AVClass. Therefore\n the first member of the struct should be a pointer to an AVClass describing it.\n The option field of the AVClass must be set to a NULL-terminated static array\n of AVOptions. Each AVOption must have a non-empty name, a type, a default\n value and for number-type AVOptions also a range of allowed values. It must\n also declare an offset in bytes from the start of the struct, where the field\n associated with this AVOption is located. Other fields in the AVOption struct\n should also be set when applicable, but are not required.\n\n The following example illustrates an AVOptions-enabled struct:\n @code\n typedef struct test_struct {\n     const AVClass *class;\n     int      int_opt;\n     char    *str_opt;\n     uint8_t *bin_opt;\n     int      bin_len;\n } test_struct;\n\n static const AVOption test_options[] = {\n   { \"test_int\", \"This is a test option of int type.\", offsetof(test_struct, int_opt),\n     AV_OPT_TYPE_INT, { .i64 = -1 }, INT_MIN, INT_MAX },\n   { \"test_str\", \"This is a test option of string type.\", offsetof(test_struct, str_opt),\n     AV_OPT_TYPE_STRING },\n   { \"test_bin\", \"This is a test option of binary type.\", offsetof(test_struct, bin_opt),\n     AV_OPT_TYPE_BINARY },\n   { NULL },\n };\n\n static const AVClass test_class = {\n     .class_name = \"test class\",\n     .item_name  = av_default_item_name,\n     .option     = test_options,\n     .version    = LIBAVUTIL_VERSION_INT,\n };\n @endcode\n\n Next, when allocating your struct, you must ensure that the AVClass pointer\n is set to the correct value. Then, av_opt_set_defaults() can be called to\n initialize defaults. After that the struct is ready to be used with the\n AVOptions API.\n\n When cleaning up, you may use the av_opt_free() function to automatically\n free all the allocated string and binary options.\n\n Continuing with the above example:\n\n @code\n test_struct *alloc_test_struct(void)\n {\n     test_struct *ret = av_mallocz(sizeof(*ret));\n     ret->class = &test_class;\n     av_opt_set_defaults(ret);\n     return ret;\n }\n void free_test_struct(test_struct **foo)\n {\n     av_opt_free(*foo);\n     av_freep(foo);\n }\n @endcode\n\n @subsection avoptions_implement_nesting Nesting\n      It may happen that an AVOptions-enabled struct contains another\n      AVOptions-enabled struct as a member (e.g. AVCodecContext in\n      libavcodec exports generic options, while its priv_data field exports\n      codec-specific options). In such a case, it is possible to set up the\n      parent struct to export a child's options. To do that, simply\n      implement AVClass.child_next() and AVClass.child_class_iterate() in the\n      parent struct's AVClass.\n      Assuming that the test_struct from above now also contains a\n      child_struct field:\n\n      @code\n      typedef struct child_struct {\n          AVClass *class;\n          int flags_opt;\n      } child_struct;\n      static const AVOption child_opts[] = {\n          { \"test_flags\", \"This is a test option of flags type.\",\n            offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX },\n          { NULL },\n      };\n      static const AVClass child_class = {\n          .class_name = \"child class\",\n          .item_name  = av_default_item_name,\n          .option     = child_opts,\n          .version    = LIBAVUTIL_VERSION_INT,\n      };\n\n      void *child_next(void *obj, void *prev)\n      {\n          test_struct *t = obj;\n          if (!prev && t->child_struct)\n              return t->child_struct;\n          return NULL\n      }\n      const AVClass child_class_iterate(void **iter)\n      {\n          const AVClass *c = *iter ? NULL : &child_class;\n          *iter = (void*)(uintptr_t)c;\n          return c;\n      }\n      @endcode\n      Putting child_next() and child_class_iterate() as defined above into\n      test_class will now make child_struct's options accessible through\n      test_struct (again, proper setup as described above needs to be done on\n      child_struct right after it is created).\n\n      From the above example it might not be clear why both child_next()\n      and child_class_iterate() are needed. The distinction is that child_next()\n      iterates over actually existing objects, while child_class_iterate()\n      iterates over all possible child classes. E.g. if an AVCodecContext\n      was initialized to use a codec which has private options, then its\n      child_next() will return AVCodecContext.priv_data and finish\n      iterating. OTOH child_class_iterate() on AVCodecContext.av_class will\n      iterate over all available codecs with private options.\n\n @subsection avoptions_implement_named_constants Named constants\n      It is possible to create named constants for options. Simply set the unit\n      field of the option the constants should apply to a string and\n      create the constants themselves as options of type AV_OPT_TYPE_CONST\n      with their unit field set to the same string.\n      Their default_val field should contain the value of the named\n      constant.\n      For example, to add some named constants for the test_flags option\n      above, put the following into the child_opts array:\n      @code\n      { \"test_flags\", \"This is a test option of flags type.\",\n        offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX, \"test_unit\" },\n      { \"flag1\", \"This is a flag with value 16\", 0, AV_OPT_TYPE_CONST, { .i64 = 16 }, 0, 0, \"test_unit\" },\n      @endcode\n\n @section avoptions_use Using AVOptions\n This section deals with accessing options in an AVOptions-enabled struct.\n Such structs in FFmpeg are e.g. AVCodecContext in libavcodec or\n AVFormatContext in libavformat.\n\n @subsection avoptions_use_examine Examining AVOptions\n The basic functions for examining options are av_opt_next(), which iterates\n over all options defined for one object, and av_opt_find(), which searches\n for an option with the given name.\n\n The situation is more complicated with nesting. An AVOptions-enabled struct\n may have AVOptions-enabled children. Passing the AV_OPT_SEARCH_CHILDREN flag\n to av_opt_find() will make the function search children recursively.\n\n For enumerating there are basically two cases. The first is when you want to\n get all options that may potentially exist on the struct and its children\n (e.g.  when constructing documentation). In that case you should call\n av_opt_child_class_iterate() recursively on the parent struct's AVClass.  The\n second case is when you have an already initialized struct with all its\n children and you want to get all options that can be actually written or read\n from it. In that case you should call av_opt_child_next() recursively (and\n av_opt_next() on each result).\n\n @subsection avoptions_use_get_set Reading and writing AVOptions\n When setting options, you often have a string read directly from the\n user. In such a case, simply passing it to av_opt_set() is enough. For\n non-string type options, av_opt_set() will parse the string according to the\n option type.\n\n Similarly av_opt_get() will read any option type and convert it to a string\n which will be returned. Do not forget that the string is allocated, so you\n have to free it with av_free().\n\n In some cases it may be more convenient to put all options into an\n AVDictionary and call av_opt_set_dict() on it. A specific case of this\n are the format/codec open functions in lavf/lavc which take a dictionary\n filled with option as a parameter. This makes it possible to set some options\n that cannot be set otherwise, since e.g. the input file format is not known\n before the file is actually opened."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVOptionType {
    AV_OPT_TYPE_FLAGS = 0,
    AV_OPT_TYPE_INT = 1,
    AV_OPT_TYPE_INT64 = 2,
    AV_OPT_TYPE_DOUBLE = 3,
    AV_OPT_TYPE_FLOAT = 4,
    AV_OPT_TYPE_STRING = 5,
    AV_OPT_TYPE_RATIONAL = 6,
    #[doc = "< offset must point to a pointer immediately followed by an int for the length"]
    AV_OPT_TYPE_BINARY = 7,
    AV_OPT_TYPE_DICT = 8,
    AV_OPT_TYPE_UINT64 = 9,
    AV_OPT_TYPE_CONST = 10,
    #[doc = "< offset must point to two consecutive integers"]
    AV_OPT_TYPE_IMAGE_SIZE = 11,
    AV_OPT_TYPE_PIXEL_FMT = 12,
    AV_OPT_TYPE_SAMPLE_FMT = 13,
    #[doc = "< offset must point to AVRational"]
    AV_OPT_TYPE_VIDEO_RATE = 14,
    AV_OPT_TYPE_DURATION = 15,
    AV_OPT_TYPE_COLOR = 16,
    AV_OPT_TYPE_CHANNEL_LAYOUT = 17,
    AV_OPT_TYPE_BOOL = 18,
}
#[doc = " AVOption"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVOption {
    pub name: *const libc::c_char,
    #[doc = " short English help text\n @todo What about other languages?"]
    pub help: *const libc::c_char,
    #[doc = " The offset relative to the context structure where the option\n value is stored. It should be 0 for named constants."]
    pub offset: libc::c_int,
    pub type_: AVOptionType,
    pub default_val: AVOption__bindgen_ty_1,
    #[doc = "< minimum valid value for the option"]
    pub min: f64,
    #[doc = "< maximum valid value for the option"]
    pub max: f64,
    pub flags: libc::c_int,
    #[doc = " The logical unit to which the option belongs. Non-constant\n options and corresponding named constants share the same\n unit. May be NULL."]
    pub unit: *const libc::c_char,
}
#[doc = " the default value for scalar options"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union AVOption__bindgen_ty_1 {
    pub i64_: i64,
    pub dbl: f64,
    pub str_: *const libc::c_char,
    pub q: AVRational,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVOption__bindgen_ty_1"][::std::mem::size_of::<AVOption__bindgen_ty_1>() - 8usize];
    ["Alignment of AVOption__bindgen_ty_1"]
        [::std::mem::align_of::<AVOption__bindgen_ty_1>() - 8usize];
    ["Offset of field: AVOption__bindgen_ty_1::i64_"]
        [::std::mem::offset_of!(AVOption__bindgen_ty_1, i64_) - 0usize];
    ["Offset of field: AVOption__bindgen_ty_1::dbl"]
        [::std::mem::offset_of!(AVOption__bindgen_ty_1, dbl) - 0usize];
    ["Offset of field: AVOption__bindgen_ty_1::str_"]
        [::std::mem::offset_of!(AVOption__bindgen_ty_1, str_) - 0usize];
    ["Offset of field: AVOption__bindgen_ty_1::q"]
        [::std::mem::offset_of!(AVOption__bindgen_ty_1, q) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVOption"][::std::mem::size_of::<AVOption>() - 64usize];
    ["Alignment of AVOption"][::std::mem::align_of::<AVOption>() - 8usize];
    ["Offset of field: AVOption::name"][::std::mem::offset_of!(AVOption, name) - 0usize];
    ["Offset of field: AVOption::help"][::std::mem::offset_of!(AVOption, help) - 8usize];
    ["Offset of field: AVOption::offset"][::std::mem::offset_of!(AVOption, offset) - 16usize];
    ["Offset of field: AVOption::type_"][::std::mem::offset_of!(AVOption, type_) - 20usize];
    ["Offset of field: AVOption::default_val"]
        [::std::mem::offset_of!(AVOption, default_val) - 24usize];
    ["Offset of field: AVOption::min"][::std::mem::offset_of!(AVOption, min) - 32usize];
    ["Offset of field: AVOption::max"][::std::mem::offset_of!(AVOption, max) - 40usize];
    ["Offset of field: AVOption::flags"][::std::mem::offset_of!(AVOption, flags) - 48usize];
    ["Offset of field: AVOption::unit"][::std::mem::offset_of!(AVOption, unit) - 56usize];
};
#[doc = " A single allowed range of values, or a single allowed value."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct AVOptionRange {
    pub str_: *const libc::c_char,
    #[doc = " Value range.\n For string ranges this represents the min/max length.\n For dimensions this represents the min/max pixel count or width/height in multi-component case."]
    pub value_min: f64,
    #[doc = " Value range.\n For string ranges this represents the min/max length.\n For dimensions this represents the min/max pixel count or width/height in multi-component case."]
    pub value_max: f64,
    #[doc = " Value's component range.\n For string this represents the unicode range for chars, 0-127 limits to ASCII."]
    pub component_min: f64,
    #[doc = " Value's component range.\n For string this represents the unicode range for chars, 0-127 limits to ASCII."]
    pub component_max: f64,
    #[doc = " Range flag.\n If set to 1 the struct encodes a range, if set to 0 a single value."]
    pub is_range: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVOptionRange"][::std::mem::size_of::<AVOptionRange>() - 48usize];
    ["Alignment of AVOptionRange"][::std::mem::align_of::<AVOptionRange>() - 8usize];
    ["Offset of field: AVOptionRange::str_"][::std::mem::offset_of!(AVOptionRange, str_) - 0usize];
    ["Offset of field: AVOptionRange::value_min"]
        [::std::mem::offset_of!(AVOptionRange, value_min) - 8usize];
    ["Offset of field: AVOptionRange::value_max"]
        [::std::mem::offset_of!(AVOptionRange, value_max) - 16usize];
    ["Offset of field: AVOptionRange::component_min"]
        [::std::mem::offset_of!(AVOptionRange, component_min) - 24usize];
    ["Offset of field: AVOptionRange::component_max"]
        [::std::mem::offset_of!(AVOptionRange, component_max) - 32usize];
    ["Offset of field: AVOptionRange::is_range"]
        [::std::mem::offset_of!(AVOptionRange, is_range) - 40usize];
};
#[doc = " List of AVOptionRange structs."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVOptionRanges {
    #[doc = " Array of option ranges.\n\n Most of option types use just one component.\n Following describes multi-component option types:\n\n AV_OPT_TYPE_IMAGE_SIZE:\n component index 0: range of pixel count (width * height).\n component index 1: range of width.\n component index 2: range of height.\n\n @note To obtain multi-component version of this structure, user must\n       provide AV_OPT_MULTI_COMPONENT_RANGE to av_opt_query_ranges or\n       av_opt_query_ranges_default function.\n\n Multi-component range can be read as in following example:\n\n @code\n int range_index, component_index;\n AVOptionRanges *ranges;\n AVOptionRange *range[3]; //may require more than 3 in the future.\n av_opt_query_ranges(&ranges, obj, key, AV_OPT_MULTI_COMPONENT_RANGE);\n for (range_index = 0; range_index < ranges->nb_ranges; range_index++) {\n     for (component_index = 0; component_index < ranges->nb_components; component_index++)\n         range[component_index] = ranges->range[ranges->nb_ranges * component_index + range_index];\n     //do something with range here.\n }\n av_opt_freep_ranges(&ranges);\n @endcode"]
    pub range: *mut *mut AVOptionRange,
    #[doc = " Number of ranges per component."]
    pub nb_ranges: libc::c_int,
    #[doc = " Number of componentes."]
    pub nb_components: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVOptionRanges"][::std::mem::size_of::<AVOptionRanges>() - 16usize];
    ["Alignment of AVOptionRanges"][::std::mem::align_of::<AVOptionRanges>() - 8usize];
    ["Offset of field: AVOptionRanges::range"]
        [::std::mem::offset_of!(AVOptionRanges, range) - 0usize];
    ["Offset of field: AVOptionRanges::nb_ranges"]
        [::std::mem::offset_of!(AVOptionRanges, nb_ranges) - 8usize];
    ["Offset of field: AVOptionRanges::nb_components"]
        [::std::mem::offset_of!(AVOptionRanges, nb_components) - 12usize];
};
extern "C" {
    #[doc = " Show the obj options.\n\n @param req_flags requested flags for the options to show. Show only the\n options for which it is opt->flags & req_flags.\n @param rej_flags rejected flags for the options to show. Show only the\n options for which it is !(opt->flags & req_flags).\n @param av_log_obj log context to use for showing the options"]
    pub fn av_opt_show2(
        obj: *mut libc::c_void,
        av_log_obj: *mut libc::c_void,
        req_flags: libc::c_int,
        rej_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the values of all AVOption fields to their default values.\n\n @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)"]
    pub fn av_opt_set_defaults(s: *mut libc::c_void);
}
extern "C" {
    #[doc = " Set the values of all AVOption fields to their default values. Only these\n AVOption fields for which (opt->flags & mask) == flags will have their\n default applied to s.\n\n @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)\n @param mask combination of AV_OPT_FLAG_*\n @param flags combination of AV_OPT_FLAG_*"]
    pub fn av_opt_set_defaults2(s: *mut libc::c_void, mask: libc::c_int, flags: libc::c_int);
}
extern "C" {
    #[doc = " Parse the key/value pairs list in opts. For each key/value pair\n found, stores the value in the field in ctx that is named like the\n key. ctx must be an AVClass context, storing is done using\n AVOptions.\n\n @param opts options string to parse, may be NULL\n @param key_val_sep a 0-terminated list of characters used to\n separate key from value\n @param pairs_sep a 0-terminated list of characters used to separate\n two pairs from each other\n @return the number of successfully set key/value pairs, or a negative\n value corresponding to an AVERROR code in case of error:\n AVERROR(EINVAL) if opts cannot be parsed,\n the error code issued by av_opt_set() if a key/value pair\n cannot be set"]
    pub fn av_set_options_string(
        ctx: *mut libc::c_void,
        opts: *const libc::c_char,
        key_val_sep: *const libc::c_char,
        pairs_sep: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Parse the key-value pairs list in opts. For each key=value pair found,\n set the value of the corresponding option in ctx.\n\n @param ctx          the AVClass object to set options on\n @param opts         the options string, key-value pairs separated by a\n                     delimiter\n @param shorthand    a NULL-terminated array of options names for shorthand\n                     notation: if the first field in opts has no key part,\n                     the key is taken from the first element of shorthand;\n                     then again for the second, etc., until either opts is\n                     finished, shorthand is finished or a named option is\n                     found; after that, all options must be named\n @param key_val_sep  a 0-terminated list of characters used to separate\n                     key from value, for example '='\n @param pairs_sep    a 0-terminated list of characters used to separate\n                     two pairs from each other, for example ':' or ','\n @return  the number of successfully set key=value pairs, or a negative\n          value corresponding to an AVERROR code in case of error:\n          AVERROR(EINVAL) if opts cannot be parsed,\n          the error code issued by av_set_string3() if a key/value pair\n          cannot be set\n\n Options names must use only the following characters: a-z A-Z 0-9 - . / _\n Separators must use characters distinct from option names and from each\n other."]
    pub fn av_opt_set_from_string(
        ctx: *mut libc::c_void,
        opts: *const libc::c_char,
        shorthand: *const *const libc::c_char,
        key_val_sep: *const libc::c_char,
        pairs_sep: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Free all allocated objects in obj."]
    pub fn av_opt_free(obj: *mut libc::c_void);
}
extern "C" {
    #[doc = " Check whether a particular flag is set in a flags field.\n\n @param field_name the name of the flag field option\n @param flag_name the name of the flag to check\n @return non-zero if the flag is set, zero if the flag isn't set,\n         isn't of the right type, or the flags field doesn't exist."]
    pub fn av_opt_flag_is_set(
        obj: *mut libc::c_void,
        field_name: *const libc::c_char,
        flag_name: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set all the options from a given dictionary on an object.\n\n @param obj a struct whose first element is a pointer to AVClass\n @param options options to process. This dictionary will be freed and replaced\n                by a new one containing all options not found in obj.\n                Of course this new dictionary needs to be freed by caller\n                with av_dict_free().\n\n @return 0 on success, a negative AVERROR if some option was found in obj,\n         but could not be set.\n\n @see av_dict_copy()"]
    pub fn av_opt_set_dict(obj: *mut libc::c_void, options: *mut *mut AVDictionary) -> libc::c_int;
}
extern "C" {
    #[doc = " Set all the options from a given dictionary on an object.\n\n @param obj a struct whose first element is a pointer to AVClass\n @param options options to process. This dictionary will be freed and replaced\n                by a new one containing all options not found in obj.\n                Of course this new dictionary needs to be freed by caller\n                with av_dict_free().\n @param search_flags A combination of AV_OPT_SEARCH_*.\n\n @return 0 on success, a negative AVERROR if some option was found in obj,\n         but could not be set.\n\n @see av_dict_copy()"]
    pub fn av_opt_set_dict2(
        obj: *mut libc::c_void,
        options: *mut *mut AVDictionary,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Extract a key-value pair from the beginning of a string.\n\n @param ropts        pointer to the options string, will be updated to\n                     point to the rest of the string (one of the pairs_sep\n                     or the final NUL)\n @param key_val_sep  a 0-terminated list of characters used to separate\n                     key from value, for example '='\n @param pairs_sep    a 0-terminated list of characters used to separate\n                     two pairs from each other, for example ':' or ','\n @param flags        flags; see the AV_OPT_FLAG_* values below\n @param rkey         parsed key; must be freed using av_free()\n @param rval         parsed value; must be freed using av_free()\n\n @return  >=0 for success, or a negative value corresponding to an\n          AVERROR code in case of error; in particular:\n          AVERROR(EINVAL) if no key is present\n"]
    pub fn av_opt_get_key_value(
        ropts: *mut *const libc::c_char,
        key_val_sep: *const libc::c_char,
        pairs_sep: *const libc::c_char,
        flags: libc::c_uint,
        rkey: *mut *mut libc::c_char,
        rval: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
pub const AV_OPT_FLAG_IMPLICIT_KEY: _bindgen_ty_5 = _bindgen_ty_5::AV_OPT_FLAG_IMPLICIT_KEY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_5 {
    #[doc = " Accept to parse a value without a key; the key will then be returned\n as NULL."]
    AV_OPT_FLAG_IMPLICIT_KEY = 1,
}
extern "C" {
    #[doc = " @defgroup opt_eval_funcs Evaluating option strings\n @{\n This group of functions can be used to evaluate option strings\n and get numbers out of them. They do the same thing as av_opt_set(),\n except the result is written into the caller-supplied pointer.\n\n @param obj a struct whose first element is a pointer to AVClass.\n @param o an option for which the string is to be evaluated.\n @param val string to be evaluated.\n @param *_out value of the string will be written here.\n\n @return 0 on success, a negative number on failure."]
    pub fn av_opt_eval_flags(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        flags_out: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_int(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        int_out: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_int64(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        int64_out: *mut i64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_float(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        float_out: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_double(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        double_out: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_q(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        q_out: *mut AVRational,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Look for an option in an object. Consider only options which\n have all the specified flags set.\n\n @param[in] obj A pointer to a struct whose first element is a\n                pointer to an AVClass.\n                Alternatively a double pointer to an AVClass, if\n                AV_OPT_SEARCH_FAKE_OBJ search flag is set.\n @param[in] name The name of the option to look for.\n @param[in] unit When searching for named constants, name of the unit\n                 it belongs to.\n @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).\n @param search_flags A combination of AV_OPT_SEARCH_*.\n\n @return A pointer to the option found, or NULL if no option\n         was found.\n\n @note Options found with AV_OPT_SEARCH_CHILDREN flag may not be settable\n directly with av_opt_set(). Use special calls which take an options\n AVDictionary (e.g. avformat_open_input()) to set options found with this\n flag."]
    pub fn av_opt_find(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        unit: *const libc::c_char,
        opt_flags: libc::c_int,
        search_flags: libc::c_int,
    ) -> *const AVOption;
}
extern "C" {
    #[doc = " Look for an option in an object. Consider only options which\n have all the specified flags set.\n\n @param[in] obj A pointer to a struct whose first element is a\n                pointer to an AVClass.\n                Alternatively a double pointer to an AVClass, if\n                AV_OPT_SEARCH_FAKE_OBJ search flag is set.\n @param[in] name The name of the option to look for.\n @param[in] unit When searching for named constants, name of the unit\n                 it belongs to.\n @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).\n @param search_flags A combination of AV_OPT_SEARCH_*.\n @param[out] target_obj if non-NULL, an object to which the option belongs will be\n written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present\n in search_flags. This parameter is ignored if search_flags contain\n AV_OPT_SEARCH_FAKE_OBJ.\n\n @return A pointer to the option found, or NULL if no option\n         was found."]
    pub fn av_opt_find2(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        unit: *const libc::c_char,
        opt_flags: libc::c_int,
        search_flags: libc::c_int,
        target_obj: *mut *mut libc::c_void,
    ) -> *const AVOption;
}
extern "C" {
    #[doc = " Iterate over all AVOptions belonging to obj.\n\n @param obj an AVOptions-enabled struct or a double pointer to an\n            AVClass describing it.\n @param prev result of the previous call to av_opt_next() on this object\n             or NULL\n @return next AVOption or NULL"]
    pub fn av_opt_next(obj: *const libc::c_void, prev: *const AVOption) -> *const AVOption;
}
extern "C" {
    #[doc = " Iterate over AVOptions-enabled children of obj.\n\n @param prev result of a previous call to this function or NULL\n @return next AVOptions-enabled child or NULL"]
    pub fn av_opt_child_next(obj: *mut libc::c_void, prev: *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Iterate over potential AVOptions-enabled children of parent.\n\n @param prev result of a previous call to this function or NULL\n @return AVClass corresponding to next potential child or NULL\n\n @deprecated use av_opt_child_class_iterate"]
    pub fn av_opt_child_class_next(parent: *const AVClass, prev: *const AVClass) -> *const AVClass;
}
extern "C" {
    #[doc = " Iterate over potential AVOptions-enabled children of parent.\n\n @param iter a pointer where iteration state is stored.\n @return AVClass corresponding to next potential child or NULL"]
    pub fn av_opt_child_class_iterate(
        parent: *const AVClass,
        iter: *mut *mut libc::c_void,
    ) -> *const AVClass;
}
extern "C" {
    #[doc = " @defgroup opt_set_funcs Option setting functions\n @{\n Those functions set the field of obj with the given name to value.\n\n @param[in] obj A struct whose first element is a pointer to an AVClass.\n @param[in] name the name of the field to set\n @param[in] val The value to set. In case of av_opt_set() if the field is not\n of a string type, then the given string is parsed.\n SI postfixes and some named scalars are supported.\n If the field is of a numeric type, it has to be a numeric or named\n scalar. Behavior with more than one scalar and +- infix operators\n is undefined.\n If the field is of a flags type, it has to be a sequence of numeric\n scalars or named flags separated by '+' or '-'. Prefixing a flag\n with '+' causes it to be set without affecting the other flags;\n similarly, '-' unsets a flag.\n If the field is of a dictionary type, it has to be a ':' separated list of\n key=value parameters. Values containing ':' special characters must be\n escaped.\n @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN\n is passed here, then the option may be set on a child of obj.\n\n @return 0 if the value has been set, or an AVERROR code in case of\n error:\n AVERROR_OPTION_NOT_FOUND if no matching option exists\n AVERROR(ERANGE) if the value is out of range\n AVERROR(EINVAL) if the value is not valid"]
    pub fn av_opt_set(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: *const libc::c_char,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_int(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: i64,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_double(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: f64,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_q(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: AVRational,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_bin(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: *const u8,
        size: libc::c_int,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_image_size(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        w: libc::c_int,
        h: libc::c_int,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_pixel_fmt(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        fmt: AVPixelFormat,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_sample_fmt(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        fmt: AVSampleFormat,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_video_rate(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: AVRational,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_channel_layout(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        ch_layout: i64,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @note Any old dictionary present is discarded and replaced with a copy of the new one. The\n caller still owns val is and responsible for freeing it."]
    pub fn av_opt_set_dict_val(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: *const AVDictionary,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @defgroup opt_get_funcs Option getting functions\n @{\n Those functions get a value of the option with the given name from an object.\n\n @param[in] obj a struct whose first element is a pointer to an AVClass.\n @param[in] name name of the option to get.\n @param[in] search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN\n is passed here, then the option may be found in a child of obj.\n @param[out] out_val value of the option will be written here\n @return >=0 on success, a negative error code otherwise\n/\n/**\n @note the returned string will be av_malloc()ed and must be av_free()ed by the caller\n\n @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the\n option is of type AV_OPT_TYPE_STRING, AV_OPT_TYPE_BINARY or AV_OPT_TYPE_DICT\n and is set to NULL, *out_val will be set to NULL instead of an allocated\n empty string."]
    pub fn av_opt_get(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut *mut u8,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_int(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut i64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_double(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_q(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut AVRational,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_image_size(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        w_out: *mut libc::c_int,
        h_out: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_pixel_fmt(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_fmt: *mut AVPixelFormat,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_sample_fmt(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_fmt: *mut AVSampleFormat,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_video_rate(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut AVRational,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_channel_layout(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        ch_layout: *mut i64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @param[out] out_val The returned dictionary is a copy of the actual value and must\n be freed with av_dict_free() by the caller"]
    pub fn av_opt_get_dict_val(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @}\n/\n/**\n Gets a pointer to the requested field in a struct.\n This function allows accessing a struct even when its fields are moved or\n renamed since the application making the access has been compiled,\n\n @returns a pointer to the field, it can be cast to the correct type and read\n          or written to."]
    pub fn av_opt_ptr(
        avclass: *const AVClass,
        obj: *mut libc::c_void,
        name: *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Free an AVOptionRanges struct and set it to NULL."]
    pub fn av_opt_freep_ranges(ranges: *mut *mut AVOptionRanges);
}
extern "C" {
    #[doc = " Get a list of allowed ranges for the given option.\n\n The returned list may depend on other fields in obj like for example profile.\n\n @param flags is a bitmask of flags, undefined flags should not be set and should be ignored\n              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance\n              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges\n\n The result must be freed with av_opt_freep_ranges.\n\n @return number of compontents returned on success, a negative errro code otherwise"]
    pub fn av_opt_query_ranges(
        arg1: *mut *mut AVOptionRanges,
        obj: *mut libc::c_void,
        key: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy options from src object into dest object.\n\n Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object.\n Original memory allocated for such options is freed unless both src and dest options points to the same memory.\n\n @param dest Object to copy from\n @param src  Object to copy into\n @return 0 on success, negative on error"]
    pub fn av_opt_copy(dest: *mut libc::c_void, src: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    #[doc = " Get a default list of allowed ranges for the given option.\n\n This list is constructed without using the AVClass.query_ranges() callback\n and can be used as fallback from within the callback.\n\n @param flags is a bitmask of flags, undefined flags should not be set and should be ignored\n              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance\n              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges\n\n The result must be freed with av_opt_free_ranges.\n\n @return number of compontents returned on success, a negative errro code otherwise"]
    pub fn av_opt_query_ranges_default(
        arg1: *mut *mut AVOptionRanges,
        obj: *mut libc::c_void,
        key: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Check if given option is set to its default value.\n\n Options o must belong to the obj. This function must not be called to check child's options state.\n @see av_opt_is_set_to_default_by_name().\n\n @param obj  AVClass object to check option on\n @param o    option to be checked\n @return     >0 when option is set to its default,\n              0 when option is not set its default,\n             <0 on error"]
    pub fn av_opt_is_set_to_default(obj: *mut libc::c_void, o: *const AVOption) -> libc::c_int;
}
extern "C" {
    #[doc = " Check if given option is set to its default value.\n\n @param obj          AVClass object to check option on\n @param name         option name\n @param search_flags combination of AV_OPT_SEARCH_*\n @return             >0 when option is set to its default,\n                     0 when option is not set its default,\n                     <0 on error"]
    pub fn av_opt_is_set_to_default_by_name(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize object's options.\n\n Create a string containing object's serialized options.\n Such string may be passed back to av_opt_set_from_string() in order to restore option values.\n A key/value or pairs separator occurring in the serialized value or\n name string are escaped through the av_escape() function.\n\n @param[in]  obj           AVClass object to serialize\n @param[in]  opt_flags     serialize options with all the specified flags set (AV_OPT_FLAG)\n @param[in]  flags         combination of AV_OPT_SERIALIZE_* flags\n @param[out] buffer        Pointer to buffer that will be allocated with string containg serialized options.\n                           Buffer must be freed by the caller when is no longer needed.\n @param[in]  key_val_sep   character used to separate key from value\n @param[in]  pairs_sep     character used to separate two pairs from each other\n @return                   >= 0 on success, negative on error\n @warning Separators cannot be neither '\\\\' nor '\\0'. They also cannot be the same."]
    pub fn av_opt_serialize(
        obj: *mut libc::c_void,
        opt_flags: libc::c_int,
        flags: libc::c_int,
        buffer: *mut *mut libc::c_char,
        key_val_sep: libc::c_char,
        pairs_sep: libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Parse str and store the parsed ratio in q.\n\n Note that a ratio with infinite (1/0) or negative value is\n considered valid, so you should check on the returned value if you\n want to exclude those values.\n\n The undefined value can be expressed using the \"0:0\" string.\n\n @param[in,out] q pointer to the AVRational which will contain the ratio\n @param[in] str the string to parse: it has to be a string in the format\n num:den, a float number or an expression\n @param[in] max the maximum allowed numerator and denominator\n @param[in] log_offset log level offset which is applied to the log\n level of log_ctx\n @param[in] log_ctx parent logging context\n @return >= 0 on success, a negative error code otherwise"]
    pub fn av_parse_ratio(
        q: *mut AVRational,
        str_: *const libc::c_char,
        max: libc::c_int,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Parse str and put in width_ptr and height_ptr the detected values.\n\n @param[in,out] width_ptr pointer to the variable which will contain the detected\n width value\n @param[in,out] height_ptr pointer to the variable which will contain the detected\n height value\n @param[in] str the string to parse: it has to be a string in the format\n width x height or a valid video size abbreviation.\n @return >= 0 on success, a negative error code otherwise"]
    pub fn av_parse_video_size(
        width_ptr: *mut libc::c_int,
        height_ptr: *mut libc::c_int,
        str_: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Parse str and store the detected values in *rate.\n\n @param[in,out] rate pointer to the AVRational which will contain the detected\n frame rate\n @param[in] str the string to parse: it has to be a string in the format\n rate_num / rate_den, a float number or a valid video rate abbreviation\n @return >= 0 on success, a negative error code otherwise"]
    pub fn av_parse_video_rate(rate: *mut AVRational, str_: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Put the RGBA values that correspond to color_string in rgba_color.\n\n @param color_string a string specifying a color. It can be the name of\n a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence,\n possibly followed by \"@\" and a string representing the alpha\n component.\n The alpha component may be a string composed by \"0x\" followed by an\n hexadecimal number or a decimal number between 0.0 and 1.0, which\n represents the opacity value (0x00/0.0 means completely transparent,\n 0xff/1.0 completely opaque).\n If the alpha component is not specified then 0xff is assumed.\n The string \"random\" will result in a random color.\n @param slen length of the initial part of color_string containing the\n color. It can be set to -1 if color_string is a null terminated string\n containing nothing else than the color.\n @return >= 0 in case of success, a negative value in case of\n failure (for example if color_string cannot be parsed)."]
    pub fn av_parse_color(
        rgba_color: *mut u8,
        color_string: *const libc::c_char,
        slen: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the name of a color from the internal table of hard-coded named\n colors.\n\n This function is meant to enumerate the color names recognized by\n av_parse_color().\n\n @param color_idx index of the requested color, starting from 0\n @param rgbp      if not NULL, will point to a 3-elements array with the color value in RGB\n @return the color name string or NULL if color_idx is not in the array"]
    pub fn av_get_known_color_name(
        color_idx: libc::c_int,
        rgb: *mut *const u8,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Parse timestr and return in *time a corresponding number of\n microseconds.\n\n @param timeval puts here the number of microseconds corresponding\n to the string in timestr. If the string represents a duration, it\n is the number of microseconds contained in the time interval.  If\n the string is a date, is the number of microseconds since 1st of\n January, 1970 up to the time of the parsed date.  If timestr cannot\n be successfully parsed, set *time to INT64_MIN.\n\n @param timestr a string representing a date or a duration.\n - If a date the syntax is:\n @code\n [{YYYY-MM-DD|YYYYMMDD}[T|t| ]]{{HH:MM:SS[.m...]]]}|{HHMMSS[.m...]]]}}[Z]\n now\n @endcode\n If the value is \"now\" it takes the current time.\n Time is local time unless Z is appended, in which case it is\n interpreted as UTC.\n If the year-month-day part is not specified it takes the current\n year-month-day.\n - If a duration the syntax is:\n @code\n [-][HH:]MM:SS[.m...]\n [-]S+[.m...]\n @endcode\n @param duration flag which tells how to interpret timestr, if not\n zero timestr is interpreted as a duration, otherwise as a date\n @return >= 0 in case of success, a negative value corresponding to an\n AVERROR code otherwise"]
    pub fn av_parse_time(
        timeval: *mut i64,
        timestr: *const libc::c_char,
        duration: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Attempt to find a specific tag in a URL.\n\n syntax: '?tag1=val1&tag2=val2...'. Little URL decoding is done.\n Return 1 if found."]
    pub fn av_find_info_tag(
        arg: *mut libc::c_char,
        arg_size: libc::c_int,
        tag1: *const libc::c_char,
        info: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Simplified version of strptime\n\n Parse the input string p according to the format string fmt and\n store its results in the structure dt.\n This implementation supports only a subset of the formats supported\n by the standard strptime().\n\n The supported input field descriptors are listed below.\n - %H: the hour as a decimal number, using a 24-hour clock, in the\n   range '00' through '23'\n - %J: hours as a decimal number, in the range '0' through INT_MAX\n - %M: the minute as a decimal number, using a 24-hour clock, in the\n   range '00' through '59'\n - %S: the second as a decimal number, using a 24-hour clock, in the\n   range '00' through '59'\n - %Y: the year as a decimal number, using the Gregorian calendar\n - %m: the month as a decimal number, in the range '1' through '12'\n - %d: the day of the month as a decimal number, in the range '1'\n   through '31'\n - %T: alias for '%H:%M:%S'\n - %%: a literal '%'\n\n @return a pointer to the first character not processed in this function\n         call. In case the input string contains more characters than\n         required by the format string the return value points right after\n         the last consumed input character. In case the whole input string\n         is consumed the return value points to the null byte at the end of\n         the string. On failure NULL is returned."]
    pub fn av_small_strptime(
        p: *const libc::c_char,
        fmt: *const libc::c_char,
        dt: *mut tm,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Convert the decomposed UTC time in tm to a time_t value."]
    pub fn av_timegm(tm: *mut tm) -> time_t;
}
extern "C" {
    #[doc = " Get a seed to use in conjunction with random functions.\n This function tries to provide a good seed at a best effort bases.\n Its possible to call this function multiple times if more bits are needed.\n It can be quite slow, which is why it should only be used as seed for a faster\n PRNG. The quality of the seed depends on the platform."]
    pub fn av_get_random_seed() -> u32;
}
#[doc = " ReplayGain information (see\n http://wiki.hydrogenaudio.org/index.php?title=ReplayGain_1.0_specification).\n The size of this struct is a part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVReplayGain {
    #[doc = " Track replay gain in microbels (divide by 100000 to get the value in dB).\n Should be set to INT32_MIN when unknown."]
    pub track_gain: i32,
    #[doc = " Peak track amplitude, with 100000 representing full scale (but values\n may overflow). 0 when unknown."]
    pub track_peak: u32,
    #[doc = " Same as track_gain, but for the whole album."]
    pub album_gain: i32,
    #[doc = " Same as track_peak, but for the whole album,"]
    pub album_peak: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVReplayGain"][::std::mem::size_of::<AVReplayGain>() - 16usize];
    ["Alignment of AVReplayGain"][::std::mem::align_of::<AVReplayGain>() - 4usize];
    ["Offset of field: AVReplayGain::track_gain"]
        [::std::mem::offset_of!(AVReplayGain, track_gain) - 0usize];
    ["Offset of field: AVReplayGain::track_peak"]
        [::std::mem::offset_of!(AVReplayGain, track_peak) - 4usize];
    ["Offset of field: AVReplayGain::album_gain"]
        [::std::mem::offset_of!(AVReplayGain, album_gain) - 8usize];
    ["Offset of field: AVReplayGain::album_peak"]
        [::std::mem::offset_of!(AVReplayGain, album_peak) - 12usize];
};
extern "C" {
    #[doc = " @defgroup lavu_ripemd RIPEMD\n @ingroup lavu_hash\n RIPEMD hash function implementation.\n\n @{"]
    pub static av_ripemd_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVRIPEMD {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVRIPEMD context."]
    pub fn av_ripemd_alloc() -> *mut AVRIPEMD;
}
extern "C" {
    #[doc = " Initialize RIPEMD hashing.\n\n @param context pointer to the function context (of size av_ripemd_size)\n @param bits    number of bits in digest (128, 160, 256 or 320 bits)\n @return        zero if initialization succeeded, -1 otherwise"]
    pub fn av_ripemd_init(context: *mut AVRIPEMD, bits: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_ripemd_update(context: *mut AVRIPEMD, data: *const u8, len: libc::c_uint);
}
extern "C" {
    #[doc = " Finish hashing and output digest value.\n\n @param context hash function context\n @param digest  buffer where output digest value is stored"]
    pub fn av_ripemd_final(context: *mut AVRIPEMD, digest: *mut u8);
}
extern "C" {
    #[doc = " @defgroup lavu_sha SHA\n @ingroup lavu_hash\n SHA-1 and SHA-256 (Secure Hash Algorithm) hash function implementations.\n\n This module supports the following SHA hash functions:\n\n - SHA-1: 160 bits\n - SHA-224: 224 bits, as a variant of SHA-2\n - SHA-256: 256 bits, as a variant of SHA-2\n\n @see For SHA-384, SHA-512, and variants thereof, see @ref lavu_sha512.\n\n @{"]
    pub static av_sha_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSHA {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVSHA context."]
    pub fn av_sha_alloc() -> *mut AVSHA;
}
extern "C" {
    #[doc = " Initialize SHA-1 or SHA-2 hashing.\n\n @param context pointer to the function context (of size av_sha_size)\n @param bits    number of bits in digest (SHA-1 - 160 bits, SHA-2 224 or 256 bits)\n @return        zero if initialization succeeded, -1 otherwise"]
    pub fn av_sha_init(context: *mut AVSHA, bits: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_sha_update(ctx: *mut AVSHA, data: *const u8, len: libc::c_uint);
}
extern "C" {
    #[doc = " Finish hashing and output digest value.\n\n @param context hash function context\n @param digest  buffer where output digest value is stored"]
    pub fn av_sha_final(context: *mut AVSHA, digest: *mut u8);
}
extern "C" {
    #[doc = " @defgroup lavu_sha512 SHA-512\n @ingroup lavu_hash\n SHA-512 (Secure Hash Algorithm) hash function implementations.\n\n This module supports the following SHA-2 hash functions:\n\n - SHA-512/224: 224 bits\n - SHA-512/256: 256 bits\n - SHA-384: 384 bits\n - SHA-512: 512 bits\n\n @see For SHA-1, SHA-256, and variants thereof, see @ref lavu_sha.\n\n @{"]
    pub static av_sha512_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSHA512 {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVSHA512 context."]
    pub fn av_sha512_alloc() -> *mut AVSHA512;
}
extern "C" {
    #[doc = " Initialize SHA-2 512 hashing.\n\n @param context pointer to the function context (of size av_sha512_size)\n @param bits    number of bits in digest (224, 256, 384 or 512 bits)\n @return        zero if initialization succeeded, -1 otherwise"]
    pub fn av_sha512_init(context: *mut AVSHA512, bits: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_sha512_update(context: *mut AVSHA512, data: *const u8, len: libc::c_uint);
}
extern "C" {
    #[doc = " Finish hashing and output digest value.\n\n @param context hash function context\n @param digest  buffer where output digest value is stored"]
    pub fn av_sha512_final(context: *mut AVSHA512, digest: *mut u8);
}
#[repr(u32)]
#[doc = " List of possible 3D Types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVStereo3DType {
    #[doc = " Video is not stereoscopic (and metadata has to be there)."]
    AV_STEREO3D_2D = 0,
    #[doc = " Views are next to each other.\n\n @code{.unparsed}\n    LLLLRRRR\n    LLLLRRRR\n    LLLLRRRR\n    ...\n @endcode"]
    AV_STEREO3D_SIDEBYSIDE = 1,
    #[doc = " Views are on top of each other.\n\n @code{.unparsed}\n    LLLLLLLL\n    LLLLLLLL\n    RRRRRRRR\n    RRRRRRRR\n @endcode"]
    AV_STEREO3D_TOPBOTTOM = 2,
    #[doc = " Views are alternated temporally.\n\n @code{.unparsed}\n     frame0   frame1   frame2   ...\n    LLLLLLLL RRRRRRRR LLLLLLLL\n    LLLLLLLL RRRRRRRR LLLLLLLL\n    LLLLLLLL RRRRRRRR LLLLLLLL\n    ...      ...      ...\n @endcode"]
    AV_STEREO3D_FRAMESEQUENCE = 3,
    #[doc = " Views are packed in a checkerboard-like structure per pixel.\n\n @code{.unparsed}\n    LRLRLRLR\n    RLRLRLRL\n    LRLRLRLR\n    ...\n @endcode"]
    AV_STEREO3D_CHECKERBOARD = 4,
    #[doc = " Views are next to each other, but when upscaling\n apply a checkerboard pattern.\n\n @code{.unparsed}\n     LLLLRRRR          L L L L    R R R R\n     LLLLRRRR    =>     L L L L  R R R R\n     LLLLRRRR          L L L L    R R R R\n     LLLLRRRR           L L L L  R R R R\n @endcode"]
    AV_STEREO3D_SIDEBYSIDE_QUINCUNX = 5,
    #[doc = " Views are packed per line, as if interlaced.\n\n @code{.unparsed}\n    LLLLLLLL\n    RRRRRRRR\n    LLLLLLLL\n    ...\n @endcode"]
    AV_STEREO3D_LINES = 6,
    #[doc = " Views are packed per column.\n\n @code{.unparsed}\n    LRLRLRLR\n    LRLRLRLR\n    LRLRLRLR\n    ...\n @endcode"]
    AV_STEREO3D_COLUMNS = 7,
}
#[repr(u32)]
#[doc = " List of possible view types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVStereo3DView {
    #[doc = " Frame contains two packed views."]
    AV_STEREO3D_VIEW_PACKED = 0,
    #[doc = " Frame contains only the left view."]
    AV_STEREO3D_VIEW_LEFT = 1,
    #[doc = " Frame contains only the right view."]
    AV_STEREO3D_VIEW_RIGHT = 2,
}
#[doc = " Stereo 3D type: this structure describes how two videos are packed\n within a single video surface, with additional information as needed.\n\n @note The struct must be allocated with av_stereo3d_alloc() and\n       its size is not a part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVStereo3D {
    #[doc = " How views are packed within the video."]
    pub type_: AVStereo3DType,
    #[doc = " Additional information about the frame packing."]
    pub flags: libc::c_int,
    #[doc = " Determines which views are packed."]
    pub view: AVStereo3DView,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVStereo3D"][::std::mem::size_of::<AVStereo3D>() - 12usize];
    ["Alignment of AVStereo3D"][::std::mem::align_of::<AVStereo3D>() - 4usize];
    ["Offset of field: AVStereo3D::type_"][::std::mem::offset_of!(AVStereo3D, type_) - 0usize];
    ["Offset of field: AVStereo3D::flags"][::std::mem::offset_of!(AVStereo3D, flags) - 4usize];
    ["Offset of field: AVStereo3D::view"][::std::mem::offset_of!(AVStereo3D, view) - 8usize];
};
extern "C" {
    #[doc = " Allocate an AVStereo3D structure and set its fields to default values.\n The resulting struct can be freed using av_freep().\n\n @return An AVStereo3D filled with default values or NULL on failure."]
    pub fn av_stereo3d_alloc() -> *mut AVStereo3D;
}
extern "C" {
    #[doc = " Allocate a complete AVFrameSideData and add it to the frame.\n\n @param frame The frame which side data is added to.\n\n @return The AVStereo3D structure to be filled by caller."]
    pub fn av_stereo3d_create_side_data(frame: *mut AVFrame) -> *mut AVStereo3D;
}
extern "C" {
    #[doc = " Provide a human-readable name of a given stereo3d type.\n\n @param type The input stereo3d type value.\n\n @return The name of the stereo3d value, or \"unknown\"."]
    pub fn av_stereo3d_type_name(type_: libc::c_uint) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the AVStereo3DType form a human-readable name.\n\n @param name The input string.\n\n @return The AVStereo3DType value, or -1 if not found."]
    pub fn av_stereo3d_from_name(name: *const libc::c_char) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVThreadMessageQueue {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVThreadMessageFlags {
    #[doc = " Perform non-blocking operation.\n If this flag is set, send and recv operations are non-blocking and\n return AVERROR(EAGAIN) immediately if they can not proceed."]
    AV_THREAD_MESSAGE_NONBLOCK = 1,
}
extern "C" {
    #[doc = " Allocate a new message queue.\n\n @param mq      pointer to the message queue\n @param nelem   maximum number of elements in the queue\n @param elsize  size of each element in the queue\n @return  >=0 for success; <0 for error, in particular AVERROR(ENOSYS) if\n          lavu was built without thread support"]
    pub fn av_thread_message_queue_alloc(
        mq: *mut *mut AVThreadMessageQueue,
        nelem: libc::c_uint,
        elsize: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Free a message queue.\n\n The message queue must no longer be in use by another thread."]
    pub fn av_thread_message_queue_free(mq: *mut *mut AVThreadMessageQueue);
}
extern "C" {
    #[doc = " Send a message on the queue."]
    pub fn av_thread_message_queue_send(
        mq: *mut AVThreadMessageQueue,
        msg: *mut libc::c_void,
        flags: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Receive a message from the queue."]
    pub fn av_thread_message_queue_recv(
        mq: *mut AVThreadMessageQueue,
        msg: *mut libc::c_void,
        flags: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the sending error code.\n\n If the error code is set to non-zero, av_thread_message_queue_send() will\n return it immediately. Conventional values, such as AVERROR_EOF or\n AVERROR(EAGAIN), can be used to cause the sending thread to stop or\n suspend its operation."]
    pub fn av_thread_message_queue_set_err_send(mq: *mut AVThreadMessageQueue, err: libc::c_int);
}
extern "C" {
    #[doc = " Set the receiving error code.\n\n If the error code is set to non-zero, av_thread_message_queue_recv() will\n return it immediately when there are no longer available messages.\n Conventional values, such as AVERROR_EOF or AVERROR(EAGAIN), can be used\n to cause the receiving thread to stop or suspend its operation."]
    pub fn av_thread_message_queue_set_err_recv(mq: *mut AVThreadMessageQueue, err: libc::c_int);
}
extern "C" {
    #[doc = " Set the optional free message callback function which will be called if an\n operation is removing messages from the queue."]
    pub fn av_thread_message_queue_set_free_func(
        mq: *mut AVThreadMessageQueue,
        free_func: ::std::option::Option<unsafe extern "C" fn(msg: *mut libc::c_void)>,
    );
}
extern "C" {
    #[doc = " Return the current number of messages in the queue.\n\n @return the current number of messages or AVERROR(ENOSYS) if lavu was built\n         without thread support"]
    pub fn av_thread_message_queue_nb_elems(mq: *mut AVThreadMessageQueue) -> libc::c_int;
}
extern "C" {
    #[doc = " Flush the message queue\n\n This function is mostly equivalent to reading and free-ing every message\n except that it will be done in a single operation (no lock/unlock between\n reads)."]
    pub fn av_thread_message_flush(mq: *mut AVThreadMessageQueue);
}
extern "C" {
    #[doc = " Get the current time in microseconds."]
    pub fn av_gettime() -> i64;
}
extern "C" {
    #[doc = " Get the current time in microseconds since some unspecified starting point.\n On platforms that support it, the time comes from a monotonic clock\n This property makes this time source ideal for measuring relative time.\n The returned values may not be monotonic on platforms where a monotonic\n clock is not available."]
    pub fn av_gettime_relative() -> i64;
}
extern "C" {
    #[doc = " Indicates with a boolean result if the av_gettime_relative() time source\n is monotonic."]
    pub fn av_gettime_relative_is_monotonic() -> libc::c_int;
}
extern "C" {
    #[doc = " Sleep for a period of time.  Although the duration is expressed in\n microseconds, the actual delay may be rounded to the precision of the\n system timer.\n\n @param  usec Number of microseconds to sleep.\n @return zero on success or (negative) error code."]
    pub fn av_usleep(usec: libc::c_uint) -> libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVTimecodeFlag {
    #[doc = "< timecode is drop frame"]
    AV_TIMECODE_FLAG_DROPFRAME = 1,
    #[doc = "< timecode wraps after 24 hours"]
    AV_TIMECODE_FLAG_24HOURSMAX = 2,
    #[doc = "< negative time values are allowed"]
    AV_TIMECODE_FLAG_ALLOWNEGATIVE = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVTimecode {
    #[doc = "< timecode frame start (first base frame number)"]
    pub start: libc::c_int,
    #[doc = "< flags such as drop frame, +24 hours support, ..."]
    pub flags: u32,
    #[doc = "< frame rate in rational form"]
    pub rate: AVRational,
    #[doc = "< frame per second; must be consistent with the rate field"]
    pub fps: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVTimecode"][::std::mem::size_of::<AVTimecode>() - 20usize];
    ["Alignment of AVTimecode"][::std::mem::align_of::<AVTimecode>() - 4usize];
    ["Offset of field: AVTimecode::start"][::std::mem::offset_of!(AVTimecode, start) - 0usize];
    ["Offset of field: AVTimecode::flags"][::std::mem::offset_of!(AVTimecode, flags) - 4usize];
    ["Offset of field: AVTimecode::rate"][::std::mem::offset_of!(AVTimecode, rate) - 8usize];
    ["Offset of field: AVTimecode::fps"][::std::mem::offset_of!(AVTimecode, fps) - 16usize];
};
extern "C" {
    #[doc = " Adjust frame number for NTSC drop frame time code.\n\n @param framenum frame number to adjust\n @param fps      frame per second, multiples of 30\n @return         adjusted frame number\n @warning        adjustment is only valid for multiples of NTSC 29.97"]
    pub fn av_timecode_adjust_ntsc_framenum2(
        framenum: libc::c_int,
        fps: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Convert frame number to SMPTE 12M binary representation.\n\n @param tc       timecode data correctly initialized\n @param framenum frame number\n @return         the SMPTE binary representation\n\n See SMPTE ST 314M-2005 Sec 4.4.2.2.1 \"Time code pack (TC)\"\n the format description as follows:\n bits 0-5:   hours, in BCD(6bits)\n bits 6:     BGF1\n bits 7:     BGF2 (NTSC) or FIELD (PAL)\n bits 8-14:  minutes, in BCD(7bits)\n bits 15:    BGF0 (NTSC) or BGF2 (PAL)\n bits 16-22: seconds, in BCD(7bits)\n bits 23:    FIELD (NTSC) or BGF0 (PAL)\n bits 24-29: frames, in BCD(6bits)\n bits 30:    drop  frame flag (0: non drop,    1: drop)\n bits 31:    color frame flag (0: unsync mode, 1: sync mode)\n @note BCD numbers (6 or 7 bits): 4 or 5 lower bits for units, 2 higher bits for tens.\n @note Frame number adjustment is automatically done in case of drop timecode,\n       you do NOT have to call av_timecode_adjust_ntsc_framenum2().\n @note The frame number is relative to tc->start.\n @note Color frame (CF) and binary group flags (BGF) bits are set to zero."]
    pub fn av_timecode_get_smpte_from_framenum(tc: *const AVTimecode, framenum: libc::c_int)
        -> u32;
}
extern "C" {
    #[doc = " Convert sei info to SMPTE 12M binary representation.\n\n @param rate     frame rate in rational form\n @param drop     drop flag\n @param hh       hour\n @param mm       minute\n @param ss       second\n @param ff       frame number\n @return         the SMPTE binary representation"]
    pub fn av_timecode_get_smpte(
        rate: AVRational,
        drop: libc::c_int,
        hh: libc::c_int,
        mm: libc::c_int,
        ss: libc::c_int,
        ff: libc::c_int,
    ) -> u32;
}
extern "C" {
    #[doc = " Load timecode string in buf.\n\n @param buf      destination buffer, must be at least AV_TIMECODE_STR_SIZE long\n @param tc       timecode data correctly initialized\n @param framenum frame number\n @return         the buf parameter\n\n @note Timecode representation can be a negative timecode and have more than\n       24 hours, but will only be honored if the flags are correctly set.\n @note The frame number is relative to tc->start."]
    pub fn av_timecode_make_string(
        tc: *const AVTimecode,
        buf: *mut libc::c_char,
        framenum: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Get the timecode string from the SMPTE timecode format.\n\n In contrast to av_timecode_make_smpte_tc_string this function supports 50/60\n fps timecodes by using the field bit.\n\n @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long\n @param rate       frame rate of the timecode\n @param tcsmpte    the 32-bit SMPTE timecode\n @param prevent_df prevent the use of a drop flag when it is known the DF bit\n                   is arbitrary\n @param skip_field prevent the use of a field flag when it is known the field\n                   bit is arbitrary (e.g. because it is used as PC flag)\n @return           the buf parameter"]
    pub fn av_timecode_make_smpte_tc_string2(
        buf: *mut libc::c_char,
        rate: AVRational,
        tcsmpte: u32,
        prevent_df: libc::c_int,
        skip_field: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Get the timecode string from the SMPTE timecode format.\n\n @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long\n @param tcsmpte    the 32-bit SMPTE timecode\n @param prevent_df prevent the use of a drop flag when it is known the DF bit\n                   is arbitrary\n @return           the buf parameter"]
    pub fn av_timecode_make_smpte_tc_string(
        buf: *mut libc::c_char,
        tcsmpte: u32,
        prevent_df: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Get the timecode string from the 25-bit timecode format (MPEG GOP format).\n\n @param buf     destination buffer, must be at least AV_TIMECODE_STR_SIZE long\n @param tc25bit the 25-bits timecode\n @return        the buf parameter"]
    pub fn av_timecode_make_mpeg_tc_string(
        buf: *mut libc::c_char,
        tc25bit: u32,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Init a timecode struct with the passed parameters.\n\n @param log_ctx     a pointer to an arbitrary struct of which the first field\n                    is a pointer to an AVClass struct (used for av_log)\n @param tc          pointer to an allocated AVTimecode\n @param rate        frame rate in rational form\n @param flags       miscellaneous flags such as drop frame, +24 hours, ...\n                    (see AVTimecodeFlag)\n @param frame_start the first frame number\n @return            0 on success, AVERROR otherwise"]
    pub fn av_timecode_init(
        tc: *mut AVTimecode,
        rate: AVRational,
        flags: libc::c_int,
        frame_start: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Init a timecode struct from the passed timecode components.\n\n @param log_ctx     a pointer to an arbitrary struct of which the first field\n                    is a pointer to an AVClass struct (used for av_log)\n @param tc          pointer to an allocated AVTimecode\n @param rate        frame rate in rational form\n @param flags       miscellaneous flags such as drop frame, +24 hours, ...\n                    (see AVTimecodeFlag)\n @param hh          hours\n @param mm          minutes\n @param ss          seconds\n @param ff          frames\n @return            0 on success, AVERROR otherwise"]
    pub fn av_timecode_init_from_components(
        tc: *mut AVTimecode,
        rate: AVRational,
        flags: libc::c_int,
        hh: libc::c_int,
        mm: libc::c_int,
        ss: libc::c_int,
        ff: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Parse timecode representation (hh:mm:ss[:;.]ff).\n\n @param log_ctx a pointer to an arbitrary struct of which the first field is a\n                pointer to an AVClass struct (used for av_log).\n @param tc      pointer to an allocated AVTimecode\n @param rate    frame rate in rational form\n @param str     timecode string which will determine the frame start\n @return        0 on success, AVERROR otherwise"]
    pub fn av_timecode_init_from_string(
        tc: *mut AVTimecode,
        rate: AVRational,
        str_: *const libc::c_char,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Check if the timecode feature is available for the given frame rate\n\n @return 0 if supported, <0 otherwise"]
    pub fn av_timecode_check_frame_rate(rate: AVRational) -> libc::c_int;
}
extern "C" {
    #[doc = " @file\n @brief Public header for libavutil TWOFISH algorithm\n @defgroup lavu_twofish TWOFISH\n @ingroup lavu_crypto\n @{"]
    pub static av_twofish_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVTWOFISH {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVTWOFISH context\n To free the struct: av_free(ptr)"]
    pub fn av_twofish_alloc() -> *mut AVTWOFISH;
}
extern "C" {
    #[doc = " Initialize an AVTWOFISH context.\n\n @param ctx an AVTWOFISH context\n @param key a key of size ranging from 1 to 32 bytes used for encryption/decryption\n @param key_bits number of keybits: 128, 192, 256 If less than the required, padded with zeroes to nearest valid value; return value is 0 if key_bits is 128/192/256, -1 if less than 0, 1 otherwise"]
    pub fn av_twofish_init(
        ctx: *mut AVTWOFISH,
        key: *const u8,
        key_bits: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context\n\n @param ctx an AVTWOFISH context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param count number of 16 byte blocks\n @paran iv initialization vector for CBC mode, NULL for ECB mode\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_twofish_crypt(
        ctx: *mut AVTWOFISH,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
#[doc = " @file\n @brief Public header for libavutil XTEA algorithm\n @defgroup lavu_xtea XTEA\n @ingroup lavu_crypto\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVXTEA {
    pub key: [u32; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVXTEA"][::std::mem::size_of::<AVXTEA>() - 64usize];
    ["Alignment of AVXTEA"][::std::mem::align_of::<AVXTEA>() - 4usize];
    ["Offset of field: AVXTEA::key"][::std::mem::offset_of!(AVXTEA, key) - 0usize];
};
extern "C" {
    #[doc = " Allocate an AVXTEA context."]
    pub fn av_xtea_alloc() -> *mut AVXTEA;
}
extern "C" {
    #[doc = " Initialize an AVXTEA context.\n\n @param ctx an AVXTEA context\n @param key a key of 16 bytes used for encryption/decryption,\n            interpreted as big endian 32 bit numbers"]
    pub fn av_xtea_init(ctx: *mut AVXTEA, key: *const u8);
}
extern "C" {
    #[doc = " Initialize an AVXTEA context.\n\n @param ctx an AVXTEA context\n @param key a key of 16 bytes used for encryption/decryption,\n            interpreted as little endian 32 bit numbers"]
    pub fn av_xtea_le_init(ctx: *mut AVXTEA, key: *const u8);
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context,\n in big endian format.\n\n @param ctx an AVXTEA context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param count number of 8 byte blocks\n @param iv initialization vector for CBC mode, if NULL then ECB will be used\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_xtea_crypt(
        ctx: *mut AVXTEA,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context,\n in little endian format.\n\n @param ctx an AVXTEA context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param count number of 8 byte blocks\n @param iv initialization vector for CBC mode, if NULL then ECB will be used\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_xtea_le_crypt(
        ctx: *mut AVXTEA,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
extern "C" {
    #[doc = " @defgroup libsws libswscale\n Color conversion and scaling library.\n\n @{\n\n Return the LIBSWSCALE_VERSION_INT constant."]
    pub fn swscale_version() -> libc::c_uint;
}
extern "C" {
    #[doc = " Return the libswscale build-time configuration."]
    pub fn swscale_configuration() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return the libswscale license."]
    pub fn swscale_license() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return a pointer to yuv<->rgb coefficients for the given colorspace\n suitable for sws_setColorspaceDetails().\n\n @param colorspace One of the SWS_CS_* macros. If invalid,\n SWS_CS_DEFAULT is used."]
    pub fn sws_getCoefficients(colorspace: libc::c_int) -> *const libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SwsVector {
    #[doc = "< pointer to the list of coefficients"]
    pub coeff: *mut f64,
    #[doc = "< number of coefficients in the vector"]
    pub length: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SwsVector"][::std::mem::size_of::<SwsVector>() - 16usize];
    ["Alignment of SwsVector"][::std::mem::align_of::<SwsVector>() - 8usize];
    ["Offset of field: SwsVector::coeff"][::std::mem::offset_of!(SwsVector, coeff) - 0usize];
    ["Offset of field: SwsVector::length"][::std::mem::offset_of!(SwsVector, length) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SwsFilter {
    pub lumH: *mut SwsVector,
    pub lumV: *mut SwsVector,
    pub chrH: *mut SwsVector,
    pub chrV: *mut SwsVector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SwsFilter"][::std::mem::size_of::<SwsFilter>() - 32usize];
    ["Alignment of SwsFilter"][::std::mem::align_of::<SwsFilter>() - 8usize];
    ["Offset of field: SwsFilter::lumH"][::std::mem::offset_of!(SwsFilter, lumH) - 0usize];
    ["Offset of field: SwsFilter::lumV"][::std::mem::offset_of!(SwsFilter, lumV) - 8usize];
    ["Offset of field: SwsFilter::chrH"][::std::mem::offset_of!(SwsFilter, chrH) - 16usize];
    ["Offset of field: SwsFilter::chrV"][::std::mem::offset_of!(SwsFilter, chrV) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwsContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Return a positive value if pix_fmt is a supported input format, 0\n otherwise."]
    pub fn sws_isSupportedInput(pix_fmt: AVPixelFormat) -> libc::c_int;
}
extern "C" {
    #[doc = " Return a positive value if pix_fmt is a supported output format, 0\n otherwise."]
    pub fn sws_isSupportedOutput(pix_fmt: AVPixelFormat) -> libc::c_int;
}
extern "C" {
    #[doc = " @param[in]  pix_fmt the pixel format\n @return a positive value if an endianness conversion for pix_fmt is\n supported, 0 otherwise."]
    pub fn sws_isSupportedEndiannessConversion(pix_fmt: AVPixelFormat) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate an empty SwsContext. This must be filled and passed to\n sws_init_context(). For filling see AVOptions, options.c and\n sws_setColorspaceDetails()."]
    pub fn sws_alloc_context() -> *mut SwsContext;
}
extern "C" {
    #[doc = " Initialize the swscaler context sws_context.\n\n @return zero or positive value on success, a negative value on\n error"]
    pub fn sws_init_context(
        sws_context: *mut SwsContext,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Free the swscaler context swsContext.\n If swsContext is NULL, then does nothing."]
    pub fn sws_freeContext(swsContext: *mut SwsContext);
}
extern "C" {
    #[doc = " Allocate and return an SwsContext. You need it to perform\n scaling/conversion operations using sws_scale().\n\n @param srcW the width of the source image\n @param srcH the height of the source image\n @param srcFormat the source image format\n @param dstW the width of the destination image\n @param dstH the height of the destination image\n @param dstFormat the destination image format\n @param flags specify which algorithm and options to use for rescaling\n @param param extra parameters to tune the used scaler\n              For SWS_BICUBIC param[0] and [1] tune the shape of the basis\n              function, param[0] tunes f(1) and param[1] f(1)\n              For SWS_GAUSS param[0] tunes the exponent and thus cutoff\n              frequency\n              For SWS_LANCZOS param[0] tunes the width of the window function\n @return a pointer to an allocated context, or NULL in case of error\n @note this function is to be removed after a saner alternative is\n       written"]
    pub fn sws_getContext(
        srcW: libc::c_int,
        srcH: libc::c_int,
        srcFormat: AVPixelFormat,
        dstW: libc::c_int,
        dstH: libc::c_int,
        dstFormat: AVPixelFormat,
        flags: libc::c_int,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
        param: *const f64,
    ) -> *mut SwsContext;
}
extern "C" {
    #[doc = " Scale the image slice in srcSlice and put the resulting scaled\n slice in the image in dst. A slice is a sequence of consecutive\n rows in an image.\n\n Slices have to be provided in sequential order, either in\n top-bottom or bottom-top order. If slices are provided in\n non-sequential order the behavior of the function is undefined.\n\n @param c         the scaling context previously created with\n                  sws_getContext()\n @param srcSlice  the array containing the pointers to the planes of\n                  the source slice\n @param srcStride the array containing the strides for each plane of\n                  the source image\n @param srcSliceY the position in the source image of the slice to\n                  process, that is the number (counted starting from\n                  zero) in the image of the first row of the slice\n @param srcSliceH the height of the source slice, that is the number\n                  of rows in the slice\n @param dst       the array containing the pointers to the planes of\n                  the destination image\n @param dstStride the array containing the strides for each plane of\n                  the destination image\n @return          the height of the output slice"]
    pub fn sws_scale(
        c: *mut SwsContext,
        srcSlice: *const *const u8,
        srcStride: *const libc::c_int,
        srcSliceY: libc::c_int,
        srcSliceH: libc::c_int,
        dst: *const *mut u8,
        dstStride: *const libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)\n @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)\n @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]\n @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]\n @param brightness 16.16 fixed point brightness correction\n @param contrast 16.16 fixed point contrast correction\n @param saturation 16.16 fixed point saturation correction\n @return -1 if not supported"]
    pub fn sws_setColorspaceDetails(
        c: *mut SwsContext,
        inv_table: *const libc::c_int,
        srcRange: libc::c_int,
        table: *const libc::c_int,
        dstRange: libc::c_int,
        brightness: libc::c_int,
        contrast: libc::c_int,
        saturation: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @return -1 if not supported"]
    pub fn sws_getColorspaceDetails(
        c: *mut SwsContext,
        inv_table: *mut *mut libc::c_int,
        srcRange: *mut libc::c_int,
        table: *mut *mut libc::c_int,
        dstRange: *mut libc::c_int,
        brightness: *mut libc::c_int,
        contrast: *mut libc::c_int,
        saturation: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate and return an uninitialized vector with length coefficients."]
    pub fn sws_allocVec(length: libc::c_int) -> *mut SwsVector;
}
extern "C" {
    #[doc = " Return a normalized Gaussian curve used to filter stuff\n quality = 3 is high quality, lower is lower quality."]
    pub fn sws_getGaussianVec(variance: f64, quality: f64) -> *mut SwsVector;
}
extern "C" {
    #[doc = " Scale all the coefficients of a by the scalar value."]
    pub fn sws_scaleVec(a: *mut SwsVector, scalar: f64);
}
extern "C" {
    #[doc = " Scale all the coefficients of a so that their sum equals height."]
    pub fn sws_normalizeVec(a: *mut SwsVector, height: f64);
}
extern "C" {
    pub fn sws_getConstVec(c: f64, length: libc::c_int) -> *mut SwsVector;
}
extern "C" {
    pub fn sws_getIdentityVec() -> *mut SwsVector;
}
extern "C" {
    pub fn sws_convVec(a: *mut SwsVector, b: *mut SwsVector);
}
extern "C" {
    pub fn sws_addVec(a: *mut SwsVector, b: *mut SwsVector);
}
extern "C" {
    pub fn sws_subVec(a: *mut SwsVector, b: *mut SwsVector);
}
extern "C" {
    pub fn sws_shiftVec(a: *mut SwsVector, shift: libc::c_int);
}
extern "C" {
    pub fn sws_cloneVec(a: *mut SwsVector) -> *mut SwsVector;
}
extern "C" {
    pub fn sws_printVec2(a: *mut SwsVector, log_ctx: *mut AVClass, log_level: libc::c_int);
}
extern "C" {
    pub fn sws_freeVec(a: *mut SwsVector);
}
extern "C" {
    pub fn sws_getDefaultFilter(
        lumaGBlur: f32,
        chromaGBlur: f32,
        lumaSharpen: f32,
        chromaSharpen: f32,
        chromaHShift: f32,
        chromaVShift: f32,
        verbose: libc::c_int,
    ) -> *mut SwsFilter;
}
extern "C" {
    pub fn sws_freeFilter(filter: *mut SwsFilter);
}
extern "C" {
    #[doc = " Check if context can be reused, otherwise reallocate a new one.\n\n If context is NULL, just calls sws_getContext() to get a new\n context. Otherwise, checks if the parameters are the ones already\n saved in context. If that is the case, returns the current\n context. Otherwise, frees context and gets a new context with\n the new parameters.\n\n Be warned that srcFilter and dstFilter are not checked, they\n are assumed to remain the same."]
    pub fn sws_getCachedContext(
        context: *mut SwsContext,
        srcW: libc::c_int,
        srcH: libc::c_int,
        srcFormat: AVPixelFormat,
        dstW: libc::c_int,
        dstH: libc::c_int,
        dstFormat: AVPixelFormat,
        flags: libc::c_int,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
        param: *const f64,
    ) -> *mut SwsContext;
}
extern "C" {
    #[doc = " Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.\n\n The output frame will have the same packed format as the palette.\n\n @param src        source frame buffer\n @param dst        destination frame buffer\n @param num_pixels number of pixels to convert\n @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src"]
    pub fn sws_convertPalette8ToPacked32(
        src: *const u8,
        dst: *mut u8,
        num_pixels: libc::c_int,
        palette: *const u8,
    );
}
extern "C" {
    #[doc = " Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.\n\n With the palette format \"ABCD\", the destination frame ends up with the format \"ABC\".\n\n @param src        source frame buffer\n @param dst        destination frame buffer\n @param num_pixels number of pixels to convert\n @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src"]
    pub fn sws_convertPalette8ToPacked24(
        src: *const u8,
        dst: *mut u8,
        num_pixels: libc::c_int,
        palette: *const u8,
    );
}
extern "C" {
    #[doc = " Get the AVClass for swsContext. It can be used in combination with\n AV_OPT_SEARCH_FAKE_OBJ for examining options.\n\n @see av_opt_find()."]
    pub fn sws_get_class() -> *const AVClass;
}
pub const AV_DRM_MAX_PLANES: _bindgen_ty_6 = _bindgen_ty_6::AV_DRM_MAX_PLANES;
#[repr(u32)]
#[doc = " @file\n API-specific header for AV_HWDEVICE_TYPE_DRM.\n\n Internal frame allocation is not currently supported - all frames\n must be allocated by the user.  Thus AVHWFramesContext is always\n NULL, though this may change if support for frame allocation is\n added in future."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_6 {
    #[doc = " The maximum number of layers/planes in a DRM frame."]
    AV_DRM_MAX_PLANES = 4,
}
#[doc = " DRM object descriptor.\n\n Describes a single DRM object, addressing it as a PRIME file\n descriptor."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDRMObjectDescriptor {
    #[doc = " DRM PRIME fd for the object."]
    pub fd: libc::c_int,
    #[doc = " Total size of the object.\n\n (This includes any parts not which do not contain image data.)"]
    pub size: usize,
    #[doc = " Format modifier applied to the object (DRM_FORMAT_MOD_*).\n\n If the format modifier is unknown then this should be set to\n DRM_FORMAT_MOD_INVALID."]
    pub format_modifier: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVDRMObjectDescriptor"][::std::mem::size_of::<AVDRMObjectDescriptor>() - 24usize];
    ["Alignment of AVDRMObjectDescriptor"]
        [::std::mem::align_of::<AVDRMObjectDescriptor>() - 8usize];
    ["Offset of field: AVDRMObjectDescriptor::fd"]
        [::std::mem::offset_of!(AVDRMObjectDescriptor, fd) - 0usize];
    ["Offset of field: AVDRMObjectDescriptor::size"]
        [::std::mem::offset_of!(AVDRMObjectDescriptor, size) - 8usize];
    ["Offset of field: AVDRMObjectDescriptor::format_modifier"]
        [::std::mem::offset_of!(AVDRMObjectDescriptor, format_modifier) - 16usize];
};
#[doc = " DRM plane descriptor.\n\n Describes a single plane of a layer, which is contained within\n a single object."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDRMPlaneDescriptor {
    #[doc = " Index of the object containing this plane in the objects\n array of the enclosing frame descriptor."]
    pub object_index: libc::c_int,
    #[doc = " Offset within that object of this plane."]
    pub offset: isize,
    #[doc = " Pitch (linesize) of this plane."]
    pub pitch: isize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVDRMPlaneDescriptor"][::std::mem::size_of::<AVDRMPlaneDescriptor>() - 24usize];
    ["Alignment of AVDRMPlaneDescriptor"][::std::mem::align_of::<AVDRMPlaneDescriptor>() - 8usize];
    ["Offset of field: AVDRMPlaneDescriptor::object_index"]
        [::std::mem::offset_of!(AVDRMPlaneDescriptor, object_index) - 0usize];
    ["Offset of field: AVDRMPlaneDescriptor::offset"]
        [::std::mem::offset_of!(AVDRMPlaneDescriptor, offset) - 8usize];
    ["Offset of field: AVDRMPlaneDescriptor::pitch"]
        [::std::mem::offset_of!(AVDRMPlaneDescriptor, pitch) - 16usize];
};
#[doc = " DRM layer descriptor.\n\n Describes a single layer within a frame.  This has the structure\n defined by its format, and will contain one or more planes."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDRMLayerDescriptor {
    #[doc = " Format of the layer (DRM_FORMAT_*)."]
    pub format: u32,
    #[doc = " Number of planes in the layer.\n\n This must match the number of planes required by format."]
    pub nb_planes: libc::c_int,
    #[doc = " Array of planes in this layer."]
    pub planes: [AVDRMPlaneDescriptor; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVDRMLayerDescriptor"][::std::mem::size_of::<AVDRMLayerDescriptor>() - 104usize];
    ["Alignment of AVDRMLayerDescriptor"][::std::mem::align_of::<AVDRMLayerDescriptor>() - 8usize];
    ["Offset of field: AVDRMLayerDescriptor::format"]
        [::std::mem::offset_of!(AVDRMLayerDescriptor, format) - 0usize];
    ["Offset of field: AVDRMLayerDescriptor::nb_planes"]
        [::std::mem::offset_of!(AVDRMLayerDescriptor, nb_planes) - 4usize];
    ["Offset of field: AVDRMLayerDescriptor::planes"]
        [::std::mem::offset_of!(AVDRMLayerDescriptor, planes) - 8usize];
};
#[doc = " DRM frame descriptor.\n\n This is used as the data pointer for AV_PIX_FMT_DRM_PRIME frames.\n It is also used by user-allocated frame pools - allocating in\n AVHWFramesContext.pool must return AVBufferRefs which contain\n an object of this type.\n\n The fields of this structure should be set such it can be\n imported directly by EGL using the EGL_EXT_image_dma_buf_import\n and EGL_EXT_image_dma_buf_import_modifiers extensions.\n (Note that the exact layout of a particular format may vary between\n platforms - we only specify that the same platform should be able\n to import it.)\n\n The total number of planes must not exceed AV_DRM_MAX_PLANES, and\n the order of the planes by increasing layer index followed by\n increasing plane index must be the same as the order which would\n be used for the data pointers in the equivalent software format."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDRMFrameDescriptor {
    #[doc = " Number of DRM objects making up this frame."]
    pub nb_objects: libc::c_int,
    #[doc = " Array of objects making up the frame."]
    pub objects: [AVDRMObjectDescriptor; 4usize],
    #[doc = " Number of layers in the frame."]
    pub nb_layers: libc::c_int,
    #[doc = " Array of layers in the frame."]
    pub layers: [AVDRMLayerDescriptor; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVDRMFrameDescriptor"][::std::mem::size_of::<AVDRMFrameDescriptor>() - 528usize];
    ["Alignment of AVDRMFrameDescriptor"][::std::mem::align_of::<AVDRMFrameDescriptor>() - 8usize];
    ["Offset of field: AVDRMFrameDescriptor::nb_objects"]
        [::std::mem::offset_of!(AVDRMFrameDescriptor, nb_objects) - 0usize];
    ["Offset of field: AVDRMFrameDescriptor::objects"]
        [::std::mem::offset_of!(AVDRMFrameDescriptor, objects) - 8usize];
    ["Offset of field: AVDRMFrameDescriptor::nb_layers"]
        [::std::mem::offset_of!(AVDRMFrameDescriptor, nb_layers) - 104usize];
    ["Offset of field: AVDRMFrameDescriptor::layers"]
        [::std::mem::offset_of!(AVDRMFrameDescriptor, layers) - 112usize];
};
#[doc = " DRM device.\n\n Allocated as AVHWDeviceContext.hwctx."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDRMDeviceContext {
    #[doc = " File descriptor of DRM device.\n\n This is used as the device to create frames on, and may also be\n used in some derivation and mapping operations.\n\n If no device is required, set to -1."]
    pub fd: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVDRMDeviceContext"][::std::mem::size_of::<AVDRMDeviceContext>() - 4usize];
    ["Alignment of AVDRMDeviceContext"][::std::mem::align_of::<AVDRMDeviceContext>() - 4usize];
    ["Offset of field: AVDRMDeviceContext::fd"]
        [::std::mem::offset_of!(AVDRMDeviceContext, fd) - 0usize];
};
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __locale_data {
    pub _address: u8,
}
#[doc = " Array of pointers to hardware configurations supported by the codec,\n or NULL if no hardware supported.  The array is terminated by a NULL\n pointer.\n\n The user can only access this field via avcodec_get_hw_config()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodecHWConfigInternal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct URLContext {
    pub _address: u8,
}
